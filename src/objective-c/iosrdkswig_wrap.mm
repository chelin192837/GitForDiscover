/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



#import <Foundation/Foundation.h>
#include <stdlib.h>
#include <string.h>


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) { /*throw exception*/ return nullreturn; } else


/* Support for throwing Objc exceptions */
typedef enum {
  SWIG_ObjcOutOfMemoryError = 1, 
  SWIG_ObjcIOException, 
  SWIG_ObjcRuntimeException, 
  SWIG_ObjcIndexOutOfBoundsException,
  SWIG_ObjcArithmeticException,
  SWIG_ObjcIllegalArgumentException,
  SWIG_ObjcNullPointerException,
  SWIG_ObjcDirectorPureVirtual,
  SWIG_ObjcUnknownError
} SWIG_ObjcExceptionCodes;

typedef struct {
  SWIG_ObjcExceptionCodes code;
  const char *Objc_exception;
} SWIG_ObjcExceptions_t;


static void SWIGUNUSED SWIG_ObjcThrowException(SWIG_ObjcExceptionCodes code, const char *msg) {
  static const SWIG_ObjcExceptions_t Objc_exceptions[] = {
    { SWIG_ObjcOutOfMemoryError, "OutOfMemoryError" },
    { SWIG_ObjcIOException, "IOException" },
    { SWIG_ObjcRuntimeException, "RuntimeException" },
    { SWIG_ObjcIndexOutOfBoundsException, "IndexOutOfBoundsException" },
    { SWIG_ObjcArithmeticException, "ArithmeticException" },
    { SWIG_ObjcIllegalArgumentException, "IllegalArgumentException" },
    { SWIG_ObjcNullPointerException, "NullPointerException" },
    { SWIG_ObjcDirectorPureVirtual, "RuntimeException" },
    { SWIG_ObjcUnknownError,  "UnknownError" },
    { (SWIG_ObjcExceptionCodes)0,  "UnknownError" }
  };
  const SWIG_ObjcExceptions_t *except_ptr = Objc_exceptions;
  while (except_ptr->code != code && except_ptr->code)
   except_ptr++;
    
    @throw  [NSException exceptionWithName:[NSString stringWithCString:except_ptr->Objc_exception encoding:NSUTF8StringEncoding]
                        reason:[NSString stringWithCString:msg encoding:NSUTF8StringEncoding]
                        userInfo:nil];
}

#define THROWEXCEPTION_IF_NULLPOINTER(param1) if(!param1) SWIG_ObjcThrowException(SWIG_ObjcNullPointerException,0);
#define THROWEXCEPTION_IF_NULLPOINTER1(param1,param2) if(!param1 || !param2) SWIG_ObjcThrowException(SWIG_ObjcNullPointerException,0);
#define THROWEXCEPTION_IF_NULLPOINTER2(param1,param2,param3) if(!param1 || !param2 || !param3) SWIG_ObjcThrowException(SWIG_ObjcNullPointerException,0);

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13




#import <CoreGraphics/CoreGraphics.h>

#include "iosrdkswig_wrap.h"

#include <stdexcept>


#include <deque>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>
#include "OfdSeal.hpp"

SWIGINTERN void SWIG_ObjcException(int code, const char *msg) {
  SWIG_ObjcExceptionCodes exception_code = SWIG_ObjcUnknownError;
  switch(code) {
  case SWIG_MemoryError:
    exception_code = SWIG_ObjcOutOfMemoryError;
    break;
  case SWIG_IOError:
    exception_code = SWIG_ObjcIOException;
    break;
  case SWIG_SystemError:
  case SWIG_RuntimeError:
    exception_code = SWIG_ObjcRuntimeException;
    break;
  case SWIG_OverflowError:
  case SWIG_IndexError:
    exception_code = SWIG_ObjcIndexOutOfBoundsException;
    break;
  case SWIG_DivisionByZero:
    exception_code = SWIG_ObjcArithmeticException;
    break;
  case SWIG_SyntaxError:
  case SWIG_ValueError:
  case SWIG_TypeError:
    exception_code = SWIG_ObjcIllegalArgumentException;
    break;
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_ObjcUnknownError;
    break;
  }
  SWIG_ObjcThrowException(exception_code, msg);
}


#include <stdexcept>


#include <utility>


#include <string>


#include <vector>
#include <stdexcept>


#include "../../include/common.h"
#include "../../include/fs_action.h"
#include "../../include/fs_annot.h"
#include "../../include/fs_bookmark.h"
#include "../../include/fs_pdfdoc.h"
#include "../../include/fs_pdfobject.h"
#include "../../include/fs_pdfpage.h"
#include "../../include/fs_render.h"
#include "../../include/fs_search.h"
#include "../../include/fs_pdfform.h"
#include "../../include/fs_formfiller.h"
#include "../../include/fs_readingbookmark.h"
#include "../../include/fs_signature.h"

#include <openssl/ssl.h>
#include <openssl/rsa.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/pkcs12.h>
#include <openssl/rand.h>
#include <openssl/ts.h>
#include <openssl/pkcs7.h>
#include <openssl/stack.h>
#include <crypto/ts/ts_lcl.h>

#ifdef __cplusplus
extern "C" {
#endif

class FSNotifierImpl: public FSNotifier
{
public:
    FSNotifierImpl(id obj) {m_obj = obj;}
    /** @brief Release itself by SDK. */
    virtual void			release()
    {
        
    }
        
    /** @brief	Be called when SDK run out of the memory. */
    virtual void			OnOutOfMemory()
    {
        [m_obj OnOutOfMemory];
        NSException *e = [NSException
                          exceptionWithName:@"OutOfMemory"
                          reason:@"Run out of the memory"
                          userInfo:nil];
        @throw e;
        
    }
protected:
    id m_obj;
};
    
class FSFileReadImpl: public FSFileRead
{
public:
    FSFileReadImpl() { m_pCallback = nil; }
    FSFileReadImpl(FSFileReadCallback* callback): m_pCallback(callback) {}
    
    virtual FS_UINT64	getSize()
    {
        return (FS_UINT64)[m_pCallback getSize];
    }
    
    virtual FS_BOOL		readBlock(void* buffer, FS_UINT64 offset, FS_UINT64 size)
    {
        NSData* data = [m_pCallback readBlock:offset size:size];
        if (nil == data)
            return false;
        memcpy(buffer, data.bytes, data.length);
        return data.length > 0;
    }
    
    virtual void		release()
    {
        //[m_pCallback release];
    }
    
private:
    FSFileReadCallback* m_pCallback;
};

FSFileReadImpl gFSFileRead;

class FSPauseImpl: public FSPause
{
public:
    FSPauseImpl() { m_pCallback = nil; }
    FSPauseImpl(FSPauseCallback* callback): m_pCallback(callback) {}
    
    virtual FS_BOOL needPauseNow()
    {
        return [m_pCallback needPauseNow];
    }
    
private:
    FSPauseCallback* m_pCallback;
};

FSPauseImpl gFSPause;

class FSAnnotIconProviderImpl: public FSAnnotIconProvider
{
public:
    FSAnnotIconProviderImpl() { m_pCallback = nil; }
    FSAnnotIconProviderImpl(FSAnnotIconProviderCallback* pCallback) {
        m_pCallback = pCallback;
    }
    
    virtual void release() {
        //[m_pCallback release];
    }
    
    virtual FSString getProviderID() {
        FSString fsID;
        NSString* nsID = [m_pCallback getProviderID];
        if (nsID) {
            fsID = [nsID UTF8String];
        }
        return fsID;
    }
    
    virtual FSString getProviderVersion() {
        FSString fsVer;
        NSString* nsVer = [m_pCallback getProviderVersion];
        if (nsVer) {
            fsVer = [nsVer UTF8String];
        }
        return fsVer;
    }
    
    virtual FS_BOOL hasIcon(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        return [m_pCallback hasIcon:annotType iconName:nsName];
    }
    
    virtual FS_BOOL canChangeColor(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        return [m_pCallback canChangeColor:annotType iconName:nsName];
    }
    
    virtual FSPDFPage* getIcon(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName, FS_ARGB color) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        return (FSPDFPage*)[[m_pCallback getIcon:annotType iconName:nsName color:color] getCptr];
    }
    
    virtual FS_BOOL getShadingColor(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName, FS_ARGB refColor, FS_INT32 shadingIndex, FSShadingColor& shadingColor) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        id shColor = [m_pCallback getShadingColor:annotType iconName:nsName refColor:refColor shadingIndex:shadingIndex];
        
        if(!shColor)
            return false;
        FS_ARGB firstColor = (size_t)(__bridge void*)[shColor getFirstColor];
        FS_ARGB secondColor = (size_t)(__bridge void*)[shColor getSecondColor];
        shadingColor.firstColor = firstColor;
        shadingColor.secondColor = secondColor;
        return true;
    }
    
    virtual FS_FLOAT getDisplayWidth(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        NSNumber* number = [m_pCallback getDisplayWidth:annotType iconName:nsName];
        return [number floatValue];
    }
    
    virtual FS_FLOAT getDisplayHeight(FSAnnot::FS_ANNOTTYPE annotType, const char* iconName) {
        NSString* nsName = iconName?[NSString stringWithUTF8String:iconName]:nil;
        NSNumber* number = [m_pCallback getDisplayHeight:annotType iconName:nsName];
        return [number floatValue];
    }
    
private:
    FSAnnotIconProviderCallback* m_pCallback;
};

FSAnnotIconProviderImpl gFSAnnotIconProvider;

void* _wrap_FSNotifier_init(id obj)
{
    return new FSNotifierImpl(obj);
}

void _wrap_FSNotifier_OnOutOfMemory(void* imarg1)
{
  FSNotifier *arg1 = (FSNotifier *) 0 ;
  
  arg1 = (FSNotifier *)imarg1; 
  (arg1)->OnOutOfMemory();
}

void _wrap_delete_FSNotifier(void* imarg1)
{
  FSNotifier *arg1 = (FSNotifier *) 0 ;
  
  arg1 = (FSNotifier *)imarg1; 
  delete arg1;
}

int _wrap_FSLibrary_init(NSString * imarg1, NSString * imarg2)
{
  char const *arg1 = (char const *) 0 ;
  char const *arg2 = (char const *) 0 ;
  int imresult = 0 ;
  FS_ERRORCODE result;
  
  {
    arg1 = 0;
    if (imarg1) {
      arg1 = [imarg1 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_ERRORCODE)FSLibrary::init((char const *)arg1,(char const *)arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSLibrary_reinit()
{
    int imresult = 0 ;
    FS_ERRORCODE result;
    
    result = (FS_ERRORCODE)FSLibrary::reinit();
    imresult = (int)result;
    return imresult;
}

void _wrap_FSLibrary_release()
{
  FSLibrary::release();
}
    
NSString* _wrap_FSLibrary_getVersion()
{
    FSString str = FSLibrary::getVersion();
    if(!str.getBufferLen())
        return nil;
    return [NSString stringWithUTF8String: (const char*)(str.getBuffer())];
}
    
int _wrap_FSLibrary_getModuleRight(int imarg1)
{
  FS_MODULENAME arg1 ;
  int imresult = 0 ;
  FS_MODULERIGHT result;
  
  arg1 = (FS_MODULENAME)imarg1; 
  result = (FS_MODULERIGHT)FSLibrary::getModuleRight(arg1);
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_FSLibrary_setAnnotIconProvider(FSAnnotIconProviderCallback* imarg1)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
    if (imarg1)
    {
        gFSAnnotIconProvider = imarg1;
        arg1 = &gFSAnnotIconProvider;
    }
  result = (FS_BOOL)FSLibrary::setAnnotIconProvider(arg1);
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSLibrary_setNotifier(void* imarg1)
{
  FSNotifier *arg1 = (FSNotifier *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSNotifier *)imarg1; 
  result = (FS_BOOL)FSLibrary::setNotifier(arg1);
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSLibrary_addExtFont(NSString * filepath)
{
    int  errorcode = 0;
    const char * path = [filepath UTF8String];
    errorcode = (int)FSLibrary::addExtFont(path);
    return errorcode;
}

class FSActionHandlerImp: public FSActionHandler
{
public:
    FSActionHandlerImp(id objcImp) { m_objcImp = objcImp; }
    
    virtual void release() {
        m_cIP.corporation.clear();
        m_cIP.email.clear();
        m_cIP.loginName.clear();
        m_cIP.name.clear();
        delete this;
    }
    virtual	FS_INT32 getCurrentPage(FSPDFDoc* pdfDoc)
    {
        return FSActionHandler_getCurrentPage(m_objcImp, pdfDoc);
    }

    virtual	void setCurrentPage(FSPDFDoc* pdfDoc, FS_INT32 pageIndex)
    {
        FSActionHandler_setCurrentPage(m_objcImp, pdfDoc, pageIndex);
    }

    virtual FS_ROTATION getPageRotation(FSPDFDoc* pdfDoc, FS_INT32 pageIndex)
    {
        return (FS_ROTATION)FSActionHandler_getPageRotation(m_objcImp, pdfDoc, pageIndex);
    }

    virtual FS_BOOL setPageRotation(FSPDFDoc* pdfDoc, FS_INT32 pageIndex, FS_ROTATION rotation)
    {
        return FSActionHandler_setPageRotation(m_objcImp, pdfDoc, pageIndex, rotation);
    }

    virtual FS_INT32 alert(const char* msg, const char* title, FS_INT32 type, FS_INT32 icon)
    {
        NSString* nsMsg = [[NSString alloc] initWithUTF8String:msg];
        NSString* nsTitle = [[NSString alloc] initWithUTF8String:title];
        return FSActionHandler_alert(m_objcImp, nsMsg, nsTitle, type, icon);
    }
    
    virtual FSIdentityProperties getIdentityProperties()
    {
        m_cIP.set(NULL, NULL, NULL, NULL);
        id objcIP = [m_objcImp getIdentityProperties];
        m_cIP.corporation = [[objcIP getCorporation] UTF8String];
        m_cIP.email = [[objcIP getEmail] UTF8String];
        m_cIP.loginName = [[objcIP getLoginName] UTF8String];
        m_cIP.name = [[objcIP getName] UTF8String];
        return m_cIP;
    }
    
private:
    FSIdentityProperties m_cIP;
    id m_objcImp;
};
    
BOOL _wrap_FSLibrary_setActionHandler(id imarg1)
{
    FSActionHandlerImp* pActionHandlerImp = new FSActionHandlerImp(imarg1);
    return FSLibrary::setActionHandler(pActionHandlerImp);
}

class FSSignatureHandlerImp:public FSSignatureHandler
{
public:
    FSSignatureHandlerImp()
    {
        m_nRef = 1;
    }
    void addRef() {m_nRef++;}
    virtual void	release()
    {
        m_nRef--;
        if(!m_nRef)
            delete this;
    }
    virtual FS_BOOL	startCalcDigest(FSFileRead* file, const FS_DWORD* byteRangeArray, FS_DWORD sizeofArray, FSSignature* signature, void* clientData)
    {
        if (!file || !byteRangeArray || 0 == sizeofArray || !signature)
            return FALSE;
        if(!SHA1_Init(&m_sSHA_CTX))
            return FALSE;
        m_byteArray = byteRangeArray;
        m_file = file;
        m_signature = signature;
        return TRUE;
    }
    
    virtual FS_PROGRESSSTATE continueCalcDigest(FSPause* pause, void* clientData)
    {
        
        FSString subFilter = m_signature->getKeyValue(e_signatureKeyNameSubFilter);
        if(strcmp(subFilter.getBuffer(),"adbe.pkcs7.detached") == 0)
            return e_progressFinished;
        
        if (!m_byteArray)
            return e_progressError;
        int nFileLength = m_byteArray[1]+m_byteArray[3];
        unsigned char* pbFileBuffer = (unsigned char*)malloc(nFileLength);
        
        if(!m_file->readBlock(pbFileBuffer, m_byteArray[0], m_byteArray[1]))
        {
            free(pbFileBuffer);
            return e_progressError;
        }
        if(!m_file->readBlock(pbFileBuffer+m_byteArray[1], m_byteArray[2], m_byteArray[3]))
        {
            free(pbFileBuffer);
            return e_progressError;
        }
        
        SHA1_Update(&m_sSHA_CTX, pbFileBuffer, nFileLength);
        free(pbFileBuffer);
        
        
        return e_progressFinished;
    }
    

    virtual FSString getDigest(void* clientData) 
    {
        unsigned char *md = (unsigned char *)OPENSSL_malloc((SHA_DIGEST_LENGTH)*sizeof(unsigned char));
        int len = SHA1_Final(md, &m_sSHA_CTX);
        if (len != 1)
            return "";
        FSString digest = FSString((const char*)md, SHA_DIGEST_LENGTH);
        OPENSSL_free(md);
        return digest;
    }

    virtual FSString sign(void* digest, FS_DWORD digestLen, const char* certPath, const char password[], FS_INT32 passwordLen, FS_DIGEST_ALGORITHM digestAlgorithm, void* clientData)
    {
        if(!m_signature || !m_byteArray)
            return "";
        FSString subFilter = m_signature->getKeyValue(e_signatureKeyNameSubFilter);
        if(strcmp(subFilter.getBuffer(), "adbe.pkcs7.detached") == 0)
        {
            int nFileLength = m_byteArray[1]+m_byteArray[3];
            unsigned char* pbFileBuffer = (unsigned char*)malloc(nFileLength);
            
            if(!m_file->readBlock(pbFileBuffer, m_byteArray[0], m_byteArray[1]))
            {
                free(pbFileBuffer);
                return "";
            }
            if(!m_file->readBlock(pbFileBuffer+m_byteArray[1], m_byteArray[2], m_byteArray[3]))
            {
                free(pbFileBuffer);
                return "";
            }
            
            int signedDataLen = 0;
            unsigned char* signedData = PKCS7_Sign(pbFileBuffer, nFileLength, signedDataLen, FALSE, certPath, password, passwordLen, digestAlgorithm);
            FSString signedStr((const char*)signedData, signedDataLen);
            free(signedData);
            return signedStr;
        }
        
        if(strcmp(subFilter.getBuffer(),"adbe.pkcs7.sha1") == 0)
        {
            int signedDataLen = 0;
            unsigned char* signedData = PKCS7_Sign(digest, digestLen, signedDataLen, FALSE, certPath, password, passwordLen, digestAlgorithm);
            FSString signedStr((const char*)signedData, signedDataLen);
            free(signedData);
            return signedStr;
        }
        
        return "";
    }
    
    virtual FS_DWORD verify(void* digest, FS_DWORD digestLen, void* signedData, FS_DWORD signDataLen, void* clientData)
    {
        if(!m_signature || !m_byteArray)
            return e_signatureStateVerifyInvalid;
        FSString subFilter = m_signature->getKeyValue(e_signatureKeyNameSubFilter);
        if(strcmp(subFilter.getBuffer(),"adbe.pkcs7.detached") == 0)
        {
            int nFileLength = m_byteArray[1]+m_byteArray[3];
            unsigned char* pbFileBuffer = (unsigned char*)malloc(nFileLength);
            
            if(!m_file->readBlock(pbFileBuffer, m_byteArray[0], m_byteArray[1]))
            {
                free(pbFileBuffer);
                return e_signatureStateVerifyErrorData;
            }
            if(!m_file->readBlock(pbFileBuffer+m_byteArray[1], m_byteArray[2], m_byteArray[3]))
            {
                free(pbFileBuffer);
                return e_signatureStateVerifyErrorData;
            }
            
            if(PKCS7_VerifySig(signedData, signDataLen, pbFileBuffer, nFileLength, FALSE))
                return e_signatureStateVerifyValid;
            return e_signatureStateVerifyInvalid;
        }
        
        if(strcmp(subFilter.getBuffer(),"adbe.pkcs7.sha1") == 0)
        {
            if(PKCS7_VerifySig(signedData, signDataLen, digest, digestLen, FALSE))
                return e_signatureStateVerifyValid;
            return e_signatureStateVerifyInvalid;
        }
        return e_signatureStateUnknown;
    }
    
protected:
    
    struct tm asn1TimeToC(ASN1_TIME* time)
    {
        struct tm t = {0};
        const char* str = (const char*) time->data;
        size_t i = 0;
        
        if (time->type == V_ASN1_UTCTIME) {/* two digit year */
            t.tm_year = (str[i++] - '0') * 10;
            t.tm_year += (str[i++] - '0');
            if (t.tm_year < 70)
                t.tm_year += 100;
        } else if (time->type == V_ASN1_GENERALIZEDTIME) {/* four digit year */
            t.tm_year = (str[i++] - '0') * 1000;
            t.tm_year+= (str[i++] - '0') * 100;
            t.tm_year+= (str[i++] - '0') * 10;
            t.tm_year+= (str[i++] - '0');
            t.tm_year -= 1900;
        }
        t.tm_mon  = (str[i++] - '0') * 10;
        t.tm_mon += (str[i++] - '0') - 1; // -1 since January is 0 not 1.
        t.tm_mday = (str[i++] - '0') * 10;
        t.tm_mday+= (str[i++] - '0');
        
        return t;
    }
    bool checkCertTime(X509* x509, bool isForSign)
    {
        time_t timer;
        struct tm *tLocal;
        struct tm temp;
        timer = time(NULL);

        if(isForSign)
            tLocal = localtime(&timer);
        else
        {
            FSDateTime date = m_signature->getSigningTime();
            temp.tm_year = date.year - 1900;
            temp.tm_mon = date.month;
            temp.tm_mday = date.day;
            tLocal = &temp;
        }
        ASN1_TIME *beforeTime = X509_getm_notBefore(x509);
        struct tm tBefore = asn1TimeToC(beforeTime);
        
        ASN1_TIME *afterTime = X509_getm_notAfter(x509);
        struct tm tAfter = asn1TimeToC(afterTime);
        
        if( tLocal->tm_year > tAfter.tm_year)
            return false;
        else if(tLocal->tm_year == tAfter.tm_year)
        {
            if( tLocal->tm_mon > tAfter.tm_mon)
                return false;
            else if(tLocal->tm_mon == tAfter.tm_mon)
            {
                if( tLocal->tm_mday > tAfter.tm_mday)
                    return false;
            }
        }
        
        if( tLocal->tm_year < tBefore.tm_year)
            return false;
        else if(tLocal->tm_year == tBefore.tm_year)
        {
            if( tLocal->tm_mon < tBefore.tm_mon)
                return false;
            else if(tLocal->tm_mon == tBefore.tm_mon)
            {
                if( tLocal->tm_mday < tBefore.tm_mday)
                    return false;
            }
        }
        
        return true;
    }

    unsigned char* PKCS7_Sign(void* bufferToSign, int bufflen, int& retSize, FS_BOOL onlyTS, const char* certificatePath, const char password[], FS_INT32 passwordLen, FS_DIGEST_ALGORITHM digestAlgorithm)
    {
        PKCS7* p7;
        TS_RESP *tsp = NULL;
        if (onlyTS)
        {
            //unsigned char *pTSRep = NULL;
            //long lTSRepLength = Get_TS_REP((unsigned char *)plainText->str,plainText->len, tsParam, &pTSRep);
            //if (lTSRepLength == 0)
            //    return NULL;
            //tsp = d2i_TS_RESP(NULL, (const unsigned char**)&pTSRep, lTSRepLength);
            
            //p7 = tsp->token;
        }
        else{
            int err = 0;
            
            EVP_PKEY* pkey = NULL;
            X509* x509 = NULL;
            STACK_OF(X509)* ca = NULL;
            
            if(!m_signature) return NULL;
            FSString certPath(certificatePath);
            FSString certPassword(password, passwordLen);
            
            if(!parseP12File(certPath, certPassword, &pkey, &x509, &ca))
                return NULL;
            if (!checkCertTime(x509, true))
                return NULL;
            
            p7 = PKCS7_new();
            PKCS7_set_type(p7, NID_pkcs7_signed);
            PKCS7_content_new(p7, NID_pkcs7_data);
            
            //Application should not judge the sign algorithm with the content's length.
            //Here, just for convenient;
            if (bufflen > 32)
                PKCS7_ctrl(p7, PKCS7_OP_SET_DETACHED_SIGNATURE, 1, NULL);
            
            const EVP_MD* md = NULL;
            switch(digestAlgorithm)
            {
                case e_digestSHA1:
                    md = EVP_sha1();
                    break;
                case e_digestSHA256:
                    md = EVP_sha256();
                    break;
                case e_digestSHA384:
                    md = EVP_sha384();
                    break;
                case e_digestSHA512:
                    md = EVP_sha512();
                    break;
                default:
                    md = EVP_sha1();
                    break;
            }
            PKCS7_SIGNER_INFO* info = PKCS7_add_signature(p7, x509, pkey, md);
            PKCS7_add_certificate(p7, x509);
            
            for (int i = 0; i< OPENSSL_sk_num((const OPENSSL_STACK*)ca); i++)
                PKCS7_add_certificate(p7, (X509*)OPENSSL_sk_value((const OPENSSL_STACK*)ca, i));
            
            //Set source data to BIO.
            BIO* p7bio = PKCS7_dataInit(p7, NULL);
            BIO_write(p7bio, bufferToSign,bufflen);
            PKCS7_dataFinal(p7, p7bio);
            
            //if (tsParam->TSType)
            //{
                //append the time stamp token to pkcs7 structure.
             //   unsigned char md256[32] = "";
             //   SHA256(info->enc_digest->data, info->enc_digest->length, md256);
                
             //   unsigned char *pTSRep = NULL;
             //   long lTSRepLength = Get_TS_REP(md256,32, tsParam, &pTSRep);
             //   if (lTSRepLength != 0)
             //       append_tsp_token(info,pTSRep,lTSRepLength );
             //   OPENSSL_free(pTSRep);
            //}
            
            //FREE_CERT_KEY;
            BIO_free_all(p7bio); 
        }
        //Get Signed data.
        unsigned char* der = NULL;  
        unsigned char* derTmp = NULL;  
        unsigned long derlen = i2d_PKCS7(p7, NULL);  
        der = (unsigned char*)malloc(derlen);  
        memset(der, 0, derlen);
        derTmp = der;  
        i2d_PKCS7(p7, &derTmp);
        if (tsp)
        {
            TS_RESP_free(tsp);
        }
        else
            PKCS7_free(p7);   
        
        
        retSize = derlen;
        return (unsigned char*)der;
    }
    
    FS_BOOL PKCS7_VerifySig(const void* signedData, int signedDataLen, const void* plainData, int plainDataLen, FS_BOOL onlyTs)
    {
        FS_BOOL bSigAppr = FALSE;
        int length = 0;
        const unsigned char *p = NULL;
        
        //Retain PKCS7 object from signed data.
        BIO* vin = BIO_new_mem_buf(signedData, signedDataLen);
        PKCS7* p7 = d2i_PKCS7_bio(vin, NULL);
        
        STACK_OF(PKCS7_SIGNER_INFO) *sk = PKCS7_get_signer_info(p7);
        int signCount = sk_PKCS7_SIGNER_INFO_num(sk);
        
        if(onlyTs)
        {
            BIO* p7bio = PKCS7_dataDecode(p7, 0, 0, 0);
            unsigned char src[1024]="";
            length =BIO_read(p7bio,src,1024);
            
            p=src;
            TS_TST_INFO *req = d2i_TS_TST_INFO (NULL,(const unsigned char **)&p, length);
            //if time stamp is correct, time string is in req->time->data.
            if (!memcmp(plainData, req->msg_imprint->hashed_msg->data, plainDataLen))
                bSigAppr = TRUE;
            BIO_free(p7bio);
        }
        else
        {
            for(int i=0;i<signCount; i++)
            {
                PKCS7_SIGNER_INFO *signInfo = sk_PKCS7_SIGNER_INFO_value(sk,i);
                
                ASN1_TYPE *tstoken = PKCS7_get_attribute(signInfo, NID_id_smime_aa_timeStampToken);
                if (tstoken)//verify the time stamp token.
                {
                    FS_BOOL bTSAvail = FALSE;
                    ASN1_STRING *set = (ASN1_STRING *)(tstoken->value.set);
                    length = ASN1_STRING_length(set);
                    const unsigned char * tstokeng = ASN1_STRING_get0_data(set);
                    
                    p = tstokeng;
                    PKCS7* tsp7 = d2i_PKCS7(NULL, (const unsigned char**)&p, length);
                    
                    BIO* p7bio = PKCS7_dataDecode(tsp7, 0, 0, 0);
                    unsigned char src[1024]="";
                    length =BIO_read(p7bio,src,1024);
                    
                    p=src;
                    TS_TST_INFO *req = d2i_TS_TST_INFO (NULL,(const unsigned char **)&p, length);
                    //if time stamp is correct, time string is in req->time->data.
                    if (req->msg_imprint->hashed_msg->length == 20)
                    {
                        unsigned char md[20];
                        SHA1(signInfo->enc_digest->data,signInfo->enc_digest->length,md);
                        if (!memcmp(md, req->msg_imprint->hashed_msg->data, 20))
                            bTSAvail = TRUE;
                    }
                    else if (req->msg_imprint->hashed_msg->length == 32)
                    {
                        unsigned char md[32];
                        SHA256(signInfo->enc_digest->data,signInfo->enc_digest->length,md);
                        if (!memcmp(md, req->msg_imprint->hashed_msg->data, 32))
                            bTSAvail = TRUE;
                    }
                    BIO_free(p7bio);
                    PKCS7_free(tsp7); 
                }
                
                BIO *p7bio = BIO_new_mem_buf(plainData, plainDataLen);;
                X509 *x509= PKCS7_cert_from_signer_info(p7,signInfo);
                if(!checkCertTime(x509, false))
                    return false;
                int err = PKCS7_verify(p7, NULL, NULL,p7bio, NULL, PKCS7_NOVERIFY); 
                if(err == 1)
                {
                    bSigAppr = TRUE;
                }
                BIO_free(p7bio);
            }
            
            PKCS7_free(p7);            
            BIO_free(vin);    
        }
        
        return bSigAppr;  
    }
    
    int parseP12File(FSString path, FSString pwd, EVP_PKEY** pkey, X509** x509, STACK_OF(X509)** ca)
    {
        FILE* fp = NULL;
        if (!(fp = fopen(path.getBuffer(), "rb")))
        {
            fprintf(stderr, "Error opening file %s\n", path.getBuffer());
            return 0;
        }
        
        PKCS12* p12 = d2i_PKCS12_fp(fp, NULL);
        fclose (fp);
        if (!p12)
        {
            fprintf(stderr, "Error reading PKCS#12 file\n");
            ERR_print_errors_fp (stderr);
            return 0;
        }
        
        if (!PKCS12_parse(p12, pwd.getBuffer(), pkey, x509, ca)) {
            fprintf(stderr, "Error parsing PKCS#12 file\n");
            return 0; 
        }   
        
        PKCS12_free(p12); 
        if (!pkey) {   
            ERR_print_errors_fp (stderr);  
            return 0;
        }
        return 1;
    }
    
private:
    SHA_CTX m_sSHA_CTX;
    const FS_DWORD* m_byteArray;
    FS_DWORD m_sizeOfArray;
    FSFileRead* m_file;
    FSSignature* m_signature;
    int m_nRef;
};
    
BOOL _wrap_FSLibrary_registerDefaultSignatureHandler()
{
    BOOL imresult = 0 ;
    FS_BOOL result;
    
#if 0
    result = (FS_BOOL)FSLibrary::registerDefaultSignatureHandler();
#else
    FSSignatureHandlerImp* sigHandler = new FSSignatureHandlerImp();

    //Initialize openssl.
    //SSL_library_init();
    //ERR_load_ERR_strings();
    //ERR_load_crypto_strings();
    sigHandler->addRef();
    result = (FS_BOOL)FSLibrary::registerSignatureHandler("Adobe.PPKLite", "adbe.pkcs7.sha1", sigHandler);
    if(!result) return NO;
    sigHandler->addRef();
    result = (FS_BOOL)FSLibrary::registerSignatureHandler("Adobe.PPKLite", "adbe.pkcs7.detached", sigHandler);
    if(!result) return NO;
#endif
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_new_FSLibrary()
{
  void* imresult = 0 ;
  FSLibrary *result = 0 ;
  
  result = (FSLibrary *)new FSLibrary();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSLibrary(void* imarg1)
{
  FSLibrary *arg1 = (FSLibrary *) 0 ;
  
  arg1 = (FSLibrary *)imarg1; 
  delete arg1;
}

void _wrap_FSPointF_set(void* imarg1, float imarg2, float imarg3)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  
  arg1 = (_FSPointF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3;
  (arg1)->set(arg2,arg3);
}

void _wrap_FSPointF_x_set(void* imarg1, float imarg2)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSPointF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->x = arg2;
}

float _wrap_FSPointF_x_get(void* imarg1)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSPointF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->x);
  imresult = result; 
  return imresult;
}

void _wrap_FSPointF_y_set(void* imarg1, float imarg2)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSPointF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->y = arg2;
}

float _wrap_FSPointF_y_get(void* imarg1)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSPointF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->y);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSPointF()
{
  void* imresult = 0 ;
  _FSPointF *result = 0 ;
  
  result = (_FSPointF *)new _FSPointF();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSPointF(void* imarg1)
{
  _FSPointF *arg1 = (_FSPointF *) 0 ;
  
  arg1 = (_FSPointF *)imarg1; 
  delete arg1;
}

void _wrap_FSRectF_set(void* imarg1, float imarg2, float imarg3, float imarg4, float imarg5)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  FS_FLOAT arg5 ;
  
  arg1 = (_FSRectF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  arg5 = (FS_FLOAT)imarg5; 
  (arg1)->set(arg2,arg3,arg4,arg5);
}

void _wrap_FSRectF_left_set(void* imarg1, float imarg2)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSRectF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->left = arg2;
}

float _wrap_FSRectF_left_get(void* imarg1)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSRectF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->left);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectF_bottom_set(void* imarg1, float imarg2)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSRectF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->bottom = arg2;
}

float _wrap_FSRectF_bottom_get(void* imarg1)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSRectF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->bottom);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectF_right_set(void* imarg1, float imarg2)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSRectF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->right = arg2;
}

float _wrap_FSRectF_right_get(void* imarg1)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSRectF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->right);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectF_top_set(void* imarg1, float imarg2)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSRectF *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->top = arg2;
}

float _wrap_FSRectF_top_get(void* imarg1)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSRectF *)imarg1; 
  result = (FS_FLOAT) ((arg1)->top);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSRectF()
{
  void* imresult = 0 ;
  _FSRectF *result = 0 ;
  
  result = (_FSRectF *)new _FSRectF();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSRectF(void* imarg1)
{
  _FSRectF *arg1 = (_FSRectF *) 0 ;
  
  arg1 = (_FSRectF *)imarg1; 
  delete arg1;
}

void _wrap_FSRectI_set(void* imarg1, int imarg2, int imarg3, int imarg4, int imarg5)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  FS_INT32 arg2 ;
  FS_INT32 arg3 ;
  FS_INT32 arg4 ;
  FS_INT32 arg5 ;
  
  arg1 = (_FSRectI *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_INT32)imarg3; 
  arg4 = (FS_INT32)imarg4; 
  arg5 = (FS_INT32)imarg5; 
  (arg1)->set(arg2,arg3,arg4,arg5);
}

void _wrap_FSRectI_left_set(void* imarg1, int imarg2)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSRectI *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->left = arg2;
}

int _wrap_FSRectI_left_get(void* imarg1)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSRectI *)imarg1; 
  result = (FS_INT32) ((arg1)->left);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectI_top_set(void* imarg1, int imarg2)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSRectI *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->top = arg2;
}

int _wrap_FSRectI_top_get(void* imarg1)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSRectI *)imarg1; 
  result = (FS_INT32) ((arg1)->top);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectI_right_set(void* imarg1, int imarg2)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSRectI *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->right = arg2;
}

int _wrap_FSRectI_right_get(void* imarg1)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSRectI *)imarg1; 
  result = (FS_INT32) ((arg1)->right);
  imresult = result; 
  return imresult;
}

void _wrap_FSRectI_bottom_set(void* imarg1, int imarg2)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSRectI *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->bottom = arg2;
}

int _wrap_FSRectI_bottom_get(void* imarg1)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSRectI *)imarg1; 
  result = (FS_INT32) ((arg1)->bottom);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSRectI()
{
  void* imresult = 0 ;
  _FSRectI *result = 0 ;
  
  result = (_FSRectI *)new _FSRectI();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSRectI(void* imarg1)
{
  _FSRectI *arg1 = (_FSRectI *) 0 ;
  
  arg1 = (_FSRectI *)imarg1; 
  delete arg1;
}

void _wrap_FSMatrix_set(void* imarg1, float imarg2, float imarg3, float imarg4, float imarg5, float imarg6, float imarg7)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  FS_FLOAT arg5 ;
  FS_FLOAT arg6 ;
  FS_FLOAT arg7 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  arg5 = (FS_FLOAT)imarg5; 
  arg6 = (FS_FLOAT)imarg6; 
  arg7 = (FS_FLOAT)imarg7; 
  (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7);
}

void* _wrap_FSMatrix_getReverse(void* imarg1)
{
    FSMatrix *arg1 = (FSMatrix *) 0 ;
    void* imresult = 0 ;
    FSMatrix *temp ;
    FSMatrix result;
    
    arg1 = (FSMatrix *)imarg1;
    result = ((FSMatrix *)arg1)->getReverse();
    
    temp = new FSMatrix((const FSMatrix &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void* _wrap_FSMatrix_transform(void* imarg1, void* imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FSPointF arg2 ;
  void* imresult = 0 ;
  FSPointF *argp2 ;
  FSPointF *temp ;
  FSPointF result;
  
  arg1 = (FSMatrix *)imarg1; 
  if (!imarg2) return NULL;
  argp2 = (FSPointF *)imarg2;
  arg2 = *argp2; 
  
  result = (arg1)->transform(arg2);
  
  temp = new FSPointF((const FSPointF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSMatrix_transformRect(void* imarg1, void* imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FSRectF arg2 ;
  void* imresult = 0 ;
  FSRectF *argp2 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSMatrix *)imarg1; 
  if (!imarg2) return NULL;
  argp2 = (FSRectF *)imarg2;
  arg2 = *argp2; 
  
  result = (arg1)->transformRect(arg2);
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void _wrap_FSMatrix_a_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->a = arg2;
}

float _wrap_FSMatrix_a_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->a);
  imresult = result; 
  return imresult;
}

void _wrap_FSMatrix_b_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->b = arg2;
}

float _wrap_FSMatrix_b_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->b);
  imresult = result; 
  return imresult;
}

void _wrap_FSMatrix_c_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->c = arg2;
}

float _wrap_FSMatrix_c_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->c);
  imresult = result; 
  return imresult;
}

void _wrap_FSMatrix_d_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->d = arg2;
}

float _wrap_FSMatrix_d_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->d);
  imresult = result; 
  return imresult;
}

void _wrap_FSMatrix_e_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->e = arg2;
}

float _wrap_FSMatrix_e_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->e);
  imresult = result; 
  return imresult;
}

void _wrap_FSMatrix_f_set(void* imarg1, float imarg2)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMatrix *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->f = arg2;
}

float _wrap_FSMatrix_f_get(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMatrix *)imarg1; 
  result = (FS_FLOAT) ((arg1)->f);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSMatrix()
{
  void* imresult = 0 ;
  FSMatrix *result = 0 ;
  
  result = (FSMatrix *)new FSMatrix();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSMatrix(void* imarg1)
{
  FSMatrix *arg1 = (FSMatrix *) 0 ;
  
  arg1 = (FSMatrix *)imarg1; 
  delete arg1;
}

void _wrap_FSDateTime_set(void* imarg1, unsigned short imarg2, unsigned short imarg3, unsigned short imarg4, unsigned short imarg5, unsigned short imarg6, unsigned short imarg7, unsigned short imarg8, short imarg9, unsigned short imarg10)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  FS_UINT16 arg3 ;
  FS_UINT16 arg4 ;
  FS_UINT16 arg5 ;
  FS_UINT16 arg6 ;
  FS_UINT16 arg7 ;
  FS_UINT16 arg8 ;
  FS_INT16 arg9 ;
  FS_UINT16 arg10 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  arg3 = (FS_UINT16)imarg3; 
  arg4 = (FS_UINT16)imarg4; 
  arg5 = (FS_UINT16)imarg5; 
  arg6 = (FS_UINT16)imarg6; 
  arg7 = (FS_UINT16)imarg7; 
  arg8 = (FS_UINT16)imarg8; 
  arg9 = (FS_INT16)imarg9; 
  arg10 = (FS_UINT16)imarg10; 
  (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
}

void _wrap_FSDateTime_year_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->year = arg2;
}

unsigned short _wrap_FSDateTime_year_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->year);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_month_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->month = arg2;
}

unsigned short _wrap_FSDateTime_month_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->month);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_day_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->day = arg2;
}

unsigned short _wrap_FSDateTime_day_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->day);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_hour_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->hour = arg2;
}

unsigned short _wrap_FSDateTime_hour_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->hour);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_minute_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->minute = arg2;
}

unsigned short _wrap_FSDateTime_minute_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->minute);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_second_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->second = arg2;
}

unsigned short _wrap_FSDateTime_second_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->second);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_millisecond_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->milliseconds = arg2;
}

unsigned short _wrap_FSDateTime_millisecond_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->milliseconds);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_UTHourOffset_set(void* imarg1, short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_INT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_INT16)imarg2; 
  if (arg1) (arg1)->UTHourOffset = arg2;
}

short _wrap_FSDateTime_UTHourOffset_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  short imresult = 0 ;
  FS_INT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_INT16) ((arg1)->UTHourOffset);
  imresult = result; 
  return imresult;
}

void _wrap_FSDateTime_UTMinuteOffset_set(void* imarg1, unsigned short imarg2)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  FS_UINT16 arg2 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  arg2 = (FS_UINT16)imarg2; 
  if (arg1) (arg1)->UTMinuteOffset = arg2;
}

unsigned short _wrap_FSDateTime_UTMinuteOffset_get(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  unsigned short imresult = 0 ;
  FS_UINT16 result;
  
  arg1 = (_FSDateTime *)imarg1; 
  result = (FS_UINT16) ((arg1)->UTMinuteOffset);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSDateTime()
{
  void* imresult = 0 ;
  _FSDateTime *result = 0 ;
  
  result = (_FSDateTime *)new _FSDateTime();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSDateTime(void* imarg1)
{
  _FSDateTime *arg1 = (_FSDateTime *) 0 ;
  
  arg1 = (_FSDateTime *)imarg1; 
  delete arg1;
}

unsigned long long _wrap_FSFileRead_getSize(void* imarg1)
{
  FSFileRead *arg1 = (FSFileRead *) 0 ;
  unsigned long long imresult = 0 ;
  FS_UINT64 result;
  
  arg1 = (FSFileRead *)imarg1; 
  result = (FS_UINT64)(arg1)->getSize();
  imresult = result; 
  return imresult;
}

BOOL _wrap_FSFileRead_readBlock(void* imarg1, void * imarg2, unsigned long long imarg3, unsigned long long imarg4)
{
  FSFileRead *arg1 = (FSFileRead *) 0 ;
  void *arg2 = (void *) 0 ;
  FS_UINT64 arg3 ;
  FS_UINT64 arg4 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSFileRead *)imarg1;
  arg2 = imarg2;

  arg3 = (FS_UINT64)imarg3; 
  arg4 = (FS_UINT64)imarg4; 
  result = (FS_BOOL)(arg1)->readBlock(arg2,arg3,arg4);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSFileRead(void* imarg1)
{
  FSFileRead *arg1 = (FSFileRead *) 0 ;
  
  arg1 = (FSFileRead *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSPause_needPauseNow(void* imarg1)
{
  FSPause *arg1 = (FSPause *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPause *)imarg1; 
  result = (FS_BOOL)(arg1)->needPauseNow();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSPause(void* imarg1)
{
  FSPause *arg1 = (FSPause *) 0 ;
  
  arg1 = (FSPause *)imarg1; 
  delete arg1;
}

void _wrap_FSWrapperData_set(void* imarg1, int imarg2, NSString * imarg3, NSString * imarg4, NSString * imarg5, NSString * imarg6)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FS_INT32 arg2 ;
  char const *arg3 = (char const *) 0 ;
  char const *arg4 = (char const *) 0 ;
  char const *arg5 = (char const *) 0 ;
  char const *arg6 = (char const *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  {
    arg4 = 0;
    if (imarg4) {
      arg4 = [imarg4 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  {
    arg5 = 0;
    if (imarg5) {
      arg5 = [imarg5 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  {
    arg6 = 0;
    if (imarg6) {
      arg6 = [imarg6 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->set(arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6);
}

void _wrap_FSWrapperData_version_set(void* imarg1, int imarg2)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->version = arg2;
}

int _wrap_FSWrapperData_version_get(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSWrapperData *)imarg1; 
  result = (FS_INT32) ((arg1)->version);
  imresult = result; 
  return imresult;
}

void _wrap_FSWrapperData_type_set(void* imarg1, NSString * imarg2)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FSString *arg2 = (FSString *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      const char* temp = [imarg2 UTF8String];
      arg2 = new FSString(temp);
    }
  }
  if (arg1) (arg1)->type = *arg2;
}

NSString * _wrap_FSWrapperData_type_get(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  NSString * imresult = 0 ;
  FSString *result = 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  result = (FSString *)& ((arg1)->type);
  {
    if (result && 0 < result->getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSWrapperData_appID_set(void* imarg1, NSString * imarg2)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FSString *arg2 = (FSString *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      const char* temp = [imarg2 UTF8String];
      arg2 = new FSString(temp);
    }
  }
  if (arg1) (arg1)->appID = *arg2;
}

NSString * _wrap_FSWrapperData_appID_get(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  NSString * imresult = 0 ;
  FSString *result = 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  result = (FSString *)& ((arg1)->appID);
  {
    if (result && 0 < result->getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSWrapperData_uri_set(void* imarg1, NSString * imarg2)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FSString *arg2 = (FSString *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      const char* temp = [imarg2 UTF8String];
      arg2 = new FSString(temp);
    }
  }
  if (arg1) (arg1)->uri = *arg2;
}

NSString * _wrap_FSWrapperData_uri_get(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  NSString * imresult = 0 ;
  FSString *result = 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  result = (FSString *)& ((arg1)->uri);
  {
    if (result && 0 < result->getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSWrapperData_description_set(void* imarg1, NSString * imarg2)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  FSString *arg2 = (FSString *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      const char* temp = [imarg2 UTF8String];
      arg2 = new FSString(temp);
    }
  }
  if (arg1) (arg1)->description = *arg2;
}

NSString * _wrap_FSWrapperData_description_get(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  NSString * imresult = 0 ;
  FSString *result = 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  result = (FSString *)& ((arg1)->description);
  {
    if (result && 0 < result->getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
    }
  }
  return imresult;
}

void* _wrap_new_FSWrapperData()
{
  void* imresult = 0 ;
  _FSWrapperData *result = 0 ;
  
  result = (_FSWrapperData *)new _FSWrapperData();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSWrapperData(void* imarg1)
{
  _FSWrapperData *arg1 = (_FSWrapperData *) 0 ;
  
  arg1 = (_FSWrapperData *)imarg1; 
  delete arg1;
}

void* _wrap_FSDestination_createXYZ(void* imarg1, float imarg2, float imarg3, float imarg4)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  result = (FSDestination *)FSDestination::createXYZ(arg1,arg2,arg3,arg4);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitPage(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  result = (FSDestination *)FSDestination::createFitPage(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitHorz(void* imarg1, float imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  result = (FSDestination *)FSDestination::createFitHorz(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitVert(void* imarg1, float imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  result = (FSDestination *)FSDestination::createFitVert(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitRect(void* imarg1, float imarg2, float imarg3, float imarg4, float imarg5)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  FS_FLOAT arg5 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  arg5 = (FS_FLOAT)imarg5; 
  result = (FSDestination *)FSDestination::createFitRect(arg1,arg2,arg3,arg4,arg5);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitBBox(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  result = (FSDestination *)FSDestination::createFitBBox(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitBHorz(void* imarg1, float imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  result = (FSDestination *)FSDestination::createFitBHorz(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSDestination_createFitBVert(void* imarg1, float imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_FLOAT arg2 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  result = (FSDestination *)FSDestination::createFitBVert(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSDestination_getPageIndex(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_INT32)((FSDestination const *)arg1)->getPageIndex();
  imresult = result; 
  return imresult;
}

int _wrap_FSDestination_getZoomMode(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  int imresult = 0 ;
  FS_ZOOMMODE result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_ZOOMMODE)((FSDestination const *)arg1)->getZoomMode();
  imresult = (int)result; 
  return imresult;
}

float _wrap_FSDestination_getLeft(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_FLOAT)((FSDestination const *)arg1)->getLeft();
  imresult = result; 
  return imresult;
}

float _wrap_FSDestination_getTop(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_FLOAT)((FSDestination const *)arg1)->getTop();
  imresult = result; 
  return imresult;
}

float _wrap_FSDestination_getRight(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_FLOAT)((FSDestination const *)arg1)->getRight();
  imresult = result; 
  return imresult;
}

float _wrap_FSDestination_getBottom(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_FLOAT)((FSDestination const *)arg1)->getBottom();
  imresult = result; 
  return imresult;
}

float _wrap_FSDestination_getZoomFactor(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSDestination *)imarg1; 
  result = (FS_FLOAT)((FSDestination const *)arg1)->getZoomFactor();
  imresult = result; 
  return imresult;
}

void _wrap_delete_FSDestination(void* imarg1)
{
  FSDestination *arg1 = (FSDestination *) 0 ;
  
  arg1 = (FSDestination *)imarg1; 
  arg1->release();
}

void _wrap_delete_FSAction(void* imarg1)
{
  FSAction *arg1 = (FSAction *) 0 ;
  
  arg1 = (FSAction *)imarg1; 
  arg1->release();
}

void* _wrap_FSAction_create(void* imarg1, int imarg2)
{
    void* imresult = 0;
    FSPDFDoc* arg1 = (FSPDFDoc*)imarg1;
    FSAction* result = 0;
    
    if (imarg1) {
        result = (FSAction*)FSAction::create( arg1, (FS_ACTIONTYPE)imarg2);
        imresult = (void*)result;
    }
    return imresult;
}

void _wrap_FSAction_setSubAction(void* imarg1, int imarg2, void* imarg3)
{
    FSAction *arg1 = (FSAction *) 0 ;
    FSAction *arg3;
    FS_INT32 arg2 =(FS_INT32)imarg2;
    
    arg1 = (FSAction*)imarg1;
    arg3 = (FSAction *)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    THROWEXCEPTION_IF_NULLPOINTER(arg3);
    (arg1)->setSubAction(arg2, arg3);
}

BOOL _wrap_FSAction_insertSubAction(void* imarg1, int imarg2, void* imarg3)
{
    FSAction *arg1 = (FSAction *) 0 ;
    FSAction *arg3;
    FS_INT32 arg2 =(FS_INT32)imarg2;
    FS_BOOL result;
    BOOL imresult = 0;
    
    arg1 = (FSAction*)imarg1;
    arg3 = (FSAction *)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    THROWEXCEPTION_IF_NULLPOINTER(arg3)
    result = (arg1)->insertSubAction(arg2, arg3);
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSAction_removeSubAction(void* imarg1, int imarg2)
{
    FSAction *arg1 = (FSAction *) 0 ;
    FS_INT32 arg2 =(FS_INT32)imarg2;
    FS_BOOL result;
    BOOL imresult = 0;
    
    arg1 = (FSAction*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (arg1)->removeSubAction(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSAction_removeAllSubActions(void* imarg1)
{
    FSAction *arg1 = (FSAction *) 0 ;
    FS_BOOL result;
    BOOL imresult = 0;
    
    arg1 = (FSAction*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (arg1)->removeAllSubActions();
    imresult = (result)? YES:NO;
    return imresult;
}
    
int _wrap_FSAction_getType(void* imarg1)
{
  FSAction *arg1 = (FSAction *) 0 ;
  int imresult = 0 ;
  FS_ACTIONTYPE result;
  
  arg1 = (FSAction *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_ACTIONTYPE)(arg1)->getType();
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSAction_getSubActionCount(void* imarg1)
{
  FSAction *arg1 = (FSAction *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSAction *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)(arg1)->getSubActionCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSAction_getSubAction(void* imarg1, int imarg2)
{
  FSAction *arg1 = (FSAction *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSAction *result = 0 ;
  
  arg1 = (FSAction *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSAction *)(arg1)->getSubAction(arg2);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSGotoAction(void* imarg1)
{
  FSGotoAction *arg1 = (FSGotoAction *) 0 ;
  
  arg1 = (FSGotoAction *)imarg1; 
  delete arg1;
}

void* _wrap_FSGotoAction_getDestination(void* imarg1)
{
  FSGotoAction *arg1 = (FSGotoAction *) 0 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSGotoAction *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSDestination *)(arg1)->getDestination();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSGotoAction_setDestination(void* imarg1, void* imarg2)
{
    FSGotoAction *arg1 = (FSGotoAction *) 0 ;
    FSDestination *arg2;
    
    arg1 = (FSGotoAction*)imarg1;
    arg2 = (FSDestination *)imarg2;
    if (arg1 && arg2)
        (arg1)->setDestination(arg2);
}
    
void _wrap_delete_FSURIAction(void* imarg1)
{
  FSURIAction *arg1 = (FSURIAction *) 0 ;
  
  arg1 = (FSURIAction *)imarg1; 
  delete arg1;
}

NSString * _wrap_FSURIAction_getURI(void* imarg1)
{
  FSURIAction *arg1 = (FSURIAction *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSURIAction *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (arg1)->getURI();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSURIAction_setURI(void* imarg1, NSString* imarg2)
{
    FSURIAction *arg1 = (FSURIAction *) 0 ;
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSURIAction *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    (arg1)->setURI(arg2);
}

void _wrap_FSURIAction_setTrackPositionFlag(void* imarg1, BOOL imarg2)
{
    FSURIAction *arg1 = (FSURIAction *) 0 ;
    FS_BOOL arg2 ;
    
    arg1 = (FSURIAction *)imarg1;
    arg2 = imarg2? true : false;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    (arg1)->setTrackPositionFlag(arg2);
}
    
BOOL _wrap_FSURIAction_isTrackPosition(void* imarg1)
{
  FSURIAction *arg1 = (FSURIAction *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSURIAction *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->isTrackPosition();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSAnnot(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  
  arg1 = (FSAnnot *)imarg1; 
  delete arg1;
}

void* _wrap_FSAnnot_getPage(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  void* imresult = 0 ;
  FSPDFPage *result = 0 ;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFPage *)((FSAnnot const *)arg1)->getPage();
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSAnnot_isMarkup(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSAnnot const *)arg1)->isMarkup();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSAnnot_getType(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  int imresult = 0 ;
  FSAnnot::FS_ANNOTTYPE result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSAnnot::FS_ANNOTTYPE)((FSAnnot const *)arg1)->getType();
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSAnnot_getIndex(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)((FSAnnot const *)arg1)->getIndex();
  imresult = result; 
  return imresult;
}

NSString * _wrap_FSAnnot_getContent(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSAnnot const *)arg1)->getContent();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSAnnot_setContent(void* imarg1, NSString * imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSAnnot *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
        arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setContent((char const *)arg2);
}

void* _wrap_FSAnnot_getModifiedDateTime(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  void* imresult = 0 ;
  FSDateTime *temp ;
  FSDateTime result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSAnnot const *)arg1)->getModifiedDateTime();
  
  temp = new FSDateTime((const FSDateTime &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void _wrap_FSAnnot_setModifiedDateTime(void* imarg1, void* imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FSDateTime arg2 ;
  FSDateTime *argp2 ;
  
  arg1 = (FSAnnot *)imarg1; 
  
  argp2 = (FSDateTime *)imarg2;
    if (!argp2) {
        return ;
    }
  arg2 = *argp2; 
  THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setModifiedDateTime(arg2);
}

unsigned int _wrap_FSAnnot_getFlags(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_DWORD)((FSAnnot const *)arg1)->getFlags();
  imresult = result; 
  return imresult;
}

void _wrap_FSAnnot_setFlags(void* imarg1, unsigned int imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FS_DWORD arg2 ;
  
  arg1 = (FSAnnot *)imarg1; 
  arg2 = (FS_DWORD)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setFlags(arg2);
}

NSString * _wrap_FSAnnot_getUniqueID(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSAnnot const *)arg1)->getUniqueID();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSAnnot_setUniqueID(void* imarg1, NSString * imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSAnnot *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setUniqueID((char const *)arg2);
}

void* _wrap_FSAnnot_getRect(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSAnnot const *)arg1)->getRect();
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

BOOL _wrap_FSAnnot_move(void* imarg1, void* imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FSRectF arg2 ;
  BOOL imresult = 0 ;
  FSRectF *argp2 ;
  FS_BOOL result;
  
  arg1 = (FSAnnot *)imarg1; 
  
  argp2 = (FSRectF *)imarg2;
    if (!argp2) {
        arg2.set(0.0f, 0.0f, 0.0f, 0.0f);
    } else {
      arg2 = *argp2;
    }
  
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->move(arg2);
    
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSAnnot_getBorderInfo(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  void* imresult = 0 ;
  FSBorderInfo *temp ;
  FSBorderInfo result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSAnnot const *)arg1)->getBorderInfo();
  
    if (-1 == result.width)
        return NULL;
  temp = new FSBorderInfo((const FSBorderInfo &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void _wrap_FSAnnot_setBorderInfo(void* imarg1, void* imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FSBorderInfo arg2 ;
  FSBorderInfo *argp2 ;
  
  arg1 = (FSAnnot *)imarg1; 
  
  argp2 = (FSBorderInfo *)imarg2;
  arg2 = *argp2; 
  THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setBorderInfo(arg2);
}

unsigned int _wrap_FSAnnot_getBorderColor(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  unsigned int imresult = 0 ;
  FS_ARGB result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_ARGB)((FSAnnot const *)arg1)->getBorderColor();
  imresult = result; 
  return imresult;
}

void _wrap_FSAnnot_setBorderColor(void* imarg1, unsigned int imarg2)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FS_ARGB arg2 ;
  
  arg1 = (FSAnnot *)imarg1; 
  arg2 = (FS_ARGB)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->setBorderColor(arg2);
}

BOOL _wrap_FSAnnot_resetAppearanceStream(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSAnnot_getDeviceRect(void* imarg1, BOOL imarg2, void* imarg3)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  FS_BOOL arg2 ;
  FSMatrix *arg3 = (FSMatrix *) 0 ;
  void* imresult = 0 ;
  FSRectI *temp ;
  FSRectI result;
  
  arg1 = (FSAnnot *)imarg1; 
  arg2 = imarg2? true : false; 
  arg3 = (FSMatrix *)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    THROWEXCEPTION_IF_NULLPOINTER(arg3);
  result = (arg1)->getDeviceRect(arg2,(FSMatrix const *)arg3);
  
  temp = new FSRectI((const FSRectI &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSAnnot_getDict(void* imarg1)
{
  FSAnnot *arg1 = (FSAnnot *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSAnnot *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSAnnot const *)arg1)->getDict();
  imresult = (void*)result; 
  return imresult;
}
    
BOOL _wrap_FSAnnot_removeProperty(void* imarg1, int imarg2)
{
    FSAnnot *arg1 = (FSAnnot *) 0 ;
    FSAnnot::FS_ANNOTPROPERTY arg2 ;
    BOOL imresult = 0 ;
    FS_BOOL result ;
    
    arg1 = (FSAnnot *)imarg1;
    arg2 = (FSAnnot::FS_ANNOTPROPERTY)imarg2;
      THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FS_BOOL)(arg1)->removeProperty(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

void _wrap_FSBorderInfo_set(void* imarg1, float imarg2, int imarg3, float imarg4, float imarg5, NSArray * imarg6)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FS_FLOAT arg2 ;
  FSAnnot::FS_BORDERSTYLE arg3 ;
  FS_FLOAT arg4 ;
  FS_FLOAT arg5 ;
  FS_FLOAT *arg6 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FSAnnot::FS_BORDERSTYLE)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  arg5 = (FS_FLOAT)imarg5;
  {
      arg6 = (FS_FLOAT *) arg1->dashes;
      for (int i = 0; i < 16; i++)
      {
          arg6[i] = -1;
      }
      if (imarg6 && imarg6.count > 0) {
          int count = imarg6.count;
          for (int i = 0; i < count; i++)
          {
              arg6[i] = [[imarg6 objectAtIndex:i] floatValue];
          }
      }
  }
  (arg1)->set(arg2,arg3,arg4,arg5,(FS_FLOAT const (*))arg6);
}

void _wrap_FSBorderInfo_width_set(void* imarg1, float imarg2)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->width = arg2;
}

float _wrap_FSBorderInfo_width_get(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  result = (FS_FLOAT) ((arg1)->width);
  imresult = result; 
  return imresult;
}

void _wrap_FSBorderInfo_style_set(void* imarg1, int imarg2)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FSAnnot::FS_BORDERSTYLE arg2 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  arg2 = (FSAnnot::FS_BORDERSTYLE)imarg2; 
  if (arg1) (arg1)->style = arg2;
}

int _wrap_FSBorderInfo_style_get(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  int imresult = 0 ;
  FSAnnot::FS_BORDERSTYLE result;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  result = (FSAnnot::FS_BORDERSTYLE) ((arg1)->style);
  imresult = (int)result; 
  return imresult;
}

void _wrap_FSBorderInfo_cloudIntensity_set(void* imarg1, float imarg2)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  if (arg1) (arg1)->cloudIntensity = arg2;
}

float _wrap_FSBorderInfo_cloudIntensity_get(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  result = (FS_FLOAT) ((arg1)->cloudIntensity);
  imresult = result; 
  return imresult;
}

void _wrap_FSBorderInfo_dashPhase_set(void* imarg1, float imarg2)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  arg2 = (FS_FLOAT)imarg2;
  if (arg1) (arg1)->dashPhase = arg2;
}

float _wrap_FSBorderInfo_dashPhase_get(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  int imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  result = (FS_FLOAT) ((arg1)->dashPhase);
  imresult = result; 
  return imresult;
}

void _wrap_FSBorderInfo_dashes_set(void* imarg1, NSArray * imarg2)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  FS_FLOAT *arg2 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  {
    arg2 = (FS_FLOAT *) arg1->dashes;
      for (int i = 0; i < 16; i++)
      {
          arg2[i] = -1;
      }
    if (imarg2 && imarg2.count > 0) {
      int count = imarg2.count;
      for (int i = 0; i < count; i++)
      {
        arg2[i] = [[imarg2 objectAtIndex:i] floatValue];
      }
    }
  }
}

NSMutableArray * _wrap_FSBorderInfo_dashes_get(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  NSMutableArray * imresult = 0 ;
  FS_FLOAT *result = 0 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  result = (FS_FLOAT *)(FS_FLOAT *) ((arg1)->dashes);
  {
    if (result) {
        if (-1 == result[0])
            return nil;
      imresult = [NSMutableArray array];
      for (int i = 0; i < 16; i++)
      {
        if (-1 == result[i])
        break;
        NSNumber *num = [NSNumber numberWithFloat:result[i]];
        [imresult addObject:num];
        
      }
    }
  }
  return imresult;
}

void* _wrap_new_FSBorderInfo()
{
  void* imresult = 0 ;
  _FSBorderInfo *result = 0 ;
  
  result = (_FSBorderInfo *)new _FSBorderInfo();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSBorderInfo(void* imarg1)
{
  _FSBorderInfo *arg1 = (_FSBorderInfo *) 0 ;
  
  arg1 = (_FSBorderInfo *)imarg1; 
  delete arg1;
}

void _wrap_FSQuadPoints_set(void* imarg1, void* imarg2, void* imarg3, void* imarg4, void* imarg5)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  FSPointF arg2 ;
  FSPointF arg3 ;
  FSPointF arg4 ;
  FSPointF arg5 ;
  FSPointF *argp2 ;
  FSPointF *argp3 ;
  FSPointF *argp4 ;
  FSPointF *argp5 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  
  argp2 = (FSPointF *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (FSPointF *)imarg3;
  arg3 = *argp3; 
  
  
  argp4 = (FSPointF *)imarg4;
  arg4 = *argp4; 
  
  
  argp5 = (FSPointF *)imarg5;
  arg5 = *argp5; 
  
  (arg1)->set(arg2,arg3,arg4,arg5);
}

void _wrap_FSQuadPoints_first_set(void* imarg1, void* imarg2)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  FSPointF *arg2 = (FSPointF *) 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  arg2 = (FSPointF *)imarg2; 
  if (arg1) (arg1)->first = *arg2;
}

void* _wrap_FSQuadPoints_first_get(void* imarg1)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  void* imresult = 0 ;
  FSPointF *result = 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  result = (FSPointF *)& ((arg1)->first);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSQuadPoints_second_set(void* imarg1, void* imarg2)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  FSPointF *arg2 = (FSPointF *) 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  arg2 = (FSPointF *)imarg2; 
  if (arg1) (arg1)->second = *arg2;
}

void* _wrap_FSQuadPoints_second_get(void* imarg1)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  void* imresult = 0 ;
  FSPointF *result = 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  result = (FSPointF *)& ((arg1)->second);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSQuadPoints_third_set(void* imarg1, void* imarg2)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  FSPointF *arg2 = (FSPointF *) 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  arg2 = (FSPointF *)imarg2; 
  if (arg1) (arg1)->third = *arg2;
}

void* _wrap_FSQuadPoints_third_get(void* imarg1)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  void* imresult = 0 ;
  FSPointF *result = 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  result = (FSPointF *)& ((arg1)->third);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSQuadPoints_fourth_set(void* imarg1, void* imarg2)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  FSPointF *arg2 = (FSPointF *) 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  arg2 = (FSPointF *)imarg2; 
  if (arg1) (arg1)->fourth = *arg2;
}

void* _wrap_FSQuadPoints_fourth_get(void* imarg1)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  void* imresult = 0 ;
  FSPointF *result = 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  result = (FSPointF *)& ((arg1)->fourth);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_new_FSQuadPoints()
{
  void* imresult = 0 ;
  _FSQuadPoints *result = 0 ;
  
  result = (_FSQuadPoints *)new _FSQuadPoints();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSQuadPoints(void* imarg1)
{
  _FSQuadPoints *arg1 = (_FSQuadPoints *) 0 ;
  
  arg1 = (_FSQuadPoints *)imarg1; 
  delete arg1;
}

void _wrap_FSShadingColor_set(void* imarg1, unsigned int imarg2, unsigned int imarg3)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  FS_ARGB arg2 ;
  FS_ARGB arg3 ;
  
  arg1 = (_FSShadingColor *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  arg3 = (FS_ARGB)imarg3; 
  (arg1)->set(arg2,arg3);
}

void _wrap_FSShadingColor_firstColor_set(void* imarg1, unsigned int imarg2)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  FS_ARGB arg2 ;
  
  arg1 = (_FSShadingColor *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  if (arg1) (arg1)->firstColor = arg2;
}

unsigned int _wrap_FSShadingColor_firstColor_get(void* imarg1)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  unsigned int imresult = 0 ;
  FS_ARGB result;
  
  arg1 = (_FSShadingColor *)imarg1; 
  result = (FS_ARGB) ((arg1)->firstColor);
  imresult = result; 
  return imresult;
}

void _wrap_FSShadingColor_secondColor_set(void* imarg1, unsigned int imarg2)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  FS_ARGB arg2 ;
  
  arg1 = (_FSShadingColor *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  if (arg1) (arg1)->secondColor = arg2;
}

unsigned int _wrap_FSShadingColor_secondColor_get(void* imarg1)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  unsigned int imresult = 0 ;
  FS_ARGB result;
  
  arg1 = (_FSShadingColor *)imarg1; 
  result = (FS_ARGB) ((arg1)->secondColor);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSShadingColor()
{
  void* imresult = 0 ;
  _FSShadingColor *result = 0 ;
  
  result = (_FSShadingColor *)new _FSShadingColor();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSShadingColor(void* imarg1)
{
  _FSShadingColor *arg1 = (_FSShadingColor *) 0 ;
  
  arg1 = (_FSShadingColor *)imarg1; 
  delete arg1;
}

NSString * _wrap_FSAnnotIconProvider_getProviderID(void* imarg1)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  result = (arg1)->getProviderID();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

NSString * _wrap_FSAnnotIconProvider_getProviderVersion(void* imarg1)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  result = (arg1)->getProviderVersion();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

BOOL _wrap_FSAnnotIconProvider_hasIcon(void* imarg1, int imarg2, NSString * imarg3)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_BOOL)(arg1)->hasIcon(arg2,(char const *)arg3);
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSAnnotIconProvider_canChangeColor(void* imarg1, int imarg2, NSString * imarg3)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_BOOL)(arg1)->canChangeColor(arg2,(char const *)arg3);
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSAnnotIconProvider_getIcon(void* imarg1, int imarg2, NSString * imarg3, unsigned int imarg4)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  FS_ARGB arg4 ;
  void* imresult = 0 ;
  FSPDFPage *result = 0 ;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg4 = (FS_ARGB)imarg4; 
  result = (FSPDFPage *)(arg1)->getIcon(arg2,(char const *)arg3,arg4);
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSAnnotIconProvider_getShadingColor(void* imarg1, int imarg2, NSString * imarg3, unsigned int imarg4, int imarg5, void* imarg6)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  FS_ARGB arg4 ;
  FS_INT32 arg5 ;
  FSShadingColor *arg6 = 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg4 = (FS_ARGB)imarg4; 
  arg5 = (FS_INT32)imarg5; 
  arg6 = (FSShadingColor *)imarg6; 
  result = (FS_BOOL)(arg1)->getShadingColor(arg2,(char const *)arg3,arg4,arg5,*arg6);
  imresult = (result)? YES:NO; 
  return imresult;
}

float _wrap_FSAnnotIconProvider_getDisplayWidth(void* imarg1, int imarg2, NSString * imarg3)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_FLOAT)(arg1)->getDisplayWidth(arg2,(char const *)arg3);
  imresult = result; 
  return imresult;
}

float _wrap_FSAnnotIconProvider_getDisplayHeight(void* imarg1, int imarg2, NSString * imarg3)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  char const *arg3 = (char const *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  {
    arg3 = 0;
    if (imarg3) {
      arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_FLOAT)(arg1)->getDisplayHeight(arg2,(char const *)arg3);
  imresult = result; 
  return imresult;
}

void _wrap_delete_FSAnnotIconProvider(void* imarg1)
{
  FSAnnotIconProvider *arg1 = (FSAnnotIconProvider *) 0 ;
  
  arg1 = (FSAnnotIconProvider *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSPopup_getOpenStatus(void* imrg1)
{
    FSPopup* popup = (FSPopup*)imrg1;
    return popup->getOpenStatus();
}

void _wrap_FSPopup_setOpenStatus(void* imrg1, BOOL imrg2)
{
    FSPopup* popup = (FSPopup*)imrg1;
    popup->setOpenStatus(imrg2);
}
    
void _wrap_delete_FSMarkup(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  delete arg1;
}
void* _wrap_FSMarkup_getPopup(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *)imarg1;
    return arg1->getPopup();
}
void _wrap_FSMarkup_setPopup(void* imrg1, void* imrg2)
{
    FSMarkup *arg1 = (FSMarkup *)imrg1;
    arg1->setPopup((FSPopup*)imrg2);
}
NSString * _wrap_FSMarkup_getTitle(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = ((FSMarkup const *)arg1)->getTitle();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSMarkup_setTitle(void* imarg1, NSString * imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->setTitle((char const *)arg2);
}

NSString * _wrap_FSMarkup_getSubject(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = ((FSMarkup const *)arg1)->getSubject();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSMarkup_setSubject(void* imarg1, NSString * imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->setSubject((char const *)arg2);
}

float _wrap_FSMarkup_getOpacity(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = (FS_FLOAT)((FSMarkup const *)arg1)->getOpacity();
  imresult = result; 
  return imresult;
}

void _wrap_FSMarkup_setOpacity(void* imarg1, float imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  FS_FLOAT arg2 ;
  
  arg1 = (FSMarkup *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  (arg1)->setOpacity(arg2);
}

NSString * _wrap_FSMarkup_getIntent(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = ((FSMarkup const *)arg1)->getIntent();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSMarkup_setIntent(void* imarg1, NSString * imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
      (arg1)->setIntent((char const *)arg2);
    }
  }
}

void* _wrap_FSMarkup_getCreationDateTime(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  void* imresult = 0 ;
  FSDateTime *temp ;
  FSDateTime result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = ((FSMarkup const *)arg1)->getCreationDateTime();
  
  temp = new FSDateTime((const FSDateTime &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void _wrap_FSMarkup_setCreationDateTime(void* imarg1, void* imarg2)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FSDateTime arg2 ;
    FSDateTime *argp2 ;
    
    arg1 = (FSMarkup *)imarg1;
    
    argp2 = (FSDateTime *)imarg2;
    if (!argp2) {
        return;
    }
    arg2 = *argp2;
    
    (arg1)->setCreationDateTime(arg2);
}

int _wrap_FSMarkup_getReplyCount(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = (FS_INT32)(arg1)->getReplyCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSMarkup_getReply(void* imarg1, int imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSNote *result = 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FSNote *)((FSMarkup const *)arg1)->getReply(arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSMarkup_addReply(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  void* imresult = 0 ;
  FSNote *result = 0 ;
  
  arg1 = (FSMarkup *)imarg1; 
  result = (FSNote *)(arg1)->addReply();
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSMarkup_removeReply(void* imarg1, int imarg2)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  FS_INT32 arg2 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSMarkup *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FS_BOOL)(arg1)->removeReply(arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSMarkup_removeAllReplies(void* imarg1)
{
  FSMarkup *arg1 = (FSMarkup *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSMarkup *)imarg1; 
  result = (FS_BOOL)(arg1)->removeAllReplies();
  imresult = (result)? YES:NO; 
  return imresult;
}
    
BOOL _wrap_FSMarkup_isGrouped(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSMarkup *)imarg1;
    result = (FS_BOOL)(arg1)->isGrouped();
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSMarkup_getGroupHeader(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    void* imresult = 0 ;
    FSMarkup *result = 0 ;
    
    arg1 = (FSMarkup *)imarg1;
    result = (arg1)->getGroupHeader();
    imresult = (void*)result;
    return imresult;
}

int _wrap_FSMarkup_getGroupElementCount(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FS_INT32 result;
    int imresult;
    
    arg1 = (FSMarkup*)imarg1;
    result = arg1->getGroupElementCount();
    imresult = (int)result;
    return imresult;
}

void* _wrap_FSMarkup_getGroupElement(void* imarg1, int imarg2)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FS_INT32 arg2 = (FS_INT32)imarg2;
    void* imresult = 0 ;
    FSMarkup *result = 0 ;
    
    arg1 = (FSMarkup *)imarg1;
    result = (arg1)->getGroupElement(arg2);
    imresult = (void*)result;
    return imresult;
}

BOOL _wrap_FSMarkup_ungroup(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSMarkup *)imarg1;
    result = (FS_BOOL)(arg1)->ungroup();
    imresult = (result)? YES:NO;
    return imresult;
}
    
int _wrap_FSMarkup_getStateAnnotCount(void* imarg1, int imarg2)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FSAnnot::FS_ANNOTSTATEMODEL arg2 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSMarkup *)imarg1;
    arg2 = (FSAnnot::FS_ANNOTSTATEMODEL)imarg2;
    result = (FS_INT32)(arg1)->getStateAnnotCount(arg2);
    imresult = result;
    return imresult;
}

void* _wrap_FSMarkup_getStateAnnot(void* imarg1, int imarg2, int imarg3)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FSAnnot::FS_ANNOTSTATEMODEL arg2 ;
    FS_INT32 arg3 ;
    void* imresult = 0 ;
    FSNote *result = 0 ;
    
    arg1 = (FSMarkup *)imarg1;
    arg2 = (FSAnnot::FS_ANNOTSTATEMODEL)imarg2;
    arg3 = (FS_INT32)imarg3;
    result = (FSNote *)(arg1)->getStateAnnot(arg2,arg3);
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSMarkup_addStateAnnot(void* imarg1, int imarg2, int imarg3)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    FSAnnot::FS_ANNOTSTATEMODEL arg2 ;
    FSAnnot::FS_ANNOTSTATE arg3 ;
    void* imresult = 0 ;
    FSNote *result = 0 ;
    
    arg1 = (FSMarkup *)imarg1;
    arg2 = (FSAnnot::FS_ANNOTSTATEMODEL)imarg2;
    arg3 = (FSAnnot::FS_ANNOTSTATE)imarg3;
    result = (FSNote *)(arg1)->addStateAnnot(arg2,arg3);
    imresult = (void*)result;
    return imresult;
}

BOOL _wrap_FSMarkup_removeAllStateAnnots(void* imarg1)
{
    FSMarkup *arg1 = (FSMarkup *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSMarkup *)imarg1; 
    result = (FS_BOOL)(arg1)->removeAllStateAnnots();
    imresult = (result)? YES:NO; 
    return imresult;
}

void _wrap_delete_FSNote(void* imarg1)
{
  FSNote *arg1 = (FSNote *) 0 ;
  
  arg1 = (FSNote *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSNote_getOpenStatus(void* imarg1)
{
  FSNote *arg1 = (FSNote *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSNote *)imarg1; 
  result = (FS_BOOL)((FSNote const *)arg1)->getOpenStatus();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_FSNote_setOpenStatus(void* imarg1, BOOL imarg2)
{
  FSNote *arg1 = (FSNote *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSNote *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setOpenStatus(arg2);
}

NSString * _wrap_FSNote_getIconName(void* imarg1)
{
  FSNote *arg1 = (FSNote *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSNote *)imarg1; 
  result = ((FSNote const *)arg1)->getIconName();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSNote_setIconName(void* imarg1, NSString * imarg2)
{
  FSNote *arg1 = (FSNote *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSNote *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->setIconName((char const *)arg2);
}
    
void* _wrap_FSNote_getReplyTo(void* imarg1)
{
    FSNote *arg1 = (FSNote *) imarg1 ;
    return (arg1)->getReplyTo();
}
    
BOOL _wrap_FSNote_resetAppearanceStream(void* imarg1)
{
  FSNote *arg1 = (FSNote *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSNote *)imarg1; 
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSNote_isStateAnnot(void* imarg1)
{
    FSNote *arg1 = (FSNote *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSNote *)imarg1;
    result = (FS_BOOL)(arg1)->isStateAnnot();
    imresult = (result)? YES:NO;
    return imresult;
}

int _wrap_FSNote_getStateModel(void* imarg1)
{
    FSNote *arg1 = (FSNote *) 0 ;
    int imresult = 0 ;
    FSAnnot::FS_ANNOTSTATEMODEL result;
    
    arg1 = (FSNote *)imarg1;
    result = (FSAnnot::FS_ANNOTSTATEMODEL)(arg1)->getStateModel();
    imresult = (int)result;
    return imresult;
}

int _wrap_FSNote_getState(void* imarg1)
{
    FSNote *arg1 = (FSNote *) 0 ;
    int imresult = 0 ;
    FSAnnot::FS_ANNOTSTATE result;
    
    arg1 = (FSNote *)imarg1;
    result = (FSAnnot::FS_ANNOTSTATE)(arg1)->getState();
    imresult = (int)result;
    return imresult;
}

void _wrap_FSNote_setState(void* imarg1, int imarg2)
{
    FSNote *arg1 = (FSNote *) 0 ;
    FSAnnot::FS_ANNOTSTATE arg2 ;
    
    arg1 = (FSNote *)imarg1;
    arg2 = (FSAnnot::FS_ANNOTSTATE)imarg2;
    (arg1)->setState(arg2);
}

void _wrap_delete_FSTextMarkup(void* imarg1)
{
  FSTextMarkup *arg1 = (FSTextMarkup *) 0 ;
  
  arg1 = (FSTextMarkup *)imarg1; 
  delete arg1;
}

int _wrap_FSTextMarkup_getQuadPointsCount(void* imarg1)
{
  FSTextMarkup *arg1 = (FSTextMarkup *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSTextMarkup *)imarg1; 
  result = (FS_INT32)((FSTextMarkup const *)arg1)->getQuadPointsCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSTextMarkup_getQuadPoints(void* imarg1, int imarg2)
{
  FSTextMarkup *arg1 = (FSTextMarkup *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSQuadPoints *temp ;
  FSQuadPoints result;
  
  arg1 = (FSTextMarkup *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = ((FSTextMarkup const *)arg1)->getQuadPoints(arg2);
  
  temp = new FSQuadPoints((const FSQuadPoints &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void _wrap_FSTextMarkup_setQuadPoints(void* imarg1, void* imarg2, int imarg3)
{
  FSTextMarkup *arg1 = (FSTextMarkup *) 0 ;
  FSQuadPoints *arg2 = (FSQuadPoints *) 0 ;
  FS_INT32 arg3 ;
  
  arg1 = (FSTextMarkup *)imarg1; 
  arg2 = (FSQuadPoints *)imarg2;
  arg3 = (FS_INT32)imarg3; 
  (arg1)->setQuadPoints((FSQuadPoints const *)arg2,arg3);
}

void _wrap_delete_FSHighlight(void* imarg1)
{
  FSHighlight *arg1 = (FSHighlight *) 0 ;
  
  arg1 = (FSHighlight *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSHighlight_resetAppearanceStream(void* imarg1)
{
  FSHighlight *arg1 = (FSHighlight *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSHighlight *)imarg1; 
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSUnderline(void* imarg1)
{
  FSUnderline *arg1 = (FSUnderline *) 0 ;
  
  arg1 = (FSUnderline *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSUnderline_resetAppearanceStream(void* imarg1)
{
  FSUnderline *arg1 = (FSUnderline *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSUnderline *)imarg1; 
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSStrikeOut(void* imarg1)
{
  FSStrikeOut *arg1 = (FSStrikeOut *) 0 ;
  
  arg1 = (FSStrikeOut *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSStrikeOut_resetAppearanceStream(void* imarg1)
{
  FSStrikeOut *arg1 = (FSStrikeOut *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSStrikeOut *)imarg1; 
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSSquiggly(void* imarg1)
{
  FSSquiggly *arg1 = (FSSquiggly *) 0 ;
  
  arg1 = (FSSquiggly *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSSquiggly_resetAppearanceStream(void* imarg1)
{
  FSSquiggly *arg1 = (FSSquiggly *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSSquiggly *)imarg1; 
  result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_FSSquare(void* imarg1)
{
    FSSquare *arg1 = (FSSquare *) 0 ;
        
    arg1 = (FSSquare *)imarg1;
    delete arg1;
}
    
unsigned int _wrap_FSSquare_getFillColor(void* imarg1)
{
    FSSquare *arg1 = (FSSquare *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSSquare *)imarg1;
    result = (FS_ARGB)((FSSquare const *)arg1)->getFillColor();
    imresult = result;
    return imresult;
}

void _wrap_FSSquare_setFillColor(void* imarg1,unsigned int imarg2)
{
    FSSquare *arg1 = (FSSquare *) 0;
    FS_ARGB arg2 ;
    
    arg1 = (FSSquare *)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setFillColor(arg2);
}
  
void* _wrap_FSSquare_getInnerRect(void* imarg1)
{
    FSSquare* arg1 = (FSSquare *) 0;
    FSRectF result;
    FSRectF* temp = 0;
    void* imresult = 0;
    
    arg1 = (FSSquare*) imarg1;
    result = ((FSSquare const *)arg1)->getInnerRect();
    temp = new FSRectF((FSRectF const &)result);
    imresult = (void*)temp;
    
    return imresult;
    
}

void _wrap_FSSquare_setInnerRect(void* imarg1, void * imarg2)
{
    if (!imarg2) return;
    FSSquare *arg1 = (FSSquare *) 0 ;
    FSRectF *arg2 ;
    FSRectF temp;
    
    arg1 = (FSSquare *)imarg1;
    arg2 = (FSRectF *)imarg2;
    temp.left = arg2->left;
    temp.right = arg2->right;
    temp.bottom = arg2->bottom;
    temp.top = arg2->top;
    (arg1)->setInnerRect(temp);
}
    
BOOL _wrap_FSSquare_resetAppearanceStream(void* imarg1)
{
    FSSquare *arg1 = (FSSquare *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
        
    arg1 = (FSSquare *)imarg1;
    result = (FS_BOOL)(arg1)->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}
    
void _wrap_delete_FSCircle(void* imarg1)
{
    FSCircle *arg1 = (FSCircle *) 0;
    
    arg1 = (FSCircle *)imarg1;
    delete arg1;
}
   
BOOL _wrap_FSCircle_resetAppearanceStream(void* imarg1)
{
    FSCircle *arg1 = (FSCircle *) 0;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSCircle *)imarg1;
    result = (FS_BOOL)(arg1)->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}

unsigned int _wrap_FSCircle_getFillColor(void* imarg1)
{
    FSCircle *arg1 = (FSCircle *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSCircle *)imarg1;
    result = (FS_ARGB)((FSCircle const *)arg1)->getFillColor();
    imresult = result;
    return imresult;
}

void _wrap_FSCircle_setFillColor(void* imarg1, unsigned int imarg2)
{
    FSCircle *arg1 = (FSCircle *) 0;
    FS_ARGB arg2 ;
    
    arg1 = (FSCircle *)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setFillColor(arg2);
}

void* _wrap_FSCircle_getInnerRect(void* imarg1)
{
    FSCircle* arg1 = (FSCircle *) 0;
    FSRectF result;
    FSRectF* temp = 0;
    void* imresult = 0;
    
    arg1 = (FSCircle*) imarg1;
    result = ((FSCircle const *)arg1)->getInnerRect();
    temp = new FSRectF((FSRectF const &)result);
    imresult = (void*)temp;
    
    return imresult;
        
}

void _wrap_FSCircle_setInnerRect(void* imarg1, void* imarg2)
{
    if (!imarg2) return;
    FSCircle *arg1 = (FSCircle *) 0 ;
    FSRectF *arg2 ;
    FSRectF temp;
    
    arg1 = (FSCircle *)imarg1;
    arg2 = (FSRectF *)imarg2;
    temp.left = arg2->left;
    temp.right = arg2->right;
    temp.top = arg2->top;
    temp.bottom = arg2->bottom;
    (arg1)->setInnerRect(temp);
}

void _wrap_delete_FSLink(void* imarg1)
{
  FSLink *arg1 = (FSLink *) 0 ;
  
  arg1 = (FSLink *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSLink_resetAppearanceStream(void* imarg1)
{
  FSLink *arg1 = (FSLink *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSLink *)imarg1;
    if (arg1)
        result = (FS_BOOL)(arg1)->resetAppearanceStream();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSLink_getQuadPointsCount(void* imarg1)
{
  FSLink *arg1 = (FSLink *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSLink *)imarg1;
    if (arg1)
        result = (FS_INT32)((FSLink const *)arg1)->getQuadPointsCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSLink_getQuadPoints(void* imarg1, int imarg2)
{
  FSLink *arg1 = (FSLink *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSQuadPoints *temp ;
  FSQuadPoints result;
  
  arg1 = (FSLink *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    if (arg1)
        result = ((FSLink const *)arg1)->getQuadPoints(arg2);
  
  temp = new FSQuadPoints((const FSQuadPoints &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

int _wrap_FSLink_getHighlightingMode(void* imarg1)
{
  FSLink *arg1 = (FSLink *) 0 ;
  int imresult = 0 ;
  FSM_HIGHLIGHTINGMODE result;
  
  arg1 = (FSLink *)imarg1;
    if (arg1)
        result = (FSM_HIGHLIGHTINGMODE)(arg1)->getHighlightingMode();
  imresult = (int)result; 
  return imresult;
}
    
void _wrap_FSLink_setQuadPoints(void* imarg1, void* imarg2, int imarg3)
{
    FSLink *arg1 = (FSLink *) 0 ;
    FSQuadPoints *arg2 = (FSQuadPoints *) 0 ;
    FS_INT32 arg3 ;
    
    arg1 = (FSLink *)imarg1;
    arg2 = (FSQuadPoints *)imarg2;
    arg3 = (FS_INT32)imarg3;
    if (arg1)
        (arg1)->setQuadPoints((FSQuadPoints const *)arg2, arg3);
}

void _wrap_FSLink_setHighlightingMode(void* imarg1, int imarg2)
{
    FSLink *arg1 = (FSLink *) 0 ;
    FSM_HIGHLIGHTINGMODE arg2 ;
    
    arg1 = (FSLink *)imarg1;
    arg2 = (FSM_HIGHLIGHTINGMODE)imarg2;
    if (arg1)
        (arg1)->setHighlightingMode(arg2);
}

void _wrap_FSLink_setAction(void* imarg1, void* imarg2)
{
    FSLink *arg1 = (FSLink *) 0 ;
    FSAction *arg2 = (FSAction *) 0 ;
    arg1 = (FSLink *)imarg1;
    arg2 = (FSAction *)imarg2;
    if (arg1)
        (arg1)->setAction(arg2);
}
    
BOOL _wrap_FSLink_removeAction(void* imarg1)
{
    FSLink *arg1 = (FSLink *)0;
    arg1 = (FSLink*)imarg1;
    FS_BOOL result;
    BOOL imresult = 0;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    
    result = arg1->removeAction();
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSLink_getAction(void* imarg1)
{
  FSLink *arg1 = (FSLink *) 0 ;
  void* imresult = 0 ;
  FSAction *result = 0 ;
  
  arg1 = (FSLink *)imarg1;
    if (arg1)
        result = (FSAction *)(arg1)->getAction();
  imresult = (void*)result; 
  return imresult;
}
 
void _wrap_delete_FSFreeText(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    arg1 = (FSFreeText*)imarg1;
    delete arg1;
}

BOOL _wrap_FSFreeText_resetAppearanceStream(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSFreeText*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
        
}

unsigned int _wrap_FSFreeText_getFillColor(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSFreeText *)imarg1;
    result = (FS_ARGB)((FSFreeText const *)arg1)->getFillColor();
    imresult = result;
    return imresult;

}

void _wrap_FSFreeText_setFillColor(void* imarg1, unsigned int imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    FS_ARGB arg2 ;
    
    arg1 = (FSFreeText *)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setFillColor(arg2);
}

int _wrap_FSFreeText_getAlignment(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    int imresult = 0;
    FS_INT32 result;
    
    arg1 = (FSFreeText*)imarg1;
    result = (FS_INT32)((FSFreeText const *)arg1)->getAlignment();
    imresult = result;
    return imresult;
}
    
void _wrap_FSFreeText_setAlignment(void* imarg1, int imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    FS_INT32 arg2;
    
    arg1 = (FSFreeText*)imarg1;
    arg2 = (FS_INT32)imarg2;
    (arg1)->setAlignment(arg2);
}
    
void* _wrap_FSFreeText_getInnerRect(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0 ;
    void* imresult = 0 ;
    FSRectF *temp ;
    FSRectF result;
    
    arg1 = (FSFreeText *)imarg1;
    result = ((FSFreeText const *)arg1)->getInnerRect();
    
    temp = new FSRectF((const FSRectF &)result);
    imresult = (void*)temp;
    
    return imresult;
    
}
void _wrap_FSFreeText_setInnerRect(void* imarg1, void* imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0 ;
    FSRectF *arg2 ;
    FSRectF temp;
    
    arg1 = (FSFreeText *)imarg1;
    if (imarg2) {
        arg2 = (FSRectF *)imarg2;
        temp = *arg2;
        (arg1)->setInnerRect(temp);
    }
}

void* _wrap_FSFreeText_getDefaultAppearance(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0 ;
    FSDefaultAppearance result;
    FSDefaultAppearance* temp;
    void* imresult;
    
    
    arg1 = (FSFreeText*)imarg1;
    result = (arg1)->getDefaultAppearance();
    
    //temp = new FSDefaultAppearance((const FSDefaultAppearance &) result);
    temp = new FSDefaultAppearance();
    temp->set(result.flags, result.font, result.fontSize, result.textColor);
    imresult = (void*)temp;
    
    return imresult;
}
    
BOOL _wrap_FSFreeText_setDefaultAppearance(void* imarg1, void* imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    _FSDefaultAppearance arg2;
    _FSDefaultAppearance* temp;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSFreeText*)imarg1;
    temp = (_FSDefaultAppearance*)imarg2;
    if (imarg2) {
        arg2 = *temp;
        result = (arg1)->setDefaultAppearance(arg2);
        imresult = (result)? YES:NO;
    }
    return imresult;
}
    
NSString * _wrap_FSFreeText_getCalloutLineEndingStyle(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFreeText *)imarg1;
    result = ((FSFreeText const *)arg1)->getCalloutLineEndingStyle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}
    
void _wrap_FSFreeText_setCalloutLineEndingStyle(void* imarg1, NSString * imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0 ;
    NSString* defaultLineEndgingStyle = @"None";
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSFreeText *)imarg1;
    {
        arg2 = 0;
        if (imarg2&& imarg2.length>0) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setCalloutLineEndingStyle((char const *)arg2);
        }
        else{
            arg2 = [defaultLineEndgingStyle cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setCalloutLineEndingStyle((char const *)arg2);
        }
    }
}

int _wrap_FSFreeText_getCalloutLinePointCount(void* imarg1)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    FS_INT32 result;
    int imresult = 0;
    
    arg1 = (FSFreeText*)imarg1;
    result = (FS_INT32)((FSFreeText const *)arg1)->getCalloutLinePointCount();
    imresult = result;
    
    return imresult;
}

void* _wrap_FSFreeText_getCalloutLinePoint(void* imarg1, int imarg2)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    FSPointF result;
    FS_INT32 arg2 ;
    void* imresult = 0 ;
    FSPointF *temp ;
    
    arg1 = (FSFreeText *)imarg1;
    arg2 = (FS_INT32)imarg2;
    result = ((FSFreeText const *)arg1)->getCalloutLinePoint(arg2);
    
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSFreeText_setCalloutLinePoints(void* imarg1, void* imarg2, void* imarg3, void* imarg4)
{
    FSFreeText *arg1 = (FSFreeText *) 0;
    FSPointF *temp1 = (FSPointF*)imarg2;
    FSPointF *temp2 = (FSPointF*)imarg3;
    FSPointF *temp3 = (FSPointF*)imarg4;
    FSPointF arg2;
    FSPointF arg3;
    FSPointF arg4;
    
    if (imarg1 && imarg2 && imarg3 && imarg4) {
        arg1 = (FSFreeText*)imarg1;
        arg2 = *temp1;
        arg3 = *temp2;
        arg4 = *temp3;
        if (fabs(arg2.x-arg3.x)>0.00001 || fabs(arg2.y-arg3.y)>0.00001) {
             (arg1)->setCalloutLinePoints(arg2, arg3, arg4);
        }
    }
}

void* _wrap_FSFont_create(NSString* imarg1, unsigned int imarg2, int imarg3, int imarg4)
{
    const char* arg1 = (const char*) 0;
    FS_DWORD arg2 = (FS_DWORD)imarg2;
    FS_INT32 arg3 = (FS_INT32)imarg3;
    void* imresult = 0 ;
    FSFont* result = 0 ;
    
    if (imarg1) {
        arg1 = [imarg1 cStringUsingEncoding:NSUTF8StringEncoding];
    }
    result = (FSFont *)FSFont::create((const char*)arg1, arg2, arg3, (FS_FONTCHARSET)imarg4);
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSFont_createStandard(int imarg1)
{
    void* imresult = 0;
    FSFont* result = 0;
    
    result = (FSFont*)FSFont::createStandard((FS_STANDARDFONTID)imarg1);
    imresult = (void*)result;
    return imresult;

}

NSString * _wrap_FSFont_getName(void* imarg1)
{
    FSFont *arg1 = (FSFont *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFont *)imarg1;
    result = arg1->getName();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_delete_FSFont(void* imarg1)
{
    FSFont* arg1 = (FSFont *) 0;
    arg1 = (FSFont*)imarg1;
    arg1->release();
}
    
void _wrap_delete_FSDefaultAppearance(void* imarg1)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    arg1 = (_FSDefaultAppearance*)imarg1;
    delete arg1;
        
}
    
void* _wrap_new_FSDefaultAppearance()
{
    void* imresult = 0 ;
    _FSDefaultAppearance *result = 0 ;
    
    result = (_FSDefaultAppearance *)new _FSDefaultAppearance();
    imresult = (void*)result;
    return imresult;
        
}
    
void _wrap_FSDefaultAppearance_set(void* imarg1, unsigned int imarg2, void* imarg3, float imarg4, unsigned int imarg5)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    FS_DWORD arg2;
    FSFont* arg3;
    FS_FLOAT arg4;
    FS_ARGB arg5;
    
    arg1 = (_FSDefaultAppearance*)imarg1;
    
    arg2 = (FS_DWORD)imarg2;
    arg3 = (FSFont*)imarg3;
    arg4 = (FS_FLOAT)imarg4;
    arg5 = (FS_ARGB)imarg5;
    if (arg1 && arg3){
        (arg1)->set(arg2, arg3, arg4, arg5);
    }
    if (arg1 && arg3) {

        (arg1)->set(arg2, arg3, arg4, arg5);
    }
}
 
unsigned int _wrap_FSDefaultAppearance_flags_get(void* imarg1)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance *) 0;
    unsigned int imresult = 0;
    FS_DWORD result = 0;
        
    arg1 = (_FSDefaultAppearance *)imarg1;
        
    result = (arg1)->flags;
    imresult = result;
    return imresult;
}
void* _wrap_FSDefaultAppearance_font_get(void* imarg1)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance *) 0;
    void* imresult = 0;
    FSFont* result = 0;
    
    arg1 = (_FSDefaultAppearance *)imarg1;
    result = (arg1)->font;
    imresult = (void*)result;
    
    return imresult;
        
}
float _wrap_FSDefaultAppearance_fontSize_get(void* imarg1)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance *) 0;
    float imresult = 0;
    FS_FLOAT result = 0;
    
    arg1 = (_FSDefaultAppearance *)imarg1;
    
    result = (arg1)->fontSize;
    imresult = result;
    return imresult;
}
unsigned int _wrap_FSDefaultAppearance_textColor_get(void* imarg1)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance *) 0;
    unsigned int imresult = 0;
    FS_ARGB result = 0;
    
    arg1 = (_FSDefaultAppearance *)imarg1;
    result = (arg1)->textColor;
    imresult = (unsigned int)result;
    
    return imresult;
}

void _wrap_FSDefaultAppearance_flags_set(void* imarg1, unsigned int imarg2)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    FS_DWORD arg2 = (FS_DWORD)imarg2;
    
    arg1 = (_FSDefaultAppearance*)imarg1;
   
    if (arg1){
        (arg1)->flags = arg2;
    }
        
}

void _wrap_FSDefaultAppearance_font_set(void* imarg1, void* imarg2)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    FSFont* arg2 = (FSFont*)imarg2;
    
    arg1 = (_FSDefaultAppearance*)imarg1;
    
    if (arg1 && arg2){
        (arg1)->font = arg2;
    }
}

void _wrap_FSDefaultAppearance_fontSize_set(void* imarg1, float imarg2)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    FS_FLOAT arg2 = (FS_FLOAT)imarg2;
    
    arg1 = (_FSDefaultAppearance*)imarg1;
    
    if (arg1){
        (arg1)->fontSize = arg2;
    }
}

void _wrap_FSDefaultAppearance_textColor_set(void* imarg1, unsigned int imarg2)
{
    _FSDefaultAppearance* arg1 = (_FSDefaultAppearance*) 0;
    FS_ARGB arg2 = (FS_ARGB)imarg2;
    
    arg1 = (_FSDefaultAppearance*)imarg1;
    
    if (arg1){
        (arg1)->textColor = arg2;
    }
}

void* _wrap_FSPDFPath_create()
{
    void* imresult = 0;
    FSPDFPath* result = 0;
    
    result = (FSPDFPath*)FSPDFPath::create();
    imresult = (void*)result;
    return imresult;
}
    
int _wrap_FSPDFPath_getPointCount(void* imarg1)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FS_INT32 result =0;
    int imresult;
    
    arg1 = (FSPDFPath*)imarg1;
    result = (arg1)->getPointCount();
    imresult = (int) result;
    return imresult;
}

void* _wrap_FSPDFPath_getPoint(void* imarg1, int imarg2)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FSPointF result;
    FS_INT32 arg2;
    FSPointF* temp = (FSPointF *) 0;
    void* imresult = nil;
    
    arg1 = (FSPDFPath*)imarg1;
    arg2 = (FS_INT32)imarg2;
    result = (arg1)->getPoint(arg2);
    
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    return imresult;
}

int _wrap_FSPDFPath_getPointType(void* imarg1, int imarg2)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    arg1 = (FSPDFPath*)imarg1;
    FS_INT32 arg2 = (FS_INT32) imarg2;
    FS_PATHPOINTTYPE result;
    int imresult;
    
    result = (FS_PATHPOINTTYPE)(arg1)->getPointType(arg2);
    imresult = (int)result;
    return imresult;
}
    
BOOL _wrap_FSPDFPath_setPoint(void* imarg1, int imarg2, void* imarg3, int imarg4)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg3);
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FS_INT32 arg2 = (FS_INT32) imarg2;
    FSPointF* temp = (FSPointF *) 0;
    FSPointF arg3;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSPDFPath *)imarg1;
    temp = (FSPointF*)imarg3;
    if (!temp) {
        return NO;
    }
    arg3 = *temp;
    
    result = (arg1)->setPoint(arg2, arg3, (FS_PATHPOINTTYPE)imarg4);
    imresult = (result)? YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPath_moveTo(void* imarg1, void* imarg2)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FSPointF* temp = (FSPointF*)imarg2;
    FSPointF arg2;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSPDFPath*)imarg1;
    if (!temp) {
        return NO;
    }
    arg2 = *temp;
    result = (arg1)->moveTo(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPath_lineTo(void* imarg1, void* imarg2)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FSPointF* temp = (FSPointF*)imarg2;
    FSPointF arg2;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSPDFPath*)imarg1;
    if (!temp) {
        return NO;
    }
    arg2 = *temp;
    result = (arg1)->lineTo(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPath_cubicBezierTo(void* imarg1, void* imarg2, void* imarg3, void* imarg4)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    THROWEXCEPTION_IF_NULLPOINTER(imarg3);
    THROWEXCEPTION_IF_NULLPOINTER(imarg4);
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FSPointF* temp1 = (FSPointF*)imarg2;
    FSPointF* temp2 = (FSPointF*)imarg3;
    FSPointF* temp3 = (FSPointF*)imarg4;
    FSPointF arg2;
    FSPointF arg3;
    FSPointF arg4;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSPDFPath*)imarg1;
    if (!temp1 || !temp2 || !temp3) {
        return NO;
    }
    arg2 = *temp1;
    arg3 = *temp2;
    arg4 = *temp3;
    result = (arg1)->cubicBezierTo(arg2, arg3, arg4);
    imresult = (result)? YES:NO;
    return imresult;
    
}
    
BOOL _wrap_FSPDFPath_closeFigure(void* imarg1)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSPDFPath*)imarg1;
    result = (arg1)->closeFigure();
    imresult = (result)?YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPath_removePoint(void* imarg1, int imarg2)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    FS_BOOL result;
    BOOL imresult;
    FS_INT32 arg2;
    
    arg1 = (FSPDFPath*)imarg1;
    arg2 = (FS_INT32)imarg2;
    result = (arg1)->removePoint(arg2);
    imresult = (result)?YES:NO;
    return imresult;
}
    
void _wrap_FSPDFPath_clear(void* imarg1)
{
    FSPDFPath* arg1 = (FSPDFPath *) 0;
    arg1 = (FSPDFPath*)imarg1;
    
    (arg1)->clear();
}
    
void _wrap_delete_FSPDFPath(void* imarg1)
{
    FSPDFPath *arg1 = (FSPDFPath *) 0 ;
    
    arg1 = (FSPDFPath *)imarg1;
    arg1->release();
}

void _wrap_delete_FSInk(void* imarg1)
{
    FSInk *arg1 = (FSInk*) 0;
    
    arg1 = (FSInk*)imarg1;
    delete arg1;
}

BOOL _wrap_FSInk_resetAppearanceStream(void* imarg1)
{
    FSInk* arg1 = (FSInk*) 0;
    FS_BOOL result;
    BOOL imresult;
    
    arg1 = (FSInk*)imarg1;
    result = (arg1)->resetAppearanceStream();
    imresult = (result)?YES:NO;
    return imresult;
}

void* _wrap_FSInk_getInkList(void* imarg1)
{
    FSInk* arg1 = (FSInk*) 0;
    FSPDFPath* result = (FSPDFPath*) 0;
    void* imresult;
    
    arg1 = (FSInk*)imarg1;
    result = (arg1)->getInkList();
    imresult = (void*)result;
    return imresult;
}
    
void _wrap_FSInk_setInkList(void* imarg1, void* imarg2)
{
    FSInk* arg1 = (FSInk*)imarg1;
    FSPDFPath* arg2 = (FSPDFPath*)imarg2;
    
    (arg1)->setInkList(arg2);
}

void _wrap_delete_FSLine(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0 ;
    
    arg1 = (FSLine *)imarg1;
    delete arg1;
}
    
BOOL _wrap_FSLine_resetAppearanceStream(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSLine*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}

NSString* _wrap_FSLine_getLineStartingStyle(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSLine *)imarg1;
    result = ((FSLine const *)arg1)->getLineStartingStyle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSLine_setLineStartingStyle(void* imarg1, NSString* imarg2)
{
    FSLine *arg1 = (FSLine *) 0 ;
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSLine *)imarg1;
    {
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setLineStartingStyle((char const *)arg2);
}
    
NSString* _wrap_FSLine_getLineEndingStyle(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSLine *)imarg1;
    result = ((FSLine const *)arg1)->getLineEndingStyle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSLine_setLineEndingStyle(void* imarg1, NSString* imarg2)
{
    FSLine *arg1 = (FSLine *) 0 ;
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSLine *)imarg1;
    {
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setLineEndingStyle((char const *)arg2);
}

unsigned int _wrap_FSLine_getStyleFillColor(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSLine *)imarg1;
    result = (FS_ARGB)((FSLine const *)arg1)->getStyleFillColor();
    imresult = result;
    return imresult;
}
    
void _wrap_FSLine_setStyleFillColor(void* imarg1, unsigned int imarg2)
{
    
    FSLine *arg1 = (FSLine *) 0;
    FS_ARGB arg2 ;
    
    arg1 = (FSLine *)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setStyleFillColor(arg2);
}
    
void* _wrap_FSLine_getStartPoint(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    FSPointF result;
    void* imresult = 0 ;
    FSPointF *temp ;
    
    arg1 = (FSLine *)imarg1;
    result = ((FSLine const *)arg1)->getStartPoint();
    
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSLine_setStartPoint(void* imarg1, void* imarg2)
{
    FSLine *arg1 = (FSLine *) 0;
    FSPointF *temp1 = (FSPointF*)imarg2;
    FSPointF arg2;
    
    arg1 = (FSLine*)imarg1;
    if (!temp1) {
        return;
    }
    arg2 = *temp1;
    (arg1)->setStartPoint(arg2);
        
}

void * _wrap_FSLine_getEndPoint(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    FSPointF result;
    void* imresult = 0 ;
    FSPointF *temp ;
    
    arg1 = (FSLine *)imarg1;
    result = ((FSLine const *)arg1)->getEndPoint();
    
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    
    return imresult;
        
}
    
void _wrap_FSLine_setEndPoint(void* imarg1, void* imarg2)
{
    FSLine *arg1 = (FSLine *) 0;
    FSPointF *temp = (FSPointF*) imarg2;
    FSPointF arg2;
    
    arg1 = (FSLine*) imarg1;
    if (!temp) {
        return;
    }
    arg2 = *temp;
    (arg1)->setEndPoint(arg2);
        
}

BOOL _wrap_FSline_hasCaption(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSLine*)imarg1;
    result = ((FSLine const *)arg1)->hasCaption();
    imresult = (result)? YES:NO;
    return imresult;
        
}

void _wrap_FSLine_enableCaption(void* imarg1, BOOL imarg2)
{
    FSLine* arg1 = (FSLine*) 0;
    FS_BOOL arg2 = false;
    
    arg1 = (FSLine *)imarg1;
    arg2 = imarg2? true : false;
    (arg1)->enableCaption(arg2);
}
    
NSString* _wrap_FSLine_getCaptionPositionType(void* imarg1)
{
    FSLine* arg1 = (FSLine*) 0;
    NSString* imresult = nil;
    FSString result = nil;
    
    arg1 = (FSLine*)imarg1;
    result = ((FSLine const *)arg1)->getCaptionPositionType();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSLine_setCaptionPositionType(void* imarg1, NSString* imarg2)
{
    FSLine *arg1 = (FSLine *) 0 ;
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSLine *)imarg1;
    {
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setCaptionPositionType((char const *)arg2);
}

void* _wrap_FSLine_getCaptionOffset(void* imarg1)
{
    FSLine *arg1 = (FSLine *) 0;
    FSOffset result;
    void* imresult = 0 ;
    FSOffset *temp ;
    
    arg1 = (FSLine *)imarg1;
    result = ((FSLine const *)arg1)->getCaptionOffset();
    
    temp = new FSOffset((const FSOffset &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSLine_setCaptionOffset(void* imarg1, void* imarg2)
{
    FSLine *arg1 = (FSLine *) 0;
    FSOffset *temp = (FSOffset*) imarg2;
    FSOffset arg2;
    
    arg1 = (FSLine*) imarg1;
    if (!temp)
        return;
    arg2 = *temp;
    (arg1)->setCaptionOffset(arg2);
}

void _wrap_delete_FSStamp(void* imarg1)
{
    FSStamp *arg1 = (FSStamp *) 0 ;
    
    arg1 = (FSStamp *)imarg1;
    delete arg1;
}
    
BOOL _wrap_FSStamp_resetAppearanceStream(void* imarg1)
{
    FSStamp *arg1 = (FSStamp *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSStamp*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}
    
NSString* _wrap_FSStamp_getIconName(void* imarg1)
{
    FSStamp* arg1 = (FSStamp*) 0;
    NSString* imresult;
    FSString result;
    
    arg1 = (FSStamp*)imarg1;
    result = ((FSStamp const *)arg1)->getIconName();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}
    
void _wrap_FSStamp_setIconName(void* imarg1, NSString* imarg2)
{
    FSStamp *arg1 = (FSStamp *) 0 ;
    char const *arg2 = (char const *) 0 ;
    NSString* defaultIconName = @"Draft";
    
    arg1 = (FSStamp *)imarg1;
    if (imarg2.length ==0 &&imarg2)
        {
            arg2 = [defaultIconName cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setIconName((char const *)arg2);
        }
    else if(imarg2)
        {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setIconName((char const *)arg2);
        }
}
    
void _wrap_FSStamp_setBitmap(void* imarg1, void* imarg2)
{
    FSStamp *arg1 = (FSStamp*) 0;
    FSBitmap *arg2 = (FSBitmap*) imarg2;
    
    arg1 = (FSStamp*) imarg1;
    (arg1)->setBitmap(arg2);
}

void _wrap_FSStamp_setImagePath(void* imarg1, NSString* imarg2)
{
    FSStamp *arg1 = (FSStamp*) 0;
    char const *arg2 = (char const *) 0 ;
    arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];

    arg1 = (FSStamp*) imarg1;
    (arg1)->setImagePath((char const*)(arg2));
}
    
    
void _wrap_delete_FSPolygon(void* imarg1)
{
    FSPolygon *arg1 = (FSPolygon *) 0 ;
    
    arg1 = (FSPolygon *)imarg1;
    delete arg1;
}
    
BOOL _wrap_FSPolygon_resetAppearanceStream(void* imarg1)
{
    FSPolygon *arg1 = (FSPolygon *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSPolygon*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}

unsigned int _wrap_FSPolygon_getFillColor(void* imarg1)
{
    FSPolygon *arg1 = (FSPolygon *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSPolygon *)imarg1;
    result = (FS_ARGB)((FSPolygon const *)arg1)->getFillColor();
    imresult = result;
    return imresult;
}
    
void _wrap_FSPolygon_setFillColor(void* imarg1, unsigned int imarg2)
{
    FSPolygon* arg1 = (FSPolygon*) 0;
    FS_ARGB arg2;
    
    arg1 = (FSPolygon*)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setFillColor(arg2);
}
    
int _wrap_FSPolygon_getVertexCount(void* imarg1)
{
    FSPolygon* arg1 = (FSPolygon*) 0;
    FS_INT32 result;
    int imresult;
    
    arg1 = (FSPolygon*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    result = arg1->getVertexCount();
    imresult = (int)result;
    return imresult;
}

void* _wrap_FSPolygon_getVertex(void* imarg1,int imarg2)
{
    FSPolygon* arg1 = (FSPolygon*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    FS_INT32 arg2 = (FS_INT32)imarg2;
    FSPointF result;
    FSPointF* temp = (FSPointF*) 0;
    void* imresult = (void*) 0;
    
    result = (arg1)->getVertex(arg2);
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSPolygon_setVertexes(void* imarg1, void* imarg2, int imarg3)
{
    FSPolygon* arg1 = (FSPolygon*)imarg1;
    FSPointF* arg2 = (FSPointF*)imarg2;
    FS_INT32 arg3 = (FS_INT32)imarg3;
    
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    if (arg2) {
        arg1->setVertexes(arg2, arg3);
    }
}

void _wrap_delete_FSPolyLine(void* imarg1)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0 ;
    
    arg1 = (FSPolyLine *)imarg1;
    delete arg1;
}
    
BOOL _wrap_FSPolyLine_resetAppearanceStream(void* imarg1)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSPolyLine*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}
    
unsigned int _wrap_FSPolyLine_getStyleFillColor(void* imarg1)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0;
    unsigned int imresult = 0;
    FS_ARGB result;
    
    arg1 = (FSPolyLine *)imarg1;
    result = (FS_ARGB)((FSPolyLine const *)arg1)->getStyleFillColor();
    imresult = result;
    return imresult;
}
    
void _wrap_FSPolyLine_setStyleFillColor(void* imarg1, unsigned int imarg2)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0;
    FS_ARGB arg2 ;
    
    arg1 = (FSPolyLine *)imarg1;
    arg2 = (FS_ARGB)imarg2;
    (arg1)->setStyleFillColor(arg2);
}
    
int _wrap_FSPolyLine_getVertexCount(void* imarg1)
{
    FSPolyLine* arg1 = (FSPolyLine*) 0;
    FS_INT32 result;
    int imresult;

    arg1 = (FSPolyLine*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    result = arg1->getVertexCount();
    imresult = (int)result;
    return imresult;
}
    
void* _wrap_FSPolyLine_getVertex(void* imarg1, int imarg2)
{
    FSPolyLine* arg1 = (FSPolyLine*)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1);
    FS_INT32 arg2 = (FS_INT32)imarg2;
    FSPointF result;
    FSPointF* temp = (FSPointF*) 0;
    void* imresult = (void*) 0;
    
    result = (arg1)->getVertex(arg2);
    temp = new FSPointF((const FSPointF &)result);
    imresult = (void*)temp;
    
    return imresult;
}
    
void _wrap_FSPolyLine_setVertexes(void* imarg1, void* imarg2, int imarg3)
{
    FSPolyLine* arg1 = (FSPolyLine*)imarg1;
    FSPointF* arg2 = (FSPointF*)imarg2;
    FS_INT32 arg3 = (FS_INT32)imarg3;
    
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    if (arg2) {
        arg1->setVertexes(arg2, arg3);
    }
}
    
NSString* _wrap_FSPolyLine_getLineStartingStyle(void* imarg1)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSPolyLine *)imarg1;
    result = ((FSPolyLine const *)arg1)->getLineStartingStyle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}
    
void _wrap_FSPolyLine_setLineStartingStyle(void* imarg1, NSString* imarg2)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0 ;
    NSString* defaultStyle = @"None";
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSPolyLine *)imarg1;
    {
        if (imarg2 && imarg2.length>0) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setLineStartingStyle((char const *)arg2);
        }
        else
        {
            arg2 = [defaultStyle cStringUsingEncoding:NSUTF8StringEncoding];
            (arg1)->setLineStartingStyle((char const*)arg2);
        }
    }
   
}

NSString* _wrap_FSPolyLine_getLineEndingStyle(void* imarg1)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSPolyLine *)imarg1;
    result = ((FSPolyLine const *)arg1)->getLineEndingStyle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSPolyLine_setLineEndingStyle(void* imarg1, NSString* imarg2)
{
    FSPolyLine *arg1 = (FSPolyLine *) 0 ;
    NSString* defaultStyle = @"None";
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSPolyLine *)imarg1;
    {
        if (imarg2 && imarg2.length>0) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
        else{
            arg2 = [defaultStyle cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setLineEndingStyle((char const *)arg2);
}
    
void _wrap_delete_FSCaret(void* imarg1)
{
    FSCaret *arg1 = (FSCaret *) 0 ;
    
    arg1 = (FSCaret *)imarg1;
    delete arg1;
}

BOOL _wrap_FSCaret_resetAppearanceStream(void* imarg1)
{
    FSCaret *arg1 = (FSCaret *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSCaret*)imarg1;
    result = arg1->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}
    
void* _wrap_FSCaret_getInnerRect(void* imarg1)
{
    FSCaret *arg1 = (FSCaret *) 0 ;
    void* imresult = 0 ;
    FSRectF *temp ;
    FSRectF result;
    
    arg1 = (FSCaret *)imarg1;
    result = ((FSCaret const *)arg1)->getInnerRect();
    
    temp = new FSRectF((const FSRectF &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSCaret_setInnerRect(void* imarg1, void* imarg2)
{
    FSCaret *arg1 = (FSCaret *) 0 ;
    FSRectF *arg2 ;
    FSRectF temp;
    
    arg1 = (FSCaret *)imarg1;
    if (imarg2) {
        arg2 = (FSRectF *)imarg2;
        temp = *arg2;
        (arg1)->setInnerRect(temp);
    }
}

void _wrap_delete_FSBookmark(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  delete arg1;
}

void* _wrap_FSBookmark_getParent(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  void* imresult = 0 ;
  FSBookmark *result = 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FSBookmark *)((FSBookmark*)arg1)->getParent();
  imresult = (void*)result; 
  return imresult;
}
    
void* _wrap_FSBookmark_insert(void* imarg1, NSString * imarg2, int imarg3)
{
    void* imresult = 0;
    FSBookmark* result = 0;
    char const *arg2 = (char const *) 0 ;
    if (imarg2) {
        arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
    result = (FSBookmark *)((FSBookmark*)imarg1)->insert((char const *)arg2, (FS_BOOKMARKPOSITION)imarg3);
    imresult = (void*)result;
    return imresult;
}
    
BOOL _wrap_FSBookmark_moveTo(void* imarg1, void* imarg2, int imarg3)
{
    FSBookmark* arg1 = (FSBookmark *) 0;
    FSBookmark* arg2 = (FSBookmark *) 0;
    BOOL imresult = 0;
    FS_BOOL result;
    
    arg1 = (FSBookmark*)imarg1;
    arg2 = (FSBookmark*)imarg2;
    result = ((FSBookmark*)arg1)->moveTo((FSBookmark*)arg2, (FS_BOOKMARKPOSITION)imarg3);
    imresult = (result)? YES:NO;
    return imresult;
}
    
void* _wrap_FSBookmark_getFirstChild(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  void* imresult = 0 ;
  FSBookmark *result = 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FSBookmark *)((FSBookmark*)arg1)->getFirstChild();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSBookmark_getNextSibling(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  void* imresult = 0 ;
  FSBookmark *result = 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FSBookmark *)((FSBookmark *)arg1)->getNextSibling();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSBookmark_getDestination(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  void* imresult = 0 ;
  FSDestination *result = 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FSDestination *)((FSBookmark *)arg1)->getDestination();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSBookmark_setDestination(void* imarg1, void* imarg2)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  FSDestination *arg2 = (FSDestination *) 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  arg2 = (FSDestination *)imarg2; 
  (arg1)->setDestination((FSDestination const *)arg2);
}

NSString * _wrap_FSBookmark_getTitle(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSBookmark *)imarg1; 
  result = ((FSBookmark const *)arg1)->getTitle();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_FSBookmark_setTitle(void* imarg1, NSString * imarg2)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSBookmark *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->setTitle((char const *)arg2);
}

unsigned int _wrap_FSBookmark_getColor(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  unsigned int imresult = 0 ;
  FS_ARGB result;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FS_ARGB)((FSBookmark const *)arg1)->getColor();
  imresult = result; 
  return imresult;
}

void _wrap_FSBookmark_setColor(void* imarg1, unsigned int imarg2)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  FS_ARGB arg2 ;
  
  arg1 = (FSBookmark *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  (arg1)->setColor(arg2);
}

unsigned int _wrap_FSBookmark_getStyle(void* imarg1)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSBookmark *)imarg1; 
  result = (FS_DWORD)((FSBookmark const *)arg1)->getStyle();
  imresult = result; 
  return imresult;
}

void _wrap_FSBookmark_setStyle(void* imarg1, unsigned int imarg2)
{
  FSBookmark *arg1 = (FSBookmark *) 0 ;
  FS_DWORD arg2 ;
  
  arg1 = (FSBookmark *)imarg1; 
  arg2 = (FS_DWORD)imarg2; 
  (arg1)->setStyle(arg2);
}

NSString * _wrap_FSReadingBookmark_getTitle(void* imarg1)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSReadingBookmark *)imarg1;
    if (!arg1) {
        return nil;
    }
    result = ((FSReadingBookmark const *)arg1)->getTitle();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}
    
void _wrap_FSReadingBookmark_setTitle(void* imarg1, NSString * imarg2)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) 0 ;
    char const *arg2 = (char const *) 0 ;
    
    arg1 = (FSReadingBookmark *)imarg1;
    if (!arg1) {
        return;
    }
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setTitle((char const *)arg2);
}
int _wrap_FSReadingBookmark_getPageIndex(void* imarg1)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) imarg1 ;
    if (!arg1) {
        return -1;
    }
    return arg1->getPageIndex();
}
void _wrap_FSReadingBookmark_setPageIndex(void* imarg1, int pageIndex)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) imarg1 ;
    if (!arg1) {
        return;
    }
    arg1->setPageIndex(pageIndex);
}

void* _wrap_FSReadingBookmark_getDateTime(void* imarg1, BOOL imarg2)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) 0 ;
    FS_BOOL arg2 ;
    void* imresult = 0 ;
    FSDateTime *temp ;
    FSDateTime result;
    
    arg1 = (FSReadingBookmark *)imarg1;
    arg2 = imarg2? true : false;
    result = ((FSReadingBookmark const *)arg1)->getDateTime(arg2);
    
    temp = new FSDateTime((const FSDateTime &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSReadingBookmark_setDateTime(void* imarg1, void* imarg2, BOOL imarg3)
{
    if (!imarg1 ||!imarg2) return;
    FSReadingBookmark *arg1 = (FSReadingBookmark *) 0 ;
    FSDateTime arg2 ;
    FS_BOOL arg3 ;
    FSDateTime *argp2 ;
    
    arg1 = (FSReadingBookmark *)imarg1;
    
    argp2 = (FSDateTime *)imarg2;
    arg2 = *argp2; 
    
    arg3 = imarg3? true : false; 
    (arg1)->setDateTime(arg2,arg3);
}

void _wrap_delete_FSReadingBookmark(void* imarg1)
{
    FSReadingBookmark *arg1 = (FSReadingBookmark *) imarg1 ;
    delete arg1;
}
    
void _wrap_FSPageLabel_set(void* imarg1, int imarg2, int imarg3, NSString * imarg4, int imarg5)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  FS_INT32 arg2 ;
  FS_PAGELABELSTYLE arg3 ;
  char const *arg4 = 0;
  FS_INT32 arg5 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_PAGELABELSTYLE)imarg3; 
  {
    arg4 = 0;
    if (imarg4) {
      arg4 = [imarg4 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg5 = (FS_INT32)imarg5; 
  (arg1)->set(arg2,arg3,(char const (*))arg4,arg5);
}

void _wrap_FSPageLabel_start_set(void* imarg1, int imarg2)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->start = arg2;
}

int _wrap_FSPageLabel_start_get(void* imarg1)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSPageLabel *)imarg1; 
  result = (FS_INT32) ((arg1)->start);
  imresult = result; 
  return imresult;
}

void _wrap_FSPageLabel_style_set(void* imarg1, int imarg2)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  FS_PAGELABELSTYLE arg2 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  arg2 = (FS_PAGELABELSTYLE)imarg2; 
  if (arg1) (arg1)->style = arg2;
}

int _wrap_FSPageLabel_style_get(void* imarg1)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  int imresult = 0 ;
  FS_PAGELABELSTYLE result;
  
  arg1 = (_FSPageLabel *)imarg1; 
  result = (FS_PAGELABELSTYLE) ((arg1)->style);
  imresult = (int)result; 
  return imresult;
}

void _wrap_FSPageLabel_prefix_set(void* imarg1, NSString * imarg2)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  char const *arg2 = 0;
  
  arg1 = (_FSPageLabel *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  {
    if(arg2) {
      strncpy((char*)arg1->prefix, (const char *)arg2, 100-1);
      arg1->prefix[100-1] = 0;
    } else {
      arg1->prefix[0] = 0;
    }
  }
}

NSString * _wrap_FSPageLabel_prefix_get(void* imarg1)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  NSString * imresult = 0 ;
  char *result = 0 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  result = (char *)(char *) ((arg1)->prefix);
  if (result) imresult = [NSString stringWithUTF8String: (const char*)result]; 
  return imresult;
}

void _wrap_FSPageLabel_firstPageNumber_set(void* imarg1, int imarg2)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  if (arg1) (arg1)->firstPageNumber = arg2;
}

int _wrap_FSPageLabel_firstPageNumber_get(void* imarg1)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (_FSPageLabel *)imarg1; 
  result = (FS_INT32) ((arg1)->firstPageNumber);
  imresult = result; 
  return imresult;
}

void* _wrap_new_FSPageLabel()
{
  void* imresult = 0 ;
  _FSPageLabel *result = 0 ;
  
  result = (_FSPageLabel *)new _FSPageLabel();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSPageLabel(void* imarg1)
{
  _FSPageLabel *arg1 = (_FSPageLabel *) 0 ;
  
  arg1 = (_FSPageLabel *)imarg1; 
  delete arg1;
}

void* _wrap_FSPDFDoc_createFromFilePath(NSString * imarg1)
{
  char const *arg1 = (char const *) 0 ;
  void* imresult = 0 ;
  FSPDFDoc *result = 0 ;
  
  {
    arg1 = 0;
    if (imarg1) {
      arg1 = [imarg1 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FSPDFDoc *)FSPDFDoc::createFromFilePath((char const *)arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_createFromMemory(NSData * imarg1, int imarg2)
{
  void *arg1 = (void *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSPDFDoc *result = 0 ;
  {
    arg1 = 0;
    if (imarg1) {
      arg1 = (void*)[imarg1 bytes];
    }
  }
  arg2 = (FS_INT32)imarg2; 
  result = (FSPDFDoc *)FSPDFDoc::createFromMemory((void const *)arg1,arg2, FALSE);
  imresult = (void*)result; 
  return imresult;
}


NSData * _wrap_FSPDFDoc_ConvertPDF2OFD(NSData * imarg1, int imarg2)
{
    std::string cplusinStr;

    cplusinStr.assign((char*)[imarg1 bytes], imarg1.length);

    std::string cplusoutStr;

    bool result = PdfToOfdByData(cplusinStr, cplusoutStr);

    if (result) {
        
        NSData * data = [NSData dataWithBytes:(void*)cplusoutStr.c_str() length:cplusoutStr.length()];
        
       return data;
        
    }
    
    return NULL;
}

NSData * _wrap_FSPDFDoc_ConvertOFD2PDF(NSData * imarg1, int imarg2)
{
    std::string cplusinStr;

    cplusinStr.assign((char*)[imarg1 bytes], imarg1.length);

    std::string cplusoutStr;

    bool result = OfdToPdfByData(cplusinStr, cplusoutStr);

    if (result) {
        
        NSData * data = [NSData dataWithBytes:(void*)cplusoutStr.c_str() length:cplusoutStr.length()];
        
       return data;
        
    }
    
    return NULL;
}

BOOL _wrap_FSPDFDoc_ConvertPDF2OFDFromFilePath(NSString * from, NSString * to)
{
    char const *arg1 = (char const *) 0 ;
    {
      arg1 = 0;
      if (from) {
        arg1 = [from cStringUsingEncoding:NSUTF8StringEncoding];
      }
    }
    
    char const *arg2 = (char const *) 0 ;
    {
      arg2 = 0;
      if (to) {
        arg2 = [to cStringUsingEncoding:NSUTF8StringEncoding];
      }
    }
    
    bool result = PdfToOfdByName(arg1, arg2);

    return result;
}
BOOL _wrap_FSPDFDoc_ConvertOFD2PDFFromFilePath(NSString * from, NSString * to)
{
    char const *arg1 = (char const *) 0 ;
    {
      arg1 = 0;
      if (from) {
        arg1 = [from cStringUsingEncoding:NSUTF8StringEncoding];
      }
    }
    
    char const *arg2 = (char const *) 0 ;
    {
      arg2 = 0;
      if (to) {
        arg2 = [to cStringUsingEncoding:NSUTF8StringEncoding];
      }
    }
    
    bool result = OfdToPdfByName(arg1, arg2);

    return result;
}

BOOL _wrap_FSPDFDoc_SealSignBySettingNoUI(NSString * inOfd,NSString * outOfd,NSString * oesName,NSString * sealid,NSString * password,float xpos,float ypos,NSArray* range,int * subrange,NSString * key,BOOL matchcase,BOOL matchword,NSString * keyindex,int sealSigntype,int pageSealType,int startPage,int endPage,BOOL duplexPrint,int firstPagePrint,int pageSealDirection,int pageSealCoordinates)
//BOOL _wrap_FSPDFDoc_SealSignBySettingNoUI(NSString * inOfd,
//                                          NSString * outOfd,
//                                          NSString * oesName,
//                                          NSString * sealid,
//                                          NSString * password,
//                                          float xpos,
//                                          float ypos,
//                                          NSArray* range,
//                                          int * subrange,
//                                          NSString * key,
//                                          BOOL matchcase,
//                                          BOOL matchword,
//                                          NSString * keyindex,
//                                          int sealSigntype,
//                                          int pageSealType,
//                                          int startPage,
//                                          int endPage,
//                                          BOOL duplexPrint,
//                                          int firstPagePrint,
//                                          int pageSealDirection,
//                                          int pageSealCoordinates
//                                          )
{
    char const *arg1 = (char const *) 0 ;
    {
      arg1 = 0;
      if (outOfd) {
        arg1 = [outOfd cStringUsingEncoding:NSUTF8StringEncoding];
      }
    }

    
    
    
    
    bool result;

    return result;
}

//BOOL _wrap_FSPDFDoc_SealSignBySetting(void* arg0,
//                                          NSString * outOfd,
//                                          NSString * oesName,
//                                          NSString * sealid,
//                                          NSString * password,
//                                          float xpos,
//                                          float ypos,
//                                          NSArray* range,
//                                          int * subrange,
//                                          NSString * key,
//                                          BOOL matchcase,
//                                          BOOL matchword,
//                                          NSString * keyindex,
//                                          int sealSigntype,
//                                          int pageSealType,
//                                          int startPage,
//                                          int endPage,
//                                          BOOL duplexPrint,
//                                          int firstPagePrint,
//                                          int pageSealDirection,
//                                          int pageSealCoordinates
//                                          )
//{
//    char const *arg1 = (char const *) 0 ;
//    {
//      arg1 = 0;
//      if (outOfd) {
//        arg1 = [outOfd cStringUsingEncoding:NSUTF8StringEncoding];
//      }
//    }
//
//    
//    
//    
//    
//    bool result;
//
//    return result;
//}

void* _wrap_FSPDFDoc_createFromHandler(FSFileReadCallback* imarg1)
{
  FSFileRead *arg1 = (FSFileRead *) 0 ;
  void* imresult = 0 ;
  FSPDFDoc *result = 0 ;
  
    if (imarg1) {
        gFSFileRead = imarg1;
        arg1 = &gFSFileRead;
    }  result = (FSPDFDoc *)FSPDFDoc::createFromHandler(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_GetImageWithPassword(NSString * password, NSString * sealID)
{
    
  char const *arg1 = (char const *) 0 ;
  {
    arg1 = 0;
    if (password) {
      arg1 = [password cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  
  char const *arg2 = (char const *) 0 ;
  {
    arg2 = 0;
    if (sealID) {
      arg2 = [sealID cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  
    printf("福昕 鲲鹏 +(FSSealImage*)GetImageWithPassword:(NSString*)password SealID:(NSString*)sealID; \n");
    
//    void * result = getSealImage(arg1, arg2);
    
    void * result;
    
//  FSSealImage * result = GetImageSeal(arg1, arg2);

  return result;

}

void* _wrap_FSPDFDoc_GetSealList(NSString * password)
{
    
  char const *arg1 = (char const *) 0 ;
  {
    arg1 = 0;
    if (password) {
      arg1 = [password cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  
    printf("福昕 鲲鹏 +(NSArray<FSSeal*>*)GetSealList:(NSString*)password; \n");
    
//    void * result = getSealList(arg1, arg2);
    
    void * result;
    
  return result;

}


NSString * _wrap_FSPDFDoc_GetSeal(void* imarg1, NSString * password,NSString * sealID)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
     char const *arg2 = (char const *) 0 ;
    char const *arg3 = (char const *) 0 ;
    
     NSString * imresult = 0 ;
     FSString result;
     
     arg1 = (FSPDFDoc *)imarg1;

     {
       arg2 = 0;
       if (password) {
         arg2 = [password cStringUsingEncoding:NSUTF8StringEncoding];
       }
     }
    
    {
         arg3 = 0;
         if (sealID) {
           arg3 = [sealID cStringUsingEncoding:NSUTF8StringEncoding];
         }
    }
    
    
    printf("福昕 鲲鹏 -(NSString*)GetSealWithPassword:(NSString*)password SealID:(NSString*)sealID; \n");

    
//       THROWEXCEPTION_IF_NULLPOINTER(arg1)
//     result = ((FSPDFDoc const *)arg1)->getMetadataValue((char const *)arg2);
//     {
//       if (0 < (result).getBufferLen()) {
//         imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
//       }
//     }
    
     return imresult;
    
}

NSString * _wrap_FSPDFDoc_GetCert(void* imarg1, NSString * password,NSString * sealID)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
     char const *arg2 = (char const *) 0 ;
    char const *arg3 = (char const *) 0 ;
    

    
     NSString * imresult = 0 ;
     FSString result;
     
     arg1 = (FSPDFDoc *)imarg1;

     {
       arg2 = 0;
       if (password) {
         arg2 = [password cStringUsingEncoding:NSUTF8StringEncoding];
       }
     }
    
    {
         arg3 = 0;
         if (sealID) {
           arg3 = [sealID cStringUsingEncoding:NSUTF8StringEncoding];
         }
    }
    
    
    printf("福昕 鲲鹏 -(NSString*)GetCertWithPassword:(NSString*)password SealID:(NSString*)sealID; \n");

    
//       THROWEXCEPTION_IF_NULLPOINTER(arg1)
//     result = ((FSPDFDoc const *)arg1)->getMetadataValue((char const *)arg2);
//     {
//       if (0 < (result).getBufferLen()) {
//         imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
//       }
//     }
    
     return imresult;
    
}


void* _wrap_FSPDFDoc_VerifySealSignAll(void* imarg1, NSString * password)
{
    
   FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
     char const *arg2 = (char const *) 0 ;
    
     FSPDFDoc * result = 0 ;
     
     arg1 = (FSPDFDoc *)imarg1;

     {
       arg2 = 0;
       if (password) {
         arg2 = [password cStringUsingEncoding:NSUTF8StringEncoding];
       }
     }

    
    printf("福昕 鲲鹏 -(NSString*)GetCertWithPassword:(NSString*)password SealID:(NSString*)sealID; \n");
//    if (imarg1) {
//        gFSFileRead = imarg1;
//        arg1 = &gFSFileRead;
//    }  result = (FSPDFDoc *)FSPDFDoc::createFromHandler(arg1);
//
    
        
  return result;
 
}



NSString * _wrap_FSPDFDoc_IsVerify(void* imarg1, NSString * password,NSString * sealID,BOOL isVerify)
{
     FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
         char const *arg2 = (char const *) 0 ;
        char const *arg3 = (char const *) 0 ;

         FS_BOOL arg4 ;
          arg4 = isVerify? true : false;
    
         NSString * imresult = 0 ;
         FSString result;
         
         arg1 = (FSPDFDoc *)imarg1;

         {
           arg2 = 0;
           if (password) {
             arg2 = [password cStringUsingEncoding:NSUTF8StringEncoding];
           }
         }
        
        {
             arg3 = 0;
             if (sealID) {
               arg3 = [sealID cStringUsingEncoding:NSUTF8StringEncoding];
             }
        }
        
        
        printf("福昕 鲲鹏 -(NSString*)GetCertWithPassword:(NSString*)password SealID:(NSString*)sealID; \n");

        
    //       THROWEXCEPTION_IF_NULLPOINTER(arg1)
    //     result = ((FSPDFDoc const *)arg1)->getMetadataValue((char const *)arg2);
    //     {
    //       if (0 < (result).getBufferLen()) {
    //         imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    //       }
    //     }
        
         return imresult;
    
    
    
    
}


int _wrap_FSPDFDoc_load(void* imarg1, NSString * imarg2, int imarg3)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  char const *arg2 = 0;
  FS_INT32 arg3 ;
  int imresult = 0 ;
  FS_ERRORCODE result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg3 = (FS_INT32)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_ERRORCODE)(arg1)->load((char const (*))arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_FSPDFDoc_isEncrypted(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSPDFDoc const *)arg1)->isEncrypted();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSPDFDoc_isModified(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSPDFDoc const *)arg1)->isModified();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSPDFDoc_getPasswordType(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_PASSWORDTYPE result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_PASSWORDTYPE)((FSPDFDoc const *)arg1)->getPasswordType();
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSPDFDoc_getEncryptionType(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_ENCRYPTTYPE result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_ENCRYPTTYPE)((FSPDFDoc const *)arg1)->getEncryptionType();
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSPDFDoc_checkPassword(void* imarg1, NSString * imarg2, int imarg3)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  char const *arg2 = 0;
  FS_INT32 arg3 ;
  int imresult = 0 ;
  FS_PASSWORDTYPE result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg3 = (FS_INT32)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_PASSWORDTYPE)(arg1)->checkPassword((char const (*))arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_FSPDFDoc_saveAs(void* imarg1, NSString * imarg2, unsigned int imarg3)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  char const *arg2 = (char const *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->saveAs((char const *)arg2, imarg3);
  imresult = (result)? YES:NO; 
  return imresult;
}
    
void* _wrap_FSPDFDoc_creatFirstBookmark(void* imarg1)
{
    FSPDFDoc *arg1 = (FSPDFDoc*)imarg1;
    void* imresult = 0;
    FSBookmark* result = 0;
    
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FSBookmark*)(arg1)->createFirstBookmark();
    imresult = (void*)result;
    return imresult;
}
    
BOOL _wrap_FSPDFDoc_removeBookmark(void* imarg1, void* imarg2)
{
    FSPDFDoc *arg1 = (FSPDFDoc*)imarg1;
    FSBookmark *arg2 = (FSBookmark*)imarg2;
    BOOL imresult = 0;
    FS_BOOL result;
    
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FS_BOOL)(arg1)->removeBookmark(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}
    
void* _wrap_FSPDFDoc_getFirstBookmark(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSBookmark *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSBookmark *)(arg1)->getFirstBookmark();
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSPDFDoc_getPageCount(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)(arg1)->getPageCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getPage(void* imarg1, int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSPDFPage *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFPage *)(arg1)->getPage(arg2);
  imresult = (void*)result;
  return imresult;
}

BOOL _wrap_FSPDFDoc_closePage(void* imarg1, int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_INT32 arg2 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->closePage(arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSPDFDoc_getDisplayMode(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_DISPLAYMODE result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_DISPLAYMODE)((FSPDFDoc const *)arg1)->getDisplayMode();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getCatalog(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSPDFDoc const *)arg1)->getCatalog();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getTrailer(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSPDFDoc const *)arg1)->getTrailer();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getInfo(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSPDFDoc const *)arg1)->getInfo();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getEncryptDict(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSPDFDoc const *)arg1)->getEncryptDict();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getIndirectObject(void* imarg1, unsigned int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_DWORD arg2 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_DWORD)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFObject *)(arg1)->getIndirectObject(arg2);
  imresult = (void*)result; 
  return imresult;
}

unsigned int _wrap_FSPDFDoc_addIndirectObject(void* imarg1, void* imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FSPDFObject *arg2 = (FSPDFObject *) 0 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FSPDFObject *)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_DWORD)(arg1)->addIndirectObject(arg2);
  imresult = result; 
  return imresult;
}

void _wrap_FSPDFDoc_deleteIndirectObject(void* imarg1, unsigned int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_DWORD arg2 ;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_DWORD)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  (arg1)->deleteIndirectObject(arg2);
}

unsigned int _wrap_FSPDFDoc_getUserPermissions(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_DWORD)((FSPDFDoc const *)arg1)->getUserPermissions();
  imresult = result; 
  return imresult;
}

BOOL _wrap_FSPDFDoc_isWrapper(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSPDFDoc const *)arg1)->isWrapper();
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSPDFDoc_getWrapperData(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSWrapperData *temp ;
  FSWrapperData result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSPDFDoc const *)arg1)->getWrapperData();
  
  temp = new FSWrapperData((const FSWrapperData &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

int _wrap_FSPDFDoc_getWrapperOffset(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)((FSPDFDoc const *)arg1)->getWrapperOffset();
  imresult = result; 
  return imresult;
}

BOOL _wrap_FSPDFDoc_hasMetadataKey(void* imarg1, NSString * imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  char const *arg2 = (char const *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSPDFDoc const *)arg1)->hasMetadataKey((char const *)arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSPDFDoc_getCreationDateTime(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSDateTime *temp ;
  FSDateTime result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSPDFDoc const *)arg1)->getCreationDateTime();
  
  temp = new FSDateTime((const FSDateTime &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSPDFDoc_getModifiedDateTime(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  void* imresult = 0 ;
  FSDateTime *temp ;
  FSDateTime result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSPDFDoc const *)arg1)->getModifiedDateTime();
  
  temp = new FSDateTime((const FSDateTime &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

NSString * _wrap_FSPDFDoc_getMetadataValue(void* imarg1, NSString * imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  char const *arg2 = (char const *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSPDFDoc const *)arg1)->getMetadataValue((char const *)arg2);
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}


int _wrap_FSPDFDoc_getPageLabelRangeCount(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFDoc *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)((FSPDFDoc const *)arg1)->getPageLabelRangeCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFDoc_getPageLabelInfo(void* imarg1, int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSPageLabel *temp ;
  FSPageLabel result;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = ((FSPDFDoc const *)arg1)->getPageLabelInfo(arg2);
  
  temp = new FSPageLabel((const FSPageLabel &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

BOOL _wrap_FSPDFDoc_hasForm(void* imarg1)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSPDFDoc *)imarg1;
    result = (FS_BOOL)((FSPDFDoc const *)arg1)->hasForm();
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSPDFDoc_getForm(void* imarg1)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
    void* imresult = 0 ;
    FSForm *result = 0 ;
    
    arg1 = (FSPDFDoc *)imarg1;
    result = (FSForm *)(arg1)->getForm();
    imresult = (void*)result; 
    return imresult;
}

int _wrap_FSPDFDoc_getReadingBookmarkCount(void* imarg1)
{
      return ((FSPDFDoc *)imarg1)->getReadingBookmarkCount();
}
    
void* _wrap_FSPDFDoc_getReadingBookmark(void* imarg1, int index)
{
    return ((FSPDFDoc *)imarg1)->getReadingBookmark(index);
}
    
void* _wrap_FSPDFDoc_insertReadingBookmark(void* imarg1, int readingBookmarkIndex, NSString* title, int pageIndex)
{
    return ((FSPDFDoc *)imarg1)->insertReadingBookmark(readingBookmarkIndex, [title cStringUsingEncoding:NSUTF8StringEncoding], pageIndex);
}
    
BOOL _wrap_FSPDFDoc_removeReadingBookmark(void* imarg1, void* bookmark)
{
    return ((FSPDFDoc *)imarg1)->removeReadingBookmark((FSReadingBookmark*)bookmark);
}

int _wrap_FSPDFDoc_getSignatureCount(void* imarg1)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSPDFDoc *)imarg1;
    result = (FS_INT32)(arg1)->getSignatureCount();
    imresult = result;
    return imresult;
}

void* _wrap_FSPDFDoc_getSignature(void* imarg1, int imarg2)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
    FS_INT32 arg2 ;
    void* imresult = 0 ;
    FSSignature *result = 0 ;
    
    arg1 = (FSPDFDoc *)imarg1;
    arg2 = (FS_INT32)imarg2;
    result = (FSSignature *)(arg1)->getSignature(arg2);
    imresult = (void*)result; 
    return imresult;
}

void _wrap_delete_FSPDFDoc(void* imarg1)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  
  arg1 = (FSPDFDoc *)imarg1; 
  delete arg1;
}

void* _wrap_FSPDFObject_createFromBoolean(BOOL imarg1)
{
  FS_BOOL arg1 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = imarg1? true : false; 
  result = (FSPDFObject *)FSPDFObject::createFromBoolean(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createFromFloat(float imarg1)
{
  FS_FLOAT arg1 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FS_FLOAT)imarg1; 
  result = (FSPDFObject *)FSPDFObject::createFromFloat(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createFromInteger(int imarg1)
{
  FS_INT32 arg1 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FS_INT32)imarg1; 
  result = (FSPDFObject *)FSPDFObject::createFromInteger(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createFromString(NSString * imarg1)
{
  char const *arg1 = (char const *) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  {
    arg1 = 0;
    if (imarg1) {
      arg1 = [imarg1 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FSPDFObject *)FSPDFObject::createFromString((char const *)arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createFromName(NSString * imarg1)
{
  char const *arg1 = (char const *) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  {
    arg1 = 0;
    if (imarg1) {
      arg1 = [imarg1 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FSPDFObject *)FSPDFObject::createFromName((char const *)arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createFromDateTime(void* imarg1)
{
  FSDateTime arg1 ;
  void* imresult = 0 ;
  FSDateTime *argp1 ;
  FSPDFObject *result = 0 ;
  
  
  argp1 = (FSDateTime *)imarg1;
    if (!argp1) {
        return NULL;
    }
  arg1 = *argp1; 
  
  result = (FSPDFObject *)FSPDFObject::createFromDateTime(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_createReference(void* imarg1, unsigned int imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FS_DWORD arg2 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1; 
  arg2 = (FS_DWORD)imarg2; 
  result = (FSPDFObject *)FSPDFObject::createReference(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_cloneObject(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FSPDFObject *)((FSPDFObject const *)arg1)->cloneObject();
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSPDFObject_getType(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  int imresult = 0 ;
  FS_PDFOBJECTTYPE result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FS_PDFOBJECTTYPE)((FSPDFObject const *)arg1)->getType();
  imresult = (int)result; 
  return imresult;
}

unsigned int _wrap_FSPDFObject_getObjNum(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FS_DWORD)((FSPDFObject const *)arg1)->getObjNum();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFObject_getInteger(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FS_INT32)((FSPDFObject const *)arg1)->getInteger();
  imresult = result; 
  return imresult;
}

float _wrap_FSPDFObject_getFloat(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FS_FLOAT)((FSPDFObject const *)arg1)->getFloat();
  imresult = result; 
  return imresult;
}

BOOL _wrap_FSPDFObject_getBoolean(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FS_BOOL)((FSPDFObject const *)arg1)->getBoolean();
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSPDFObject_getMatrix(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  void* imresult = 0 ;
  FSMatrix *temp ;
  FSMatrix result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = ((FSPDFObject const *)arg1)->getMatrix();
  
  temp = new FSMatrix((const FSMatrix &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSPDFObject_getRect(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = ((FSPDFObject const *)arg1)->getRect();
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSPDFObject_getDirectObject(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = (FSPDFObject *)((FSPDFObject const *)arg1)->getDirectObject();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFObject_getDateTime(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  void* imresult = 0 ;
  FSDateTime *temp ;
  FSDateTime result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = ((FSPDFObject const *)arg1)->getDateTime();
  
  temp = new FSDateTime((const FSDateTime &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

NSString * _wrap_FSPDFObject_getString(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFObject *)imarg1; 
  result = ((FSPDFObject const *)arg1)->getString();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void _wrap_delete_FSPDFObject(void* imarg1)
{
  FSPDFObject *arg1 = (FSPDFObject *) 0 ;
  
  arg1 = (FSPDFObject *)imarg1; 
  delete arg1;
}

void* _wrap_new_FSPDFObject()
{
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  result = (FSPDFObject *)new FSPDFObject();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFStream_create(void* imarg1)
{
    FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
    void* imresult = 0 ;
    FSPDFStream *result = 0 ;
    
    arg1 = (FSPDFDictionary *)imarg1;
    result = (FSPDFStream *)FSPDFStream::create(arg1);
    imresult = (void*)result;
    return imresult;
}

void _wrap_delete_FSPDFStream(void* imarg1)
{
  FSPDFStream *arg1 = (FSPDFStream *) 0 ;
  
  arg1 = (FSPDFStream *)imarg1; 
  delete arg1;
}

void* _wrap_FSPDFStream_getDictionary(void* imarg1)
{
  FSPDFStream *arg1 = (FSPDFStream *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFStream *)imarg1; 
  result = (FSPDFDictionary *)(arg1)->getDictionary();
  imresult = (void*)result; 
  return imresult;
}

unsigned int _wrap_FSPDFStream_getDataSize(void* imarg1, BOOL imarg2)
{
  FSPDFStream *arg1 = (FSPDFStream *) 0 ;
  FS_BOOL arg2 ;
  unsigned int imresult = 0 ;
  FS_DWORD result;
  
  arg1 = (FSPDFStream *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (FS_DWORD)(arg1)->getDataSize(arg2);
  imresult = result; 
  return imresult;
}

NSData * _wrap_FSPDFStream_getData(void* imarg1, BOOL imarg2, int imarg4)
{
  FSPDFStream *arg1 = (FSPDFStream *) 0 ;
  FS_BOOL arg2 ;
  void *arg3 = (void *) 0 ;
  FS_INT32 arg4 ;
  NSData* imresult = nil ;
  FS_BOOL result;
  
  arg1 = (FSPDFStream *)imarg1; 
  arg2 = imarg2? true : false; 
  {
    if (0 < imarg4)
    {
        arg3 = new unsigned char[imarg4];
        memset(arg3, 0, sizeof(unsigned char)*imarg4);
    }
  }
  arg4 = (FS_INT32)imarg4; 
  result = (FS_BOOL)(arg1)->getData(arg2,arg3,arg4);
  if (result)
      imresult = [NSData dataWithBytes: arg3 length:arg4];
    if (arg3)
        delete arg3;
  return imresult;
}

void _wrap_FSPDFStream_setData(void* imarg1, NSData * imarg2, unsigned int imarg3)
{
  FSPDFStream *arg1 = (FSPDFStream *) 0 ;
  void *arg2 = (void *) 0 ;
  FS_DWORD arg3 ;
  
  arg1 = (FSPDFStream *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = (void*)[imarg2 bytes];
    }
  }
  arg3 = (FS_DWORD)imarg3; 
  (arg1)->setData((void const *)arg2,arg3);
}

void* _wrap_new_FSPDFStream()
{
  void* imresult = 0 ;
  FSPDFStream *result = 0 ;
  
  result = (FSPDFStream *)new FSPDFStream();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFArray_create()
{
    void* imresult = 0 ;
    FSPDFArray *result = 0 ;
    
    result = (FSPDFArray *)FSPDFArray::create();
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSPDFArray_createFromMatrix(void* imarg1)
{
    FSMatrix arg1 ;
    void* imresult = 0 ;
    FSMatrix *argp1 ;
    FSPDFArray *result = 0 ;
    
    
    argp1 = (FSMatrix *)imarg1;
    arg1 = *argp1;
    
    result = (FSPDFArray *)FSPDFArray::createFromMatrix(arg1);
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSPDFArray_createFromRect(void* imarg1)
{
    FSRectF arg1 ;
    void* imresult = 0 ;
    FSRectF *argp1 ;
    FSPDFArray *result = 0 ;
    
    
    argp1 = (FSRectF *)imarg1;
    
    if (!argp1)
        return nil;
    arg1 = *argp1; 
    
    result = (FSPDFArray *)FSPDFArray::createFromRect(arg1);
    imresult = (void*)result; 
    return imresult;
}

void _wrap_delete_FSPDFArray(void* imarg1)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  delete arg1;
}

int _wrap_FSPDFArray_getElementCount(void* imarg1)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFArray *)imarg1; 
  result = (FS_INT32)((FSPDFArray const *)arg1)->getElementCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFArray_getElement(void* imarg1, int imarg2)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FSPDFObject *)((FSPDFArray const *)arg1)->getElement(arg2);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSPDFArray_addElement(void* imarg1, void* imarg2)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  FSPDFObject *arg2 = (FSPDFObject *) 0 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  arg2 = (FSPDFObject *)imarg2; 
  (arg1)->addElement(arg2);
}

void _wrap_FSPDFArray_insertAt(void* imarg1, int imarg2, void* imarg3)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  FS_INT32 arg2 ;
  FSPDFObject *arg3 = (FSPDFObject *) 0 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FSPDFObject *)imarg3; 
  (arg1)->insertAt(arg2,arg3);
}

void _wrap_FSPDFArray_setAt(void* imarg1, int imarg2, void* imarg3)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  FS_INT32 arg2 ;
  FSPDFObject *arg3 = (FSPDFObject *) 0 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FSPDFObject *)imarg3; 
  (arg1)->setAt(arg2,arg3);
}

void _wrap_FSPDFArray_removeAt(void* imarg1, int imarg2)
{
  FSPDFArray *arg1 = (FSPDFArray *) 0 ;
  FS_INT32 arg2 ;
  
  arg1 = (FSPDFArray *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  (arg1)->removeAt(arg2);
}

void* _wrap_new_FSPDFArray()
{
  void* imresult = 0 ;
  FSPDFArray *result = 0 ;
  
  result = (FSPDFArray *)new FSPDFArray();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDictionary_create()
{
    void* imresult = 0 ;
    FSPDFDictionary *result = 0 ;
    
    result = (FSPDFDictionary *)FSPDFDictionary::create();
    imresult = (void*)result;
    return imresult;
}

void _wrap_delete_FSPDFDictionary(void* imarg1)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  delete arg1;
}

BOOL _wrap_FSPDFDictionary_hasKey(void* imarg1, NSString * imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  char const *arg2 = (char const *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FS_BOOL)((FSPDFDictionary const *)arg1)->hasKey((char const *)arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_FSPDFDictionary_getElement(void* imarg1, NSString * imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  char const *arg2 = (char const *) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  result = (FSPDFObject *)((FSPDFDictionary const *)arg1)->getElement((char const *)arg2);
  imresult = (void*)result; 
  return imresult;
}

NSString * _wrap_FSPDFDictionary_getKey(void* imarg1, void* imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  FS_POSITION arg2 = (FS_POSITION) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  arg2 = (FS_POSITION)imarg2; 
  result = ((FSPDFDictionary const *)arg1)->getKey(arg2);
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

void* _wrap_FSPDFDictionary_getValue(void* imarg1, void* imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  FS_POSITION arg2 = (FS_POSITION) 0 ;
  void* imresult = 0 ;
  FSPDFObject *result = 0 ;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  arg2 = (FS_POSITION)imarg2; 
  result = (FSPDFObject *)((FSPDFDictionary const *)arg1)->getValue(arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFDictionary_moveNext(void* imarg1, void* imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  FS_POSITION arg2 = (FS_POSITION) 0 ;
  void* imresult = 0 ;
  FS_POSITION result;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  arg2 = (FS_POSITION)imarg2; 
  result = (FS_POSITION)(arg1)->moveNext(arg2);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_FSPDFDictionary_setAt(void* imarg1, NSString * imarg2, void* imarg3)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  char const *arg2 = (char const *) 0 ;
  FSPDFObject *arg3 = (FSPDFObject *) 0 ;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  arg3 = (FSPDFObject *)imarg3; 
  (arg1)->setAt((char const *)arg2,arg3);
}

void _wrap_FSPDFDictionary_removeAt(void* imarg1, NSString * imarg2)
{
  FSPDFDictionary *arg1 = (FSPDFDictionary *) 0 ;
  char const *arg2 = (char const *) 0 ;
  
  arg1 = (FSPDFDictionary *)imarg1; 
  {
    arg2 = 0;
    if (imarg2) {
      arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    }
  }
  (arg1)->removeAt((char const *)arg2);
}

void* _wrap_new_FSPDFDictionary()
{
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  result = (FSPDFDictionary *)new FSPDFDictionary();
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSPDFPage(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  delete arg1;
}

void* _wrap_FSPDFPage_getDocument(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSPDFDoc *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDoc *)((FSPDFPage const *)arg1)->getDocument();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFPage_getDict(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSPDFDictionary *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSPDFDictionary *)((FSPDFPage const *)arg1)->getDict();
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSPDFPage_isParsed(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)((FSPDFPage const *)arg1)->isParsed();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSPDFPage_startParse(void* imarg1, unsigned int imarg2, FSPauseCallback* imarg3, BOOL imarg4)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_DWORD arg2 ;
  FSPause *arg3 = (FSPause *) 0 ;
  FS_BOOL arg4 ;
  int imresult = 0 ;
  FS_PROGRESSSTATE result;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_DWORD)imarg2; 
    if (imarg3)
    {
        gFSPause = imarg3;
        arg3 = &gFSPause;
    }
  arg4 = imarg4? true : false;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_PROGRESSSTATE)(arg1)->startParse(arg2,arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSPDFPage_continueParse(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  int imresult = 0 ;
  FS_PROGRESSSTATE result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_PROGRESSSTATE)(arg1)->continueParse();
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSPDFPage_getIndex(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)((FSPDFPage const *)arg1)->getIndex();
  imresult = result; 
  return imresult;
}

float _wrap_FSPDFPage_getHeight(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_FLOAT)((FSPDFPage const *)arg1)->getHeight();
  imresult = result; 
  return imresult;
}

float _wrap_FSPDFPage_getWidth(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  float imresult = 0 ;
  FS_FLOAT result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_FLOAT)((FSPDFPage const *)arg1)->getWidth();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFPage_getRotation(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  int imresult = 0 ;
  FS_ROTATION result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_ROTATION)((FSPDFPage const *)arg1)->getRotation();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_FSPDFPage_loadThumbnail(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSBitmap *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSBitmap *)(arg1)->loadThumbnail();
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFPage_getDisplayMatrix(void* imarg1, int imarg2, int imarg3, int imarg4, int imarg5, int imarg6)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_INT32 arg2 ;
  FS_INT32 arg3 ;
  FS_INT32 arg4 ;
  FS_INT32 arg5 ;
  FS_ROTATION arg6 ;
  void* imresult = 0 ;
  FSMatrix *temp ;
  FSMatrix result;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_INT32)imarg3; 
  arg4 = (FS_INT32)imarg4; 
  arg5 = (FS_INT32)imarg5; 
  arg6 = (FS_ROTATION)imarg6;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (arg1)->getDisplayMatrix(arg2,arg3,arg4,arg5,arg6);
  
  temp = new FSMatrix((const FSMatrix &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSPDFPage_calcContentBBox(void* imarg1, int imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_CALCMARGINMODE arg2 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_CALCMARGINMODE)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (arg1)->calcContentBBox(arg2);
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

int _wrap_FSPDFPage_getAnnotCount(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_INT32)(arg1)->getAnnotCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFPage_getAnnot(void* imarg1, int imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSAnnot *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FS_INT32)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSAnnot *)(arg1)->getAnnot(arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFPage_getAnnotAtPos(void* imarg1, void* imarg2, float imarg3)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FSPointF arg2 ;
  FS_FLOAT arg3 ;
  void* imresult = 0 ;
  FSPointF *argp2 ;
  FSAnnot *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  
  argp2 = (FSPointF *)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(argp2)
  arg2 = *argp2;
  
  arg3 = (FS_FLOAT)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSAnnot *)(arg1)->getAnnotAtPos(arg2,arg3);
  imresult = (void*)result; 
  return imresult;
}
    
void* _wrap_FSPDFPage_getAnnotAtDevicePos(void* imarg1, void* imarg2, void* imarg3, float imarg4)
{
    FSPDFPage *arg1 = (FSPDFPage *) 0 ;
    FSMatrix* arg2 = 0;
    FSPointF arg3 ;
    FS_FLOAT arg4 ;
    void* imresult = 0 ;
    FSPointF *argp3 ;
    FSAnnot *result = 0 ;
    
    
    arg1 = (FSPDFPage *)imarg1;
    arg2 = (FSMatrix*)imarg2;
    argp3 = (FSPointF *)imarg3;
    THROWEXCEPTION_IF_NULLPOINTER(argp3);
    arg3 = *argp3;
    
    arg4 = (FS_FLOAT)imarg4;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FSAnnot *)(arg1)->getAnnotAtDevicePos(arg2, arg3, arg4);
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSPDFPage_addAnnot(void* imarg1, int imarg2, void* imarg3)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FSAnnot::FS_ANNOTTYPE arg2 ;
  FSRectF arg3 ;
  void* imresult = 0 ;
  FSRectF *argp3 ;
  FSAnnot *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FSAnnot::FS_ANNOTTYPE)imarg2; 
  
  argp3 = (FSRectF *)imarg3;
    if (!argp3) {
        return NULL;
    }
  arg3 = *argp3; 
  
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FSAnnot *)(arg1)->addAnnot(arg2,arg3);
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSPDFPage_removeAnnot(void* imarg1, void* imarg2)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  FSAnnot *arg2 = (FSAnnot *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFPage *)imarg1; 
  arg2 = (FSAnnot *)imarg2;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
  result = (FS_BOOL)(arg1)->removeAnnot(arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSPDFPage_hasTransparency(void* imarg1)
{
    FSPDFPage *arg1 = (FSPDFPage *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FS_BOOL)(arg1)->hasTransparency();
    imresult = (result)? YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPage_flatten(void* imarg1, BOOL isDisplay, unsigned int options)
{
    FSPDFPage *arg1 = (FSPDFPage *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSPDFPage *)imarg1;
    THROWEXCEPTION_IF_NULLPOINTER(arg1)
    result = (FS_BOOL)(arg1)->flatten(isDisplay, options);
    imresult = (result)? YES:NO;
    return imresult;
}
    
BOOL _wrap_FSPDFPage_setAnnotGroup(void* imarg1, void** imarg2, int imarg3, int imarg4)
{
    FSPDFPage *arg1 = (FSPDFPage *) 0 ;
    FSMarkup** arg2 = (FSMarkup**)imarg2;
    BOOL imresult = 0 ;
    FS_BOOL result;
    FS_INT32 arg3 = (FS_INT32)imarg3;
    FS_INT32 arg4 = (FS_INT32)imarg4;
    
    arg1 = (FSPDFPage*)imarg1;
    result = (arg1)->setAnnotGroup(arg2, arg3, arg4);
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSPDFPage_addSignature(void* imarg1, void* imarg2)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    FSPDFPage *arg1 = (FSPDFPage *) 0 ;
    FSRectF arg2 ;
    void* imresult = 0 ;
    FSRectF *argp2 ;
    FSSignature *result = 0 ;
    
    arg1 = (FSPDFPage *)imarg1;
    
    argp2 = (FSRectF *)imarg2;
    arg2 = *argp2; 
    
    result = (FSSignature *)(arg1)->addSignature(arg2);
    imresult = (void*)result; 
    return imresult;
}

void* _wrap_FSBitmap_create(int imarg1, int imarg2, int imarg3, unsigned char * imarg4, int imarg5)
{
  FS_INT32 arg1 ;
  FS_INT32 arg2 ;
  FS_DIBFORMAT arg3 ;
  FS_LPBYTE arg4 = (FS_LPBYTE) 0 ;
  int arg5 ;
  void* imresult = 0 ;
  FSBitmap *result = 0 ;
  
  arg1 = (FS_INT32)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_DIBFORMAT)imarg3; 
  arg4 = (FS_LPBYTE)imarg4;
  arg5 = (int)imarg5; 
  result = (FSBitmap *)FSBitmap::create(arg1,arg2,arg3,arg4,arg5);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSBitmap(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  
  arg1 = (FSBitmap *)imarg1; 
  delete arg1;
}

void* _wrap_FSBitmap_clone(void* imarg1, void* imarg2)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  FSRectI *arg2 = (FSRectI *) 0 ;
  void* imresult = 0 ;
  FSBitmap *result = 0 ;
  
  arg1 = (FSBitmap *)imarg1; 
  arg2 = (FSRectI *)imarg2; 
  result = (FSBitmap *)((FSBitmap const *)arg1)->clone((FSRectI const *)arg2);
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSBitmap_getWidth(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_INT32)((FSBitmap const *)arg1)->getWidth();
  imresult = result; 
  return imresult;
}

int _wrap_FSBitmap_getHeight(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_INT32)((FSBitmap const *)arg1)->getHeight();
  imresult = result; 
  return imresult;
}

int _wrap_FSBitmap_getPitch(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_INT32)((FSBitmap const *)arg1)->getPitch();
  imresult = result; 
  return imresult;
}

int _wrap_FSBitmap_getBpp(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_INT32)((FSBitmap const *)arg1)->getBpp();
  imresult = result; 
  return imresult;
}

NSData * _wrap_FSBitmap_getBuffer(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  NSData * imresult = 0 ;
  FS_LPBYTE result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_LPBYTE)((FSBitmap const *)arg1)->getBuffer();
  {
    if (result) {
        int pitch = arg1->getPitch();
        int height = arg1->getHeight();
        imresult = [NSData dataWithBytes: result length:pitch * height];
    }
  }
  return imresult;
}

int _wrap_FSBitmap_getFormat(void* imarg1)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  int imresult = 0 ;
  FS_DIBFORMAT result;
  
  arg1 = (FSBitmap *)imarg1; 
  result = (FS_DIBFORMAT)((FSBitmap const *)arg1)->getFormat();
  imresult = (int)result; 
  return imresult;
}

void _wrap_FSBitmap_fillRect(void* imarg1, unsigned int imarg2, void* imarg3)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  FS_ARGB arg2 ;
  FSRectI *arg3 = (FSRectI *) 0 ;
  
  arg1 = (FSBitmap *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  arg3 = (FSRectI *)imarg3; 
  (arg1)->fillRect(arg2,(FSRectI const *)arg3);
}

void* _wrap_FSRenderer_create(void* imarg1, BOOL imarg2)
{
  FSBitmap *arg1 = (FSBitmap *) 0 ;
  FS_BOOL arg2 ;
  void* imresult = 0 ;
  FSRenderer *result = 0 ;
  
  arg1 = (FSBitmap *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (FSRenderer *)FSRenderer::create(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSRenderer_createFromContext(CGContextRef imarg1, int imarg2)
{
  CGContextRef arg1 ;
  FS_DEVICETYPE arg2 ;
  void* imresult = 0 ;
  FSRenderer *result = 0 ;

  arg1 = 0;
  if (imarg1) {
      arg1 = imarg1;
  }
  arg2 = (FS_DEVICETYPE)imarg2; 
  result = (FSRenderer *)FSRenderer::createFromContext(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSRenderer_startRender(void* imarg1, void* imarg2, void* imarg3, FSPauseCallback* imarg4)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FSPDFPage *arg2 = (FSPDFPage *) 0 ;
  FSMatrix *arg3 = 0 ;
  FSPause *arg4 = (FSPause *) 0 ;
  int imresult = 0 ;
  FS_PROGRESSSTATE result;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = (FSPDFPage *)imarg2; 
  arg3 = (FSMatrix *)imarg3;
    FSMatrix mat;
    if (!arg3) {
        mat.set(1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);
        arg3 = &mat;
    }
    arg4 = (FSPause *)imarg4;
    if (imarg4)
    {
        gFSPause = imarg4;
        arg4 = &gFSPause;
    }
  result = (FS_PROGRESSSTATE)(arg1)->startRender(arg2,(FSMatrix const &)*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_FSRenderer_continueRender(void* imarg1)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  int imresult = 0 ;
  FS_PROGRESSSTATE result;
  
  arg1 = (FSRenderer *)imarg1; 
  result = (FS_PROGRESSSTATE)(arg1)->continueRender();
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_FSRenderer_renderAnnot(void* imarg1, void* imarg2, void* imarg3)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FSAnnot *arg2 = (FSAnnot *) 0 ;
  FSMatrix *arg3 = 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSRenderer *)imarg1;
  arg2 = (FSAnnot *)imarg2;
  arg3 = (FSMatrix *)imarg3;
    FSMatrix mat;
    if (!arg3) {
        mat.set(1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);
        arg3 = &mat;
    }

  result = (FS_BOOL)(arg1)->renderAnnot(arg2,(FSMatrix const &)*arg3);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_FSRenderer_setRenderContent(void* imarg1, unsigned int imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_DWORD arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = (FS_DWORD)imarg2; 
  (arg1)->setRenderContent(arg2);
}

void _wrap_FSRenderer_setTransformAnnotIcon(void* imarg1, BOOL imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setTransformAnnotIcon(arg2);
}

void _wrap_FSRenderer_setColorMode(void* imarg1, int imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_RENDERCOLORMODE arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = (FS_RENDERCOLORMODE)imarg2; 
  (arg1)->setColorMode(arg2);
}

void _wrap_FSRenderer_setMappingModeColors(void* imarg1, unsigned int imarg2, unsigned int imarg3)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_ARGB arg2 ;
  FS_ARGB arg3 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = (FS_ARGB)imarg2; 
  arg3 = (FS_ARGB)imarg3; 
  (arg1)->setMappingModeColors(arg2,arg3);
}

void _wrap_FSRenderer_setClearType(void* imarg1, BOOL imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setClearType(arg2);
}

void _wrap_FSRenderer_setPrintGraphicText(void* imarg1, BOOL imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setPrintGraphicText(arg2);
}

void _wrap_FSRenderer_setForceDownSample(void* imarg1, BOOL imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setForceDownSample(arg2);
}

void _wrap_FSRenderer_setForceHalftone(void* imarg1, BOOL imarg2)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  FS_BOOL arg2 ;
  
  arg1 = (FSRenderer *)imarg1; 
  arg2 = imarg2? true : false; 
  (arg1)->setForceHalftone(arg2);
}

void _wrap_delete_FSRenderer(void* imarg1)
{
  FSRenderer *arg1 = (FSRenderer *) 0 ;
  
  arg1 = (FSRenderer *)imarg1; 
  delete arg1;
}


void* _wrap_FSPDFTextSearch_create(void* imarg1, FSPauseCallback* imarg2)
{
  FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
  FSPause *arg2 = (FSPause *) 0 ;
  void* imresult = 0 ;
  FSPDFTextSearch *result = 0 ;
  
  arg1 = (FSPDFDoc *)imarg1;
    if (imarg2)
    {
        gFSPause = imarg2;
        arg2 = &gFSPause;
    }
  result = (FSPDFTextSearch *)FSPDFTextSearch::create(arg1,arg2);
  imresult = (void*)result; 
  return imresult;
}

BOOL _wrap_FSPDFTextSearch_setKeyWords(void* imarg1, NSString * imarg2)
{
    FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
    char const *arg2 = (char const *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSPDFTextSearch *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    result = (FS_BOOL)(arg1)->setKeyWords((char const *)arg2);
    imresult = (result)? YES:NO; 
    return imresult;
}

BOOL _wrap_FSPDFTextSearch_setStartPage(void* imarg1, int imarg2)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  FS_INT32 arg2 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  arg2 = (FS_INT32)imarg2;
  result = (FS_BOOL)(arg1)->setStartPage(arg2);
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSPDFTextSearch_setFlag(void* imarg1, unsigned int imarg2)
{
    FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
    FS_DWORD arg2 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSPDFTextSearch *)imarg1;
    arg2 = (FS_DWORD)imarg2;
    result = (FS_BOOL)(arg1)->setFlag(arg2);
    imresult = (result)? YES:NO; 
    return imresult;
}

BOOL _wrap_FSPDFTextSearch_findNext(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_BOOL)(arg1)->findNext();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_FSPDFTextSearch_findPrev(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_BOOL)(arg1)->findPrev();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSPDFTextSearch_getMatchRectCount(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_INT32)(arg1)->getMatchRectCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFTextSearch_getMatchRect(void* imarg1, int imarg2)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = ((FSPDFTextSearch const *)arg1)->getMatchRect(arg2);
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

int _wrap_FSPDFTextSearch_getMatchPageIndex(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_INT32)((FSPDFTextSearch const *)arg1)->getMatchPageIndex();
  imresult = result; 
  return imresult;
}

NSString * _wrap_FSPDFTextSearch_getMatchSentence(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (arg1)->getMatchSentence();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

int _wrap_FSPDFTextSearch_getMatchSentenceStartIndex(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_INT32)(arg1)->getMatchSentenceStartIndex();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFTextSearch_getMatchStartCharIndex(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_INT32)((FSPDFTextSearch const *)arg1)->getMatchStartCharIndex();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFTextSearch_getMatchEndCharIndex(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  result = (FS_INT32)((FSPDFTextSearch const *)arg1)->getMatchEndCharIndex();
  imresult = result; 
  return imresult;
}

void _wrap_delete_FSPDFTextSearch(void* imarg1)
{
  FSPDFTextSearch *arg1 = (FSPDFTextSearch *) 0 ;
  
  arg1 = (FSPDFTextSearch *)imarg1; 
  delete arg1;
}

void* _wrap_FSPDFTextSelect_create(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSPDFTextSelect *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  result = (FSPDFTextSelect *)FSPDFTextSelect::create(arg1);
  imresult = (void*)result; 
  return imresult;
}

void* _wrap_FSPDFTextSelect_getPage(void* imarg1)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  void* imresult = 0 ;
  FSPDFPage *result = 0 ;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  result = (FSPDFPage *)((FSPDFTextSelect const *)arg1)->getPage();
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSPDFTextSelect_getCharCount(void* imarg1)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  result = (FS_INT32)((FSPDFTextSelect const *)arg1)->getCharCount();
  imresult = result; 
  return imresult;
}

NSString * _wrap_FSPDFTextSelect_getChars(void* imarg1, int imarg2, int imarg3)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_INT32 arg2 ;
  FS_INT32 arg3 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_INT32)imarg3; 
  result = ((FSPDFTextSelect const *)arg1)->getChars(arg2,arg3);
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

int _wrap_FSPDFTextSelect_getIndexAtPos(void* imarg1, float imarg2, float imarg3, float imarg4)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  result = (FS_INT32)((FSPDFTextSelect const *)arg1)->getIndexAtPos(arg2,arg3,arg4);
  imresult = result; 
  return imresult;
}

NSString * _wrap_FSPDFTextSelect_getTextInRect(void* imarg1, void* imarg2)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FSRectF arg2 ;
  NSString * imresult = 0 ;
  FSRectF *argp2 ;
  FSString result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  
  argp2 = (FSRectF *)imarg2;
    if (!argp2)
        return nil;
  arg2 = *argp2; 
  
  result = ((FSPDFTextSelect const *)arg1)->getTextInRect(arg2);
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

BOOL _wrap_FSPDFTextSelect_getWordAtPos(void* imarg1, float imarg2, float imarg3, float imarg4, int * imarg5, int * imarg6)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_FLOAT arg2 ;
  FS_FLOAT arg3 ;
  FS_FLOAT arg4 ;
  FS_INT32 *arg5 = 0 ;
  FS_INT32 *arg6 = 0 ;
  BOOL imresult = 0 ;
  FS_BOOL result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_FLOAT)imarg2; 
  arg3 = (FS_FLOAT)imarg3; 
  arg4 = (FS_FLOAT)imarg4; 
  arg5 = (FS_INT32 *)imarg5; 
  arg6 = (FS_INT32 *)imarg6; 
  result = (FS_BOOL)((FSPDFTextSelect const *)arg1)->getWordAtPos(arg2,arg3,arg4,*arg5,*arg6);
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_FSPDFTextSelect_getTextRectCount(void* imarg1, int imarg2, int imarg3)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_INT32 arg2 ;
  FS_INT32 arg3 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  arg3 = (FS_INT32)imarg3; 
  result = (FS_INT32)(arg1)->getTextRectCount(arg2,arg3);
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFTextSelect_getTextRect(void* imarg1, int imarg2)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = ((FSPDFTextSelect const *)arg1)->getTextRect(arg2);
  
    float epsilon = 10e-5;
    if (result.left < epsilon &&
        result.right < epsilon &&
        result.top < epsilon &&
        result.bottom < epsilon) {
        return NULL;
    }
    
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

int _wrap_FSPDFTextSelect_getBaselineRotation(void* imarg1, int imarg2)
{
  FSPDFTextSelect *arg1 = (FSPDFTextSelect *) 0 ;
  FS_INT32 arg2 ;
  int imresult = 0 ;
  FS_ROTATION result;
  
  arg1 = (FSPDFTextSelect *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FS_ROTATION)(arg1)->getBaselineRotation(arg2);
  imresult = (int)result; 
  return imresult;
}

void _wrap_delete_FSPDFTextSelect(void* imarg1)
{
    if(!imarg1) return;
  
  ((FSPDFTextSelect *)imarg1)->release();
}

void _wrap_delete_FSPDFTextLink(void* imarg1)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  delete arg1;
}

NSString * _wrap_FSPDFTextLink_getURI(void* imarg1)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  NSString * imresult = 0 ;
  FSString result;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  result = (arg1)->getURI();
  {
    if (0 < (result).getBufferLen()) {
      imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
    }
  }
  return imresult;
}

int _wrap_FSPDFTextLink_getStartCharIndex(void* imarg1)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  result = (FS_INT32)(arg1)->getStartCharIndex();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFTextLink_getEndCharIndex(void* imarg1)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  result = (FS_INT32)(arg1)->getEndCharIndex();
  imresult = result; 
  return imresult;
}

int _wrap_FSPDFTextLink_getRectCount(void* imarg1)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  result = (FS_INT32)(arg1)->getRectCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFTextLink_getRect(void* imarg1, int imarg2)
{
  FSPDFTextLink *arg1 = (FSPDFTextLink *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSRectF *temp ;
  FSRectF result;
  
  arg1 = (FSPDFTextLink *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (arg1)->getRect(arg2);
  
  temp = new FSRectF((const FSRectF &)result); 
  imresult = (void*)temp;
  
  return imresult;
}

void* _wrap_FSPDFPageLinks_create(void* imarg1)
{
  FSPDFPage *arg1 = (FSPDFPage *) 0 ;
  void* imresult = 0 ;
  FSPDFPageLinks *result = 0 ;
  
  arg1 = (FSPDFPage *)imarg1; 
  result = (FSPDFPageLinks *)FSPDFPageLinks::create(arg1);
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSPDFPageLinks_getTextLinkCount(void* imarg1)
{
  FSPDFPageLinks *arg1 = (FSPDFPageLinks *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFPageLinks *)imarg1; 
  result = (FS_INT32)(arg1)->getTextLinkCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFPageLinks_getTextLink(void* imarg1, int imarg2)
{
  FSPDFPageLinks *arg1 = (FSPDFPageLinks *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSPDFTextLink *result = 0 ;
  
  arg1 = (FSPDFPageLinks *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FSPDFTextLink *)(arg1)->getTextLink(arg2);
  imresult = (void*)result; 
  return imresult;
}

int _wrap_FSPDFPageLinks_getLinkAnnotCount(void* imarg1)
{
  FSPDFPageLinks *arg1 = (FSPDFPageLinks *) 0 ;
  int imresult = 0 ;
  FS_INT32 result;
  
  arg1 = (FSPDFPageLinks *)imarg1; 
  result = (FS_INT32)(arg1)->getLinkAnnotCount();
  imresult = result; 
  return imresult;
}

void* _wrap_FSPDFPageLinks_getLinkAnnot(void* imarg1, int imarg2)
{
  FSPDFPageLinks *arg1 = (FSPDFPageLinks *) 0 ;
  FS_INT32 arg2 ;
  void* imresult = 0 ;
  FSLink *result = 0 ;
  
  arg1 = (FSPDFPageLinks *)imarg1; 
  arg2 = (FS_INT32)imarg2; 
  result = (FSLink *)(arg1)->getLinkAnnot(arg2);
  imresult = (void*)result; 
  return imresult;
}

void _wrap_delete_FSPDFPageLinks(void* imarg1)
{
  FSPDFPageLinks *arg1 = (FSPDFPageLinks *) 0 ;
  
  arg1 = (FSPDFPageLinks *)imarg1; 
  delete arg1;
}


int _wrap_FSForm_getFieldCount(void* imarg1, NSString * imarg2)
{
    FSForm *arg1 = (FSForm *) 0 ;
    char *arg2 = (char *) 0 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSForm *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    result = (FS_INT32)((FSForm const *)arg1)->getFieldCount((char const *)arg2);
    imresult = result;
    return imresult;
}

void* _wrap_FSForm_getField(void* imarg1, NSString * imarg2, int imarg3)
{
    FSForm *arg1 = (FSForm *) 0 ;
    char const *arg2 = (char const *) 0 ;
    FS_INT32 arg3 ;
    void* imresult = 0 ;
    FSFormField *result = 0 ;
    
    arg1 = (FSForm *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    arg3 = (FS_INT32)imarg3;
    result = (FSFormField *)(arg1)->getField((char const *)arg2,arg3);
    imresult = (void*)result;
    return imresult;
}

void* _wrap_FSForm_getFormFiller(void* imarg1)
{
    FSForm *arg1 = (FSForm *) 0 ;
    void* imresult = 0 ;
    FSFormFiller *result = 0;
    
    arg1 = (FSForm *)imarg1;
    result = (FSFormFiller *)((FSForm const *)arg1)->getFormFiller();
    imresult = (void*)result;
    return imresult;
}

BOOL _wrap_FSForm_reset(void* imarg1)
{
    FSForm *arg1 = (FSForm *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSForm *)imarg1;
    result = (FS_BOOL)(arg1)->reset();
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSForm_exportToXML(void* imarg1, NSString * imarg2)
{
    FSForm *arg1 = (FSForm *) 0 ;
    char const *arg2 = (char const *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSForm *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    result = (FS_BOOL)(arg1)->exportToXML((char const *)arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSForm_importFromXML(void* imarg1, NSString * imarg2)
{
    FSForm *arg1 = (FSForm *) 0 ;
    char const *arg2 = (char const *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSForm *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = [imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    result = (FS_BOOL)(arg1)->importFromXML((char const *)arg2);
    imresult = (result)? YES:NO; 
    return imresult;
}

void _wrap_delete_FSForm(void* imarg1)
{
    FSForm *arg1 = (FSForm *) 0 ;
    
    arg1 = (FSForm *)imarg1;
    delete arg1;
}

int _wrap_FSFormField_getType(void* imarg1)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    int imresult = 0 ;
    FSFormField::FS_FORMFIELDTYPE result;
    
    arg1 = (FSFormField *)imarg1;
    result = (FSFormField::FS_FORMFIELDTYPE)((FSFormField const *)arg1)->getType();
    imresult = (int)result;
    return imresult;
}
    
int _wrap_FSFormField_getFlags(void* imarg1)
{
    FSFormField* arg1 = (FSFormField *) 0;
    int imresult = 0;
    FSFormField::FS_FORMFIELDFLAGS result;
    
    arg1 = (FSFormField*)imarg1;
    result = (FSFormField::FS_FORMFIELDFLAGS)((FSFormField const*)arg1)->getFlags();
    imresult = (int)result;
    return imresult;
    
}

NSString * _wrap_FSFormField_getName(void* imarg1)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFormField *)imarg1;
    result = ((FSFormField const *)arg1)->getName();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

NSString * _wrap_FSFormField_getDefaultValue(void* imarg1)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFormField *)imarg1;
    result = ((FSFormField const *)arg1)->getDefaultValue();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

NSString * _wrap_FSFormField_getValue(void* imarg1)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFormField *)imarg1;
    result = ((FSFormField const *)arg1)->getValue();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

int _wrap_FSFormField_getControlCount(void* imarg1, void* imarg2)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    FSPDFPage *arg2 = (FSPDFPage *) 0 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSFormField *)imarg1;
    arg2 = (FSPDFPage *)imarg2;
    result = (FS_INT32)((FSFormField const *)arg1)->getControlCount(arg2);
    imresult = result;
    return imresult;
}

void* _wrap_FSFormField_getControl(void* imarg1, void* imarg2, int imarg3)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    FSPDFPage *arg2 = (FSPDFPage *) 0 ;
    FS_INT32 arg3 ;
    void* imresult = 0 ;
    FSFormControl *result = 0 ;
    
    arg1 = (FSFormField *)imarg1;
    arg2 = (FSPDFPage *)imarg2;
    arg3 = (FS_INT32)imarg3;
    result = (FSFormControl *)(arg1)->getControl(arg2,arg3);
    imresult = (void*)result;
    return imresult;
}

void _wrap_delete_FSFormField(void* imarg1)
{
    FSFormField *arg1 = (FSFormField *) 0 ;
    
    arg1 = (FSFormField *)imarg1;
    delete arg1;
}

void* _wrap_FSFormControl_getField(void* imarg1)
{
    FSFormControl *arg1 = (FSFormControl *) 0 ;
    void* imresult = 0 ;
    FSFormField *result = 0 ;
    
    arg1 = (FSFormControl *)imarg1;
    result = (FSFormField *)(arg1)->getField();
    imresult = (void*)result;
    return imresult;
}

void _wrap_delete_FSFormControl(void* imarg1)
{
    FSFormControl *arg1 = (FSFormControl *) 0 ;
    
    arg1 = (FSFormControl *)imarg1;
    delete arg1;
}

class FSFormFillerAssistImpl: public FSFormFillerAssist
{
public:
    FSFormFillerAssistImpl(id obj) {m_obj = obj;}

    virtual void release() {
        delete this;
    }
    
    virtual	void refresh(FSPDFPage* page, FSRectF* pdfRect)
    {
        FSFormFillerAssist_refresh(m_obj, page, pdfRect);
    }

    virtual FS_BOOL	setTimer(FS_INT32 elapse, FS_CALLBACK_TIMER timerFunc, FS_INT32* timerID)
    {
        return [m_obj setTimer:elapse timerFunc:timerFunc timerID:timerID];
    }

    virtual FS_BOOL	killTimer(FS_INT32 timerID)
    {
        return [m_obj killTimer:timerID];
    }

    virtual void focusGotOnControl(FSFormControl* control, const char* fieldValue)
    {
        FSFormFillerAssist_focusGotOnControl(m_obj, control, fieldValue);
    }

    virtual void focusLostFromControl(FSFormControl* control, const char* fieldValue)
    {
        FSFormFillerAssist_focusLostFromControl(m_obj, control, fieldValue);
    }
    
protected:
    id m_obj;
};
    
void* _wrap_FSFormFillerAssist_init(id obj)
{
    return new FSFormFillerAssistImpl(obj);
}

void _wrap_delete_FSFormFillerAssist(void* imarg1)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    delete arg1;
}

int _wrap_FSFormFillerAssist_getVersion(void* imarg1)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    int imresult = 0 ;
    int result;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    result = (int)(arg1)->getVersion();
    imresult = result;
    return imresult;
}

void _wrap_FSFormFillerAssist_refresh(void* imarg1, void* imarg2, void* imarg3)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    FSPDFPage *arg2 = (FSPDFPage *) 0 ;
    FSRectF *arg3 = (FSRectF *) 0 ;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    arg2 = (FSPDFPage *)imarg2;
    arg3 = (FSRectF *)imarg3;
    (arg1)->refresh(arg2,arg3);
}

BOOL _wrap_FSFormFillerAssist_setTimer(void* imarg1, int imarg2, FS_CALLBACK_TIMER imarg3, int * imarg4)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    FS_INT32 arg2 ;
    FS_CALLBACK_TIMER arg3 = (FS_CALLBACK_TIMER) 0 ;
    FS_INT32 *arg4 = (FS_INT32 *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    arg2 = (FS_INT32)imarg2;
    arg3 = (FS_CALLBACK_TIMER)imarg3;
    arg4 = (FS_INT32 *)imarg4;
    result = (FS_BOOL)(arg1)->setTimer(arg2,arg3,arg4);
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSFormFillerAssist_killTimer(void* imarg1, int imarg2)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    FS_INT32 arg2 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    arg2 = (FS_INT32)imarg2;
    result = (FS_BOOL)(arg1)->killTimer(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

void _wrap_FSFormFillerAssist_focusGotOnControl(void* imarg1, void* imarg2, NSString * imarg3)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    FSFormControl *arg2 = (FSFormControl *) 0 ;
    char const *arg3 = (char *) 0 ;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    arg2 = (FSFormControl *)imarg2;
    {
        arg3 = 0;
        if (imarg3) {
            arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->focusGotOnControl(arg2,(char const *)arg3);
}

void _wrap_FSFormFillerAssist_focusLostFromControl(void* imarg1, void* imarg2, NSString * imarg3)
{
    FSFormFillerAssist *arg1 = (FSFormFillerAssist *) 0 ;
    FSFormControl *arg2 = (FSFormControl *) 0 ;
    char const *arg3 = (char *) 0 ;
    
    arg1 = (FSFormFillerAssist *)imarg1;
    arg2 = (FSFormControl *)imarg2;
    {
        arg3 = 0;
        if (imarg3) {
            arg3 = [imarg3 cStringUsingEncoding:NSUTF8StringEncoding];        }
    }
    (arg1)->focusLostFromControl(arg2,(char const *)arg3);
}

void _wrap_FSIdentityProperties_set(void* imarg1, NSString * imarg2, NSString * imarg3, NSString * imarg4, NSString * imarg5)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    {
        arg3 = 0;
        if (imarg3) {
            arg3 = (char *)[imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    {
        arg4 = 0;
        if (imarg4) {
            arg4 = (char *)[imarg4 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    {
        arg5 = 0;
        if (imarg5) {
            arg5 = (char *)[imarg5 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->set((char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
}

void _wrap_FSIdentityProperties_corporation_set(void* imarg1, NSString * imarg2)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    FSString *arg2 = (FSString *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            const char* temp = [imarg2 UTF8String];
            arg2 = new FSString(temp);
        }
    }
    if (arg1) (arg1)->corporation = *arg2;
}

NSString * _wrap_FSIdentityProperties_corporation_get(void* imarg1)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    NSString * imresult = 0 ;
    FSString *result = 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    result = (FSString *)& ((arg1)->corporation);
    {
        if (result && 0 < result->getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSIdentityProperties_email_set(void* imarg1, NSString * imarg2)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    FSString *arg2 = (FSString *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            const char* temp = [imarg2 UTF8String];
            arg2 = new FSString(temp);
        }
    }
    if (arg1) (arg1)->email = *arg2;
}

NSString * _wrap_FSIdentityProperties_email_get(void* imarg1)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    NSString * imresult = 0 ;
    FSString *result = 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    result = (FSString *)& ((arg1)->email);
    {
        if (result && 0 < result->getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSIdentityProperties_loginName_set(void* imarg1, NSString * imarg2)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    FSString *arg2 = (FSString *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            const char* temp = [imarg2 UTF8String];
            arg2 = new FSString(temp);
        }
    }
    if (arg1) (arg1)->loginName = *arg2;
}

NSString * _wrap_FSIdentityProperties_loginName_get(void* imarg1)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    NSString * imresult = 0 ;
    FSString *result = 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    result = (FSString *)& ((arg1)->loginName);
    {
        if (result && 0 < result->getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSIdentityProperties_name_set(void* imarg1, NSString * imarg2)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    FSString *arg2 = (FSString *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            const char* temp = [imarg2 UTF8String];
            arg2 = new FSString(temp);
        }
    }
    if (arg1) (arg1)->name = *arg2;
}

NSString * _wrap_FSIdentityProperties_name_get(void* imarg1)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    NSString * imresult = 0 ;
    FSString *result = 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    result = (FSString *)& ((arg1)->name);
    {
        if (result && 0 < result->getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)(result->getBuffer())];
        }
    }
    return imresult;
}

void* _wrap_new_FSIdentityProperties()
{
    void* imresult = 0 ;
    _FSIdentityProperties *result = 0 ;
    
    result = (_FSIdentityProperties *)new _FSIdentityProperties();
    imresult = (void*)result;
    return imresult;
}

void _wrap_delete_FSIdentityProperties(void* imarg1)
{
    _FSIdentityProperties *arg1 = (_FSIdentityProperties *) 0 ;
    
    arg1 = (_FSIdentityProperties *)imarg1;
    delete arg1;
}

void* _wrap_FSActionHandler_init(id obj)
{
    return new FSActionHandlerImp(obj);
}

void _wrap_delete_FSActionHandler(void* imarg1)
{
    FSActionHandlerImp *arg1 = (FSActionHandlerImp *) 0 ;
    
    arg1 = (FSActionHandlerImp *)imarg1;
    delete arg1;
}

int _wrap_FSActionHandler_getCurrentPage(void* imarg1, void* imarg2)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSActionHandler *)imarg1;
    FSPDFDoc* pdfDoc = (FSPDFDoc*)imarg2;
    result = (FS_INT32)(arg1)->getCurrentPage(pdfDoc);
    imresult = result;
    return imresult;
}

void _wrap_FSActionHandler_setCurrentPage(void* imarg1, void* imarg2, int imarg3)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    FSPDFDoc* arg2 = (FSPDFDoc*)0;
    FS_INT32 arg3 ;
    
    arg1 = (FSActionHandler *)imarg1;
    arg2 = (FSPDFDoc*)imarg2;
    arg3 = (FS_INT32)imarg3;
    (arg1)->setCurrentPage(arg2, arg3);
}

int _wrap_FSActionHandler_getPageRotation(void* imarg1, void* imarg2, int imarg3)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    FSPDFDoc* arg2 = (FSPDFDoc*)0;
    FS_INT32 arg3 ;
    int imresult = 0 ;
    FS_ROTATION result;
    
    arg1 = (FSActionHandler *)imarg1;
    arg2 = (FSPDFDoc*)imarg2;
    arg3 = (FS_INT32)imarg3;
    result = (FS_ROTATION)(arg1)->getPageRotation(arg2, arg3);
    imresult = (int)result;
    return imresult;
}

BOOL _wrap_FSActionHandler_setPageRotation(void* imarg1, void* imarg2, int imarg3, int imarg4)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    FSPDFDoc* arg2 = (FSPDFDoc*)0;
    
    arg1 = (FSActionHandler *)imarg1;
    arg2 = (FSPDFDoc*)imarg2;
    return arg1->setPageRotation(arg2, imarg3, (FS_ROTATION)imarg4);
}

int _wrap_FSActionHandler_alert(void* imarg1, NSString * imarg2, NSString * imarg3, int imarg4, int imarg5)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    FS_INT32 arg4 ;
    FS_INT32 arg5 ;
    int imresult = 0 ;
    FS_INT32 result;
    
    arg1 = (FSActionHandler *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    {
        arg3 = 0;
        if (imarg3) {
            arg3 = (char *)[imarg3 cStringUsingEncoding:NSUTF8StringEncoding];        }
    }
    arg4 = (FS_INT32)imarg4; 
    arg5 = (FS_INT32)imarg5; 
    result = (FS_INT32)(arg1)->alert((char const *)arg2,(char const *)arg3,arg4,arg5);
    imresult = result; 
    return imresult;
}

void* _wrap_FSActionHandler_getIdentityProperties(void* imarg1)
{
    FSActionHandler *arg1 = (FSActionHandler *) 0 ;
    void* imresult = 0 ;
    FSIdentityProperties *temp ;
    FSIdentityProperties result;
    
    arg1 = (FSActionHandler *)imarg1;
    result = (arg1)->getIdentityProperties();
    
    temp = new FSIdentityProperties((const FSIdentityProperties &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void* _wrap_FSFormFiller_create(void* imarg1, void* imarg2)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg1);
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    FSForm *arg1 = (FSForm *) 0 ;
    FSFormFillerAssist *arg2 = (FSFormFillerAssist *) 0 ;
    void* imresult = 0 ;
    FSFormFiller *result = 0 ;
    
    arg1 = (FSForm *)imarg1; 
    arg2 = (FSFormFillerAssist *)imarg2; 
    result = (FSFormFiller *)FSFormFiller::create(arg1,arg2);
    imresult = (void*)result; 
    return imresult;
}

void _wrap_delete_FSFormFiller(void* imarg1)
{
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    
    arg1 = (FSFormFiller *)imarg1; 
    delete arg1;
}

void _wrap_FSFormFiller_render(void* imarg1, void* imarg2, void* imarg3, void* imrg4)
{
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    THROWEXCEPTION_IF_NULLPOINTER(imrg4);
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    FSPDFPage *arg2 = (FSPDFPage *) 0 ;
    FSMatrix* arg3 = (FSMatrix*)0;
    FSRenderer *arg4 = (FSRenderer *) 0 ;
    
    arg1 = (FSFormFiller *)imarg1;
    arg2 = (FSPDFPage *)imarg2;
    arg3 = (FSMatrix *)imarg3;
    arg3 = (FSMatrix *)imarg3;
    FSMatrix mat;
    if (!arg3) {
        mat.set(1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);
        arg3 = &mat;
    }
    
    arg4 = (FSRenderer*)imrg4;
    
    (arg1)->render(arg2, *arg3, arg4);
}

BOOL _wrap_FSFormFiller_tap(void* imarg1, void* imarg2, void* imarg3)
{
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    FSPDFPage *arg2 = (FSPDFPage *) 0 ;
    FSPointF *arg3 = (FSPointF *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFormFiller *)imarg1; 
    arg2 = (FSPDFPage *)imarg2; 
    arg3 = (FSPointF *)imarg3; 
    result = (FS_BOOL)(arg1)->onLButtonDown(arg2,arg3,0);
    if (!result)
        return result;
    result = (FS_BOOL)(arg1)->onLButtonUp(arg2,arg3,0);
    imresult = (result)? YES:NO; 
    return imresult;
}

BOOL _wrap_FSFormFiller_input(void* imarg1, unsigned int imarg2)
{
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    FS_DWORD arg2 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFormFiller *)imarg1; 
    arg2 = (FS_DWORD)imarg2;
    result = (FS_BOOL)(arg1)->onChar(arg2,0);
    imresult = (result)? YES:NO; 
    return imresult;
}

void _wrap_FSFormFiller_highlightFormFields(void* imarg1, BOOL imarg2)
{
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    FS_BOOL arg2 ;
    
    arg1 = (FSFormFiller *)imarg1; 
    arg2 = imarg2? true : false; 
    (arg1)->highlightFormFields(arg2);
}

void _wrap_FSFormFiller_setHighlightColor(void* imarg1, unsigned int imarg2)
{
    FSFormFiller *arg1 = (FSFormFiller *) 0 ;
    FS_ARGB arg2 ;
    
    arg1 = (FSFormFiller *)imarg1; 
    arg2 = (FS_ARGB)imarg2; 
    (arg1)->setHighlightColor(arg2);
}

void _wrap_delete_FSFileSpec(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    
    arg1 = (FSFileSpec *)imarg1;
    delete arg1;
}

void* _wrap_FSFileSpec_create(void* imarg1)
{
    FSPDFDoc *arg1 = (FSPDFDoc *) 0 ;
    void* imresult = 0 ;
    FSFileSpec *result = 0 ;
    
    arg1 = (FSPDFDoc *)imarg1;
    result = (FSFileSpec *)FSFileSpec::create(arg1);
    imresult = (void*)result;
    return imresult;
}

NSString * _wrap_FSFileSpec_getFileName(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (arg1)->getFileName();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSFileSpec_setFileName(void* imarg1, NSString * imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    char *arg2 = (char *) 0 ;
    
    arg1 = (FSFileSpec *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setFileName((char const *)arg2);
}

long long _wrap_FSFileSpec_getFileSize(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    long long imresult = 0 ;
    FS_INT64 result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (FS_INT64)(arg1)->getFileSize();
    imresult = result;
    return imresult;
}

void* _wrap_FSFileSpec_getFileData(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    void* imresult = 0 ;
    FSFileRead *result = 0 ;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (FSFileRead *)(arg1)->getFileData();
    imresult = (void*)result;
    return imresult;
}

BOOL _wrap_FSFileSpec_embed(void* imarg1, NSString * imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    char *arg2 = (char *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFileSpec *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];        }
    }
    result = (FS_BOOL)(arg1)->embed((char const *)arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSFileSpec_isEmbedded(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (FS_BOOL)(arg1)->isEmbedded();
    imresult = (result)? YES:NO;
    return imresult;
}

NSString * _wrap_FSFileSpec_getDescription(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (arg1)->getDescription();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSFileSpec_setDescription(void* imarg1, NSString * imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    char *arg2 = (char *) 0 ;
    
    arg1 = (FSFileSpec *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setDescription((char const *)arg2);
}

void* _wrap_FSFileSpec_getCreationDateTime(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    void* imresult = 0 ;
    FSDateTime *temp ;
    FSDateTime result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (arg1)->getCreationDateTime();
    
    temp = new FSDateTime((const FSDateTime &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSFileSpec_setCreationDateTime(void* imarg1, void* imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    FSDateTime *arg2 = (FSDateTime *) 0 ;
    
    arg1 = (FSFileSpec *)imarg1;
    arg2 = (FSDateTime *)imarg2;
    (arg1)->setCreationDateTime((FSDateTime const *)arg2);
}

void* _wrap_FSFileSpec_getModifiedDateTime(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    void* imresult = 0 ;
    FSDateTime *temp ;
    FSDateTime result;
    
    arg1 = (FSFileSpec *)imarg1;
    result = (arg1)->getModifiedDateTime();
    
    temp = new FSDateTime((const FSDateTime &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSFileSpec_setModifiedDateTime(void* imarg1, void* imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    FSDateTime *arg2 = (FSDateTime *) 0 ;
    
    arg1 = (FSFileSpec *)imarg1; 
    arg2 = (FSDateTime *)imarg2; 
    (arg1)->setModifiedDateTime((FSDateTime const *)arg2);
}

NSData * _wrap_FSFileSpec_getChecksum(void* imarg1)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    NSData * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFileSpec *)imarg1; 
    result = (arg1)->getChecksum();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSData dataWithBytes:result.getBuffer() length:result.getBufferLen()];
        }
    }
    return imresult;
}

void _wrap_FSFileSpec_setChecksum(void* imarg1, NSData * imarg2)
{
    FSFileSpec *arg1 = (FSFileSpec *) 0 ;
    char *arg2 = (char *) 0 ;
    void* buff = NULL;
    
    arg1 = (FSFileSpec *)imarg1; 
    {
        arg2 = 0;
        if (imarg2) {
            int buflen = [imarg2 length];
            buff = malloc(buflen + 1);
            ((char*)buff)[buflen] = 0;
            [imarg2 getBytes:buff length:buflen];
            arg2 = (char *)buff;
        }
    }
    (arg1)->setChecksum((char const *)arg2);
    free(arg2);
}

void _wrap_delete_FSFileAttachment(void* imarg1)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    
    arg1 = (FSFileAttachment *)imarg1;
    delete arg1;
}

BOOL _wrap_FSFileAttachment_resetAppearanceStream(void* imarg1)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFileAttachment *)imarg1;
    result = (FS_BOOL)(arg1)->resetAppearanceStream();
    imresult = (result)? YES:NO;
    return imresult;
}

BOOL _wrap_FSFileAttachment_setFileSpec(void* imarg1, void* imarg2)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    FSFileSpec *arg2 = (FSFileSpec *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSFileAttachment *)imarg1;
    arg2 = (FSFileSpec *)imarg2;
    result = (FS_BOOL)(arg1)->setFileSpec(arg2);
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSFileAttachment_getFileSpec(void* imarg1)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    void* imresult = 0 ;
    FSFileSpec *result = 0 ;
    
    arg1 = (FSFileAttachment *)imarg1;
    result = (FSFileSpec *)(arg1)->getFileSpec();
    imresult = (void*)result;
    return imresult;
}

NSString * _wrap_FSFileAttachment_getIconName(void* imarg1)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSFileAttachment *)imarg1;
    result = ((FSFileAttachment const *)arg1)->getIconName();
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSFileAttachment_setIconName(void* imarg1, NSString * imarg2)
{
    FSFileAttachment *arg1 = (FSFileAttachment *) 0 ;
    char *arg2 = (char *) 0 ;
    
    arg1 = (FSFileAttachment *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setIconName((char const *)arg2);
}

BOOL _wrap_FSSignature_isSigned(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_BOOL)(arg1)->isSigned();
    imresult = (result)? YES:NO;
    return imresult;
}

int _wrap_FSSignature_startSign(void* imarg1, NSString * imarg2, NSString* imarg3, NSString* imarg4, int imarg5, void* imarg6, void* imarg7)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    char *arg2 = (char *) 0 ;
    int imresult = 0 ;
    FS_PROGRESSSTATE result;
    
    arg1 = (FSSignature *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    char* arg3 = 0;
    if (imarg3) {
        arg3 = (char *)[imarg3 cStringUsingEncoding:NSUTF8StringEncoding];
    }
    char* arg4 = 0;
    if (imarg4) {
        arg4 = (char *)[imarg4 cStringUsingEncoding:NSUTF8StringEncoding];
    }
    int arg5 = imarg5;
    FSPause* arg6 = (FSPause *)imarg6;
    void* clientData = imarg7;
    result = (FS_PROGRESSSTATE)(arg1)->startSign((char const *)arg2, (const char*)arg3, (const char*)arg4, (int)[imarg4 length],(FS_DIGEST_ALGORITHM)arg5, (FSPause*)arg6, (void*)clientData);
    imresult = (int)result;
    return imresult;
}

int _wrap_FSSignature_continueSign(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    int imresult = 0 ;
    FS_PROGRESSSTATE result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_PROGRESSSTATE)(arg1)->continueSign();
    imresult = (int)result;
    return imresult;
}

int _wrap_FSSignature_startVerify(void* imarg1, void* imarg2, void* imrg3)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FSPause *arg2 = (FSPause *) 0 ;
    int imresult = 0 ;
    FS_PROGRESSSTATE result;
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (FSPause *)imarg2;
    result = (FS_PROGRESSSTATE)(arg1)->startVerify(arg2, imrg3);
    imresult = (int)result;
    return imresult;
}

int _wrap_FSSignature_continueVerify(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    int imresult = 0 ;
    FS_PROGRESSSTATE result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_PROGRESSSTATE)(arg1)->continueVerify();
    imresult = (int)result;
    return imresult;
}

unsigned int _wrap_FSSignature_getState(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    unsigned int imresult = 0 ;
    FS_DWORD result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_DWORD)(arg1)->getState();
    imresult = result;
    return imresult;
}

BOOL _wrap_FSSignature_clearSignedData(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    BOOL imresult = 0 ;
    FS_BOOL result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_BOOL)(arg1)->clearSignedData();
    imresult = (result)? YES:NO;
    return imresult;
}

void* _wrap_FSSignature_getDocument(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    void* imresult = 0 ;
    FSPDFDoc *result = 0 ;
    
    arg1 = (FSSignature *)imarg1;
    result = (FSPDFDoc *)(arg1)->getDocument();
    imresult = (void*)result;
    return imresult;
}

unsigned int _wrap_FSSignature_getAppearanceFlags(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    unsigned int imresult = 0 ;
    FS_DWORD result;
    
    arg1 = (FSSignature *)imarg1;
    result = (FS_DWORD)(arg1)->getAppearanceFlags();
    imresult = result;
    return imresult;
}

void _wrap_FSSignature_setAppearanceFlags(void* imarg1, unsigned int imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FS_DWORD arg2 ;
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (FS_DWORD)imarg2;
    (arg1)->setAppearanceFlags(arg2);
}

void* _wrap_FSSignature_getSigningTime(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    void* imresult = 0 ;
    FSDateTime *temp ;
    FSDateTime result;
    
    arg1 = (FSSignature *)imarg1;
    result = (arg1)->getSigningTime();
    
    temp = new FSDateTime((const FSDateTime &)result);
    imresult = (void*)temp;
    
    return imresult;
}

void _wrap_FSSignature_setSigningTime(void* imarg1, void* imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FSDateTime arg2 ;
    FSDateTime *argp2 ;
    
    arg1 = (FSSignature *)imarg1;
    argp2 = (FSDateTime *)imarg2;
    
    THROWEXCEPTION_IF_NULLPOINTER1(arg1, argp2);
    
    arg2 = *argp2;
    
    (arg1)->setSigningTime(arg2);
}

NSString * _wrap_FSSignature_getKeyValue(void* imarg1, int imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FS_SIGNATUREKEYNAME arg2 ;
    NSString * imresult = 0 ;
    FSString result;
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (FS_SIGNATUREKEYNAME)imarg2;
    result = (arg1)->getKeyValue(arg2);
    {
        if (0 < (result).getBufferLen()) {
            imresult = [NSString stringWithUTF8String: (const char*)((result).getBuffer())];
        }
    }
    return imresult;
}

void _wrap_FSSignature_setKeyValue(void* imarg1, int imarg2, NSString * imarg3)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FS_SIGNATUREKEYNAME arg2 ;
    char *arg3 = (char *) 0 ;
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (FS_SIGNATUREKEYNAME)imarg2;
    {
        arg3 = 0;
        if (imarg3) {
            arg3 = (char *)[imarg3 cStringUsingEncoding:NSUTF8StringEncoding];        }
    }
    (arg1)->setKeyValue(arg2,(char const *)arg3);
}

void* _wrap_FSSignature_getBitmap(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    void* imresult = 0 ;
    FSBitmap *result = 0 ;
    
    arg1 = (FSSignature *)imarg1;
    result = (FSBitmap *)(arg1)->getBitmap();
    imresult = (void*)result;
    return imresult;
}

void _wrap_FSSignature_setBitmap(void* imarg1, void* imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FSBitmap *arg2 = (FSBitmap *) 0 ;
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (FSBitmap *)imarg2;
    
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    
    (arg1)->setBitmap(arg2);
}

void _wrap_FSSignature_setImagePath(void* imarg1, NSString* imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    char *arg2 = (char *) 0 ;
    
    THROWEXCEPTION_IF_NULLPOINTER(imarg2);
    
    arg1 = (FSSignature *)imarg1;
    arg2 = (char*)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
    
    (arg1)->setImagePath(arg2);
}
    
void* _wrap_FSSignature_getSignatureDict(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    void* imresult = 0 ;
    FSPDFDictionary *result = 0 ;
    
    arg1 = (FSSignature *)imarg1; 
    result = (FSPDFDictionary *)(arg1)->getSignatureDict();
    imresult = (void*)result; 
    return imresult;
}

void _wrap_FSSignature_setAppearanceContent(void* imarg1, NSString * imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    char *arg2 = (char *) 0 ;
    
    arg1 = (FSSignature *)imarg1; 
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = (char *)[imarg2 cStringUsingEncoding:NSUTF8StringEncoding];
        }
    }
    (arg1)->setAppearanceContent((char const *)arg2);
}
    
class FR_OFDSignatureHandlerImp : public FSSignatureHandler
{
public :
    FR_OFDSignatureHandlerImp(FSSignatureCallback* callback)
    {
        m_Callback = callback;
    }
    
    ~FR_OFDSignatureHandlerImp()
    {

    }
    
#ifndef _SWIG_IOS_
    /**
     * @brief	A callback function used to release current ::FSSignatureHandler object itself.
     *
     * @return	None.
     */
    virtual void			release() {
        delete this;
    }
#endif
    
    virtual FS_BOOL				startCalcDigest(FSFileRead* file, const FS_DWORD* byteRangeArray, FS_DWORD sizeofArray, FSSignature* signature, void* clientData)
    {
        return FALSE;
    }
    
    virtual FS_PROGRESSSTATE	continueCalcDigest(FSPause* pause, void* clientData)
    {
        return e_progressError;
    }
    
    virtual FSString			getDigest(void* clientData)
    {
        return FSString();
    }
    
    virtual FSString			sign(void* digest, FS_DWORD digestLen, const char* certPath, const char password[], FS_INT32 passwordLen, FS_DIGEST_ALGORITHM digestAlgorithm, void* clientData)
    {
        NSData* nsDigest = [NSData dataWithBytes:digest length:digestLen];
        NSString* nsCertPath = [NSString stringWithUTF8String:certPath];
        NSString* nsPassword = [NSString stringWithUTF8String:password];
        NSObject* nsClientData = nil;
        if (clientData) {
            nsClientData = nsClientData;
        }
        NSData* data = [m_Callback sign:nsDigest certPath:nsCertPath certPassword:nsPassword digestAlgorithm:digestAlgorithm clientData:nsClientData];
        if (nil == data) {
            return FSString();
        }
        
        return FSString((const char *)data.bytes, data.length);
    }
    
    virtual FS_DWORD		verify(void* digest, FS_DWORD digestLen, void* signedData, FS_DWORD signDataLen, void* clientData)
    {
        return 0;
    }
    
    
    // add by gm begin 20170818
    virtual FSString        getCertData(const char* certPath, const char password[], FS_INT32 passwordLen, void* clientData)
    {
        NSString* nsCertPath = [NSString stringWithUTF8String: certPath];
        //NSData* nsPasswordData = [NSData dataWithBytes:password length:passwordLen];
        NSString* nsPassword = [NSString stringWithUTF8String:password];
        
        NSObject* nsClientData = nil;
        if (clientData) {
            nsClientData = nsClientData;
        }
        
        NSData* data = [m_Callback getCertData:nsCertPath certPassword:nsPassword clientData:nsClientData];
        if (nil == data) {
            return FSString();
        }
        
        return FSString((const char *)data.bytes, data.length);
    }
    // add end 20170818
protected:
    FSSignatureCallback* m_Callback;
};
    
    
void _wrap_FSSignature_setSignatureHandler(void* imarg1, void* imarg2)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    FSSignatureHandler *arg2 = (FSSignatureHandler *) 0 ;
    
    arg1 = (FSSignature *)imarg1;
    {
        arg2 = 0;
        if (imarg2) {
            arg2 = new FR_OFDSignatureHandlerImp((FSSignatureCallback*)imarg2);
        }
    }
    (arg1)->setSignatureHandler(arg2);
}

void _wrap_delete_FSSignature(void* imarg1)
{
    FSSignature *arg1 = (FSSignature *) 0 ;
    
    arg1 = (FSSignature *)imarg1; 
    delete arg1;
}


#ifdef __cplusplus
}
#endif
