/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */
#include "iosrdkswig_proxy.h"
#include "iosrdkswig_wrap.h"

@interface SWIGTYPE_p_void : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

@end

/**
 * @name Macro Definitions for icon type.
 */
/**@{*/
/** @brief note icon type Check. */
#define FPDF_ICONTYPE_NOTE_CHECKMARK		0
/** @brief note icon type Circle. */
#define FPDF_ICONTYPE_NOTE_CIRCLE			1
/** @brief note icon type Comment. */
#define FPDF_ICONTYPE_NOTE_COMMENT			2
/** @brief note icon type Cross. */
#define FPDF_ICONTYPE_NOTE_CROSS			3
/** @brief note icon type Help. */
#define FPDF_ICONTYPE_NOTE_HELP				4
/** @brief note icon type Insert. */
#define FPDF_ICONTYPE_NOTE_INSERT			5
/** @brief note icon type Key. */
#define FPDF_ICONTYPE_NOTE_KEY				6
/** @brief note icon type New Paragraph. */
#define FPDF_ICONTYPE_NOTE_NEWPARAGRAPH		7
/** @brief note icon type Note. */
#define FPDF_ICONTYPE_NOTE_NOTE				8
/** @brief note icon type Paragraph. */
#define FPDF_ICONTYPE_NOTE_PARAGRAPH		9
/** @brief note icon type Right Arrow. */
#define FPDF_ICONTYPE_NOTE_RIGHTARROW		10
/** @brief note icon type Right Pointer. */
#define FPDF_ICONTYPE_NOTE_RIGHTPOINTER		11
/** @brief note icon type Star. */
#define FPDF_ICONTYPE_NOTE_STAR				12
/** @brief note icon type Up Arrow. */
#define FPDF_ICONTYPE_NOTE_UPARROW			13
/** @brief note icon type Upleft Arrow. */
#define FPDF_ICONTYPE_NOTE_UPLEFTARROW		14

/** @brief file attachment icon type Graph. */
#define FPDF_ICONTYPE_FILEATTACH_GRAPH		0
/** @brief file attachment icon type PushPin. */
#define FPDF_ICONTYPE_FILEATTACH_PUSHPIN	1
/** @brief file attachment icon type PaperClip. */
#define FPDF_ICONTYPE_FILEATTACH_PAPERCLIP	2
/** @brief file attachment icon type Tag. */
#define FPDF_ICONTYPE_FILEATTACH_TAG		3

/** @brief Unknown icon type. */
#define FPDF_ICONTYPE_UNKNOWN				-1
/**@}*/

NSDate* convertFSDateTime2NSDate(FSDateTime *time)
{
    if ([time getYear] > 10000 || [time getYear] == 0 ||
        [time getMonth] > 12 || [time getMonth] == 0 ||
        [time getDay] > 31 || [time getDay] == 0 ||
        [time getHour] > 24 ||
        [time getMinute] > 60 ||
        [time getSecond] > 60)
    {
        return nil;
    }
    
    NSDateComponents *comps = [[NSDateComponents alloc] init];
    [comps setYear:[time getYear]];
    [comps setMonth:[time getMonth]];
    [comps setDay:[time getDay]];
    [comps setHour:[time getHour]];
    [comps setMinute:[time getMinute]];
    [comps setSecond:[time getSecond]];
    NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
    NSDate *date = [gregorian dateFromComponents:comps];
    [gregorian release];
    [comps release];
    return date;
}

FSDateTime* convert2FSDateTime(NSDate* date)
{
    NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
    unsigned unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit |  NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ;
    NSDateComponents *comps = [gregorian components:unitFlags fromDate:date];
    FSDateTime *time = [[[FSDateTime alloc] init] autorelease];
    time.year = [comps year];
    time.month = [comps month];
    time.day = [comps day];
    time.hour = [comps hour];
    time.minute = [comps minute];
    time.second = [comps second];
    time.UTHourOffset = 0;
    time.UTMinuteOffset = 0;
    [gregorian release];
    return time;
}

FSRectF* convertToFSRect(FSPointF *p1, FSPointF *p2)
{
    FSRectF *rect = [[[FSRectF alloc] init] autorelease];
    rect.left = MIN([p1 getX], [p2 getX]);
    rect.right = MAX([p1 getX], [p2 getX]);
    rect.top = MAX([p1 getY], [p2 getY]);
    rect.bottom = MIN([p1 getY], [p2 getY]);
    return rect;
}

FSAnnot* creatFSAnnotFromCAnnot(void* p)
{
    FSAnnot* result = nil;
    enum FS_ANNOTTYPE type = (enum FS_ANNOTTYPE)_wrap_FSAnnot_getType(p);
    switch (type) {
        case e_annotNote:
            result = [[FSNote alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotHighlight:
            result = [[FSHighlight alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotUnderline:
            result = [[FSUnderline alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotStrikeOut:
            result = [[FSStrikeOut alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotSquiggly:
            result = [[FSSquiggly alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotLink:
            result = [[FSLink alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotSquare:
            result = [[FSSquare alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotCircle:
            result = [[FSCircle alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotFreeText:
            result = [[FSFreeText alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotLine:
            result = [[FSLine alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotStamp:
            result = [[FSStamp alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotInk:
            result = [[FSInk alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotCaret:
            result = [[FSCaret alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotPolyLine:
            result =[[FSPolyLine alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotPolygon:
            result = [[FSPolygon alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotFileAttachment:
            result = [[FSFileAttachment alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotPopup:
            result = [[FSPopup alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        case e_annotWidget:
        {
            FSFormControl* control = [[FSFormControl alloc] initWithCptr:p swigOwnCObject:NO];
            FSFormField* field = [control getField];
            if(field && [field getType] == e_formFieldSignature)
                control = [[FSSignature alloc] initWithCptr:p swigOwnCObject:NO];
            result = control;
            break;
        }
        default:
        {
            if (_wrap_FSAnnot_isMarkup(p))
                result = [[FSMarkup alloc] initWithCptr:p swigOwnCObject:NO];
            else
                result = [[FSAnnot alloc] initWithCptr:p swigOwnCObject:NO];
            break;
        }
    }
    return result;
}

FSPDFObject* creatFSObjectFromCObject (void* p)
{
    FSPDFObject* result = nil;
    enum FS_PDFOBJECTTYPE type = (enum FS_PDFOBJECTTYPE)_wrap_FSPDFObject_getType(p);
    if (e_objDictionary == type)
        result = [[FSPDFDictionary alloc] initWithCptr:p swigOwnCObject:NO];
    else if (e_objArray == type)
        result = [[FSPDFArray alloc] initWithCptr:p swigOwnCObject:NO];
    else if (e_objStream == type)
        result = [[FSPDFStream alloc] initWithCptr:p swigOwnCObject:NO];
    else
        result = [[FSPDFObject alloc] initWithCptr:p swigOwnCObject:NO];
    return result;
    
}


@interface FSPointF()
{
@public
    float _x;
    float _y;
}
@end

@interface FSRectF()
{
@public
    float _left;
    float _top;
    float _right;
    float _bottom;
}

@end;

@interface FSRectI()
{
@public
    int _top;
    int _left;
    int _right;
    int _bottom;
}
@end;

@interface FSMatrix()
{
@public
    float _a;
    float _b;
    float _c;
    float _d;
    float _e;
    float _f;
}
@end;

@interface FSDefaultAppearance()
{
@public
    unsigned int _flags;
    FSFont* _font;
    float _fontSize;
    unsigned int _textColor;
}

@end

@interface FSPDFDoc()
{
    
}

@property (nonatomic,retain) NSArray* textPages;

@end


//@interface FSAction()
//
//@property (nonatomic,retain) FSAnnot* fsannot;
//@property (nonatomic,assign) FSCRT_ANNOT annot;
//@property (nonatomic,assign) int index;
//@property (nonatomic,assign) FSPDF_ACTIONDATA actionData;
//
//@end

@interface FSRestoreObj : NSObject
@property (nonatomic, assign) FSPDFDoc* pdfDoc;
@property (nonatomic, retain) NSString* filePath;
@property (nonatomic, retain) NSString* password;
@property (nonatomic, retain) NSData* fileBuff;
@property (nonatomic, retain) FSFileReadCallback* fileRead;
@end

@implementation FSRestoreObj
@synthesize filePath;
@synthesize password;
@synthesize fileBuff;
@synthesize fileRead;
@end

@interface FSSealImage()
{
    
}



@end

@implementation FSSealImage

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}
-(NSData *)m_bitmap
{
    return _bitmap;
}

-(float)m_height
{
    return _height;
}

-(float)m_width
{
    return _width;
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSNotifier((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}
@end

@interface FSRecoveryManager()
@property (retain,nonatomic)  NSMutableArray *_restoreObjs;
-(void)setFilePath:(FSPDFDoc*)doc FilePath:(NSString*)filePath;
-(void)setFileBuffer:(FSPDFDoc*)doc FileBuff:(NSData*)fileBuff;
-(void)setFileRead:(FSPDFDoc*)doc FileRead:(FSFileReadCallback*)fileRead;
-(void)setPassword:(FSPDFDoc*)doc FilePass:(NSString*)filePass;
-(NSString*)getFilePath:(FSPDFDoc*)doc;
-(NSData*)getFileBuff:(FSPDFDoc*)doc;
-(NSString*)getFilePass:(FSPDFDoc*)doc;
-(FSFileReadCallback*)getFileRead:(FSPDFDoc*)doc;
@end

@implementation FSRecoveryManager

+(FSRecoveryManager*)sharedInstance
{
    static FSRecoveryManager *sharedRestoreManagerInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedRestoreManagerInstance = [[FSRecoveryManager alloc] init];
        sharedRestoreManagerInstance._restoreObjs = [NSMutableArray array];
    });
    return sharedRestoreManagerInstance;
}

-(void)setFilePath:(FSPDFDoc*)doc FilePath:(NSString*)filePath
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            resObj.filePath = filePath;
            return;
        }
    }
    FSRestoreObj* resObj = [[FSRestoreObj alloc]init];
    resObj.pdfDoc = doc;
    resObj.filePath = filePath;
    [[FSRecoveryManager sharedInstance]._restoreObjs addObject:resObj];
    [resObj release];
}

-(void)setFileBuffer:(FSPDFDoc*)doc FileBuff:(NSData*)fileBuff
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            resObj.fileBuff = fileBuff;
            return;
        }
    }
    FSRestoreObj* resObj = [[FSRestoreObj alloc]init];
    resObj.pdfDoc = doc;
    resObj.fileBuff = fileBuff;
    [[FSRecoveryManager sharedInstance]._restoreObjs addObject:resObj];
    [resObj release];
}

-(void)setFileRead:(FSPDFDoc*)doc FileRead:(FSFileReadCallback*)fileRead
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            resObj.fileRead = fileRead;
            return;
        }
    }
    FSRestoreObj* resObj = [[FSRestoreObj alloc]init];
    resObj.pdfDoc = doc;
    resObj.fileRead = fileRead;
    [[FSRecoveryManager sharedInstance]._restoreObjs addObject:resObj];
    [resObj release];
}
-(void)setPassword:(FSPDFDoc*)doc FilePass:(NSString*)filePass
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            resObj.password = filePass;
            return;
        }
    }
    FSRestoreObj* resObj = [[FSRestoreObj alloc]init];
    resObj.pdfDoc = doc;
    resObj.password = filePass;
    [[FSRecoveryManager sharedInstance]._restoreObjs addObject:resObj];
    [resObj release];
}
-(NSString*)getFilePath:(FSPDFDoc*)doc
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            return resObj.filePath;
        }
    }
    return nil;
}
-(NSData*)getFileBuff:(FSPDFDoc*)doc
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            return resObj.fileBuff;
        }
    }
    return nil;
}
-(NSString*)getFilePass:(FSPDFDoc*)doc
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            return resObj.password;
        }
    }
    return nil;
}
-(FSFileReadCallback*)getFileRead:(FSPDFDoc*)doc
{
    for (FSRestoreObj *resObj in [FSRecoveryManager sharedInstance]._restoreObjs)
    {
        if(resObj.pdfDoc == doc)
        {
            return resObj.fileRead;
        }
    }
    return nil;
}

-(FSPDFDoc*)reloadDoc:(FSPDFDoc*)pdfDoc
{
    /* re-initialize the sdk library */
    [FSLibrary reinit];
    
    FSPDFDoc* doc = nil;
    if([self getFilePath:pdfDoc])
    {
        doc = [FSPDFDoc createFromFilePath:[self getFilePath:pdfDoc]];
    }
    else if([self getFileBuff:pdfDoc])
    {
        doc = [FSPDFDoc createFromMemory:[self getFileBuff:pdfDoc]];
    }
    else if([self getFileRead:pdfDoc])
    {
        doc = [FSPDFDoc createFromHandler:[self getFileRead:pdfDoc]];
    }
    enum FS_ERRORCODE error = [doc load:[self getFilePass:pdfDoc]];
    if(error != e_errSuccess)
        return nil;
    return [[doc retain] autorelease];
}

@end



@implementation SWIGTYPE_p_void
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

@end


@implementation FSNotifier
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(void)OnOutOfMemory
{

}

-(id)init
{
    if(self = [super init])
    {
        swigCPtr = _wrap_FSNotifier_init(self);
        swigCMemOwn = YES;
    }
    return self;
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSNotifier((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSLibrary
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(enum FS_ERRORCODE)init: (NSString *)sn key: (NSString *)key
{
  return (enum FS_ERRORCODE)_wrap_FSLibrary_init(sn, key);
}

+(enum FS_ERRORCODE)reinit
{
    return (enum FS_ERRORCODE)_wrap_FSLibrary_reinit();
}

+(void)release
{
 _wrap_FSLibrary_release();
}

+(NSString*)getVersion
{
    return _wrap_FSLibrary_getVersion();
}

+(enum FS_MODULERIGHT)getModuleRight: (enum FS_MODULENAME)module
{
  return (enum FS_MODULERIGHT)_wrap_FSLibrary_getModuleRight((int)module); 
}

+(BOOL)setAnnotIconProvider: (FSAnnotIconProviderCallback*)iconProvider
{
  return _wrap_FSLibrary_setAnnotIconProvider(iconProvider);
}

+(BOOL)setNotifier: (FSNotifier*)notifier
{
  return _wrap_FSLibrary_setNotifier([notifier getCptr]); 
}

+(BOOL)setActionHandler:(FSActionHandler*)actionHandler
{
    return _wrap_FSLibrary_setActionHandler(actionHandler);
}

+(BOOL)registerDefaultSignatureHandler
{
    return _wrap_FSLibrary_registerDefaultSignatureHandler();
}

+(NSArray *)addExtendedFont:(NSString *)filepath
{
    NSString * fontfolder = filepath;
    NSMutableArray * array = [NSMutableArray arrayWithCapacity:0];
    NSArray * fontArray;
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isDir = NO;
    BOOL existed = [fileManager fileExistsAtPath:fontfolder isDirectory:&isDir];
    if (existed) {
        NSArray * DirArray = [[NSArray alloc]init];
        DirArray = [fileManager contentsOfDirectoryAtPath:fontfolder error:nil];
        for (NSString * string in DirArray)
        {
            NSString* fullpath = [fontfolder stringByAppendingPathComponent:string];
            NSString* extension = [fullpath pathExtension];
            extension = [extension uppercaseString];
            if ([extension isEqualToString:@"TTF"] || [extension isEqualToString:@"TTC"] || [extension isEqualToString:@"OTF"] ) {
                int result = _wrap_FSLibrary_addExtFont(fullpath);
                NSLog(@"result:%d",result);
                [array addObject:string];
            }
        }
        fontArray = [NSArray arrayWithArray:array];
    }
    return fontArray;
    
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSLibrary((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPointF
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _x = [self x];
        _y = [self y];
	}
	return self;
}

-(void)set: (float)x y: (float)y
{
 _wrap_FSPointF_set([self getCptr], x, y);
    _x = x;
    _y = y;
}

-(float)x
{
    _x = _wrap_FSPointF_x_get([self getCptr]);
    return _x;
}

-(void)setX: (float)value
{
 _wrap_FSPointF_x_set([self getCptr], value);
    _x = value;
}

-(float)getX
{
  return [self x];
}

-(float)y
{
    _y = _wrap_FSPointF_y_get([self getCptr]);
    return _y;
}

-(void)setY: (float)value
{
 _wrap_FSPointF_y_set([self getCptr], value);
    _y = value;
}

-(float)getY
{
  return [self y];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSPointF();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPointF((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSRectF
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _left = [self left];
        _bottom = [self bottom];
        _right = [self right];
        _top = [self top];
	}
	return self;
}

-(void)set: (float)left bottom: (float)bottom right: (float)right top: (float)top
{
 _wrap_FSRectF_set([self getCptr], left, bottom, right, top);
    _left = left;
    _bottom = bottom;
    _right = right;
    _top = top;
}

-(float)left
{
    _left = _wrap_FSRectF_left_get([self getCptr]);
    return _left;
}

-(void)setLeft: (float)value
{
 _wrap_FSRectF_left_set([self getCptr], value);
    _left = value;
}

-(float)getLeft
{
  return [self left];
}

-(float)bottom
{
    _bottom = _wrap_FSRectF_bottom_get([self getCptr]);
    return _bottom;
}

-(void)setBottom: (float)value
{
 _wrap_FSRectF_bottom_set([self getCptr], value);
    _bottom = value;
}

-(float)getBottom
{
  return [self bottom];
}

-(float)right
{
    _right = _wrap_FSRectF_right_get([self getCptr]);
    return _right;
}

-(void)setRight: (float)value
{
 _wrap_FSRectF_right_set([self getCptr], value);
    _right = value;
}

-(float)getRight
{
  return [self right];
}

-(float)top
{
    _top = _wrap_FSRectF_top_get([self getCptr]);
    return _top;
}

-(void)setTop: (float)value
{
 _wrap_FSRectF_top_set([self getCptr], value);
    _top = value;
}

-(float)getTop
{
  return [self top];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSRectF();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSRectF((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSRectI
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _left = [self left];
        _bottom = [self bottom];
        _right = [self right];
        _top = [self top];
	}
	return self;
}

-(void)set: (int)left top: (int)top right: (int)right bottom: (int)bottom
{
 _wrap_FSRectI_set([self getCptr], left, top, right, bottom);
    _left = left;
    _bottom = bottom;
    _right = right;
    _top = top;
}

-(int)left
{
    _left = _wrap_FSRectI_left_get([self getCptr]);
    return _left;
}

-(void)setLeft: (int)value
{
 _wrap_FSRectI_left_set([self getCptr], value);
    _left = value;
}

-(int)getLeft
{
  return [self left];
}

-(int)top
{
    _top = _wrap_FSRectI_top_get([self getCptr]);
    return _top;
}

-(void)setTop: (int)value
{
 _wrap_FSRectI_top_set([self getCptr], value);
    _top = value;
}

-(int)getTop
{
  return [self top];
}

-(int)right
{
    _right = _wrap_FSRectI_right_get([self getCptr]);
    return _right;
}

-(void)setRight: (int)value
{
 _wrap_FSRectI_right_set([self getCptr], value);
    _right = value;
}

-(int)getRight
{
  return [self right];
}

-(int)bottom
{
    _bottom = _wrap_FSRectI_bottom_get([self getCptr]);
    return _bottom;
}

-(void)setBottom: (int)value
{
 _wrap_FSRectI_bottom_set([self getCptr], value);
    _bottom = value;
}

-(int)getBottom
{
  return [self bottom];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSRectI();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSRectI((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSMatrix
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _a = [self a];
        _b = [self b];
        _c = [self c];
        _d = [self d];
        _e = [self e];
        _f = [self f];
	}
	return self;
}

-(void)set: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f
{
 _wrap_FSMatrix_set([self getCptr], a, b, c, d, e, f);
    _a = a;
    _b = b;
    _c = c;
    _d = d;
    _e = e;
    _f = f;
}

-(FSMatrix*)getReverse
{
    void* cPtr = _wrap_FSMatrix_getReverse([self getCptr]);
    FSMatrix* ret = nil;
    if(cPtr) {
        ret = [[FSMatrix alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(FSPointF*)transform: (FSPointF*)point
{
    void* cPtr = _wrap_FSMatrix_transform([self getCptr], [point getCptr]);
     FSPointF* ret = nil;
     if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSRectF*)transformRect: (FSRectF*)rect
{
    void* cPtr = _wrap_FSMatrix_transformRect([self getCptr], [rect getCptr]);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(void)setA: (float)value
{
 _wrap_FSMatrix_a_set([self getCptr], value);
    _a = value;
}

-(float)a
{
    _a = _wrap_FSMatrix_a_get([self getCptr]);
    return _a;
}

-(float)getA
{
  return [self a];
}

-(void)setB: (float)value
{
 _wrap_FSMatrix_b_set([self getCptr], value);
    _b = value;
}

-(float)b
{
    _b = _wrap_FSMatrix_b_get([self getCptr]);
    return _b;
}

-(float)getB
{
  return [self b];
}

-(void)setC: (float)value
{
 _wrap_FSMatrix_c_set([self getCptr], value);
    _c = value;
}

-(float)c
{
    _c = _wrap_FSMatrix_c_get([self getCptr]);
    return _c;
}

-(float)getC
{
  return [self c];
}

-(void)setD: (float)value
{
 _wrap_FSMatrix_d_set([self getCptr], value);
    _d = value;
}

-(float)d
{
    _d = _wrap_FSMatrix_d_get([self getCptr]);
    return _d;
}

-(float)getD
{
  return [self d];
}

-(void)setE: (float)value
{
 _wrap_FSMatrix_e_set([self getCptr], value);
    _e = value;
}

-(float)e
{
    _e = _wrap_FSMatrix_e_get([self getCptr]);
    return _e;
}

-(float)getE
{
  return [self e];
}

-(void)setF: (float)value
{
 _wrap_FSMatrix_f_set([self getCptr], value);
    _f = value;
}

-(float)f
{
    _f = _wrap_FSMatrix_f_get([self getCptr]);
    return _f;
}

-(float)getF
{
  return [self f];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSMatrix();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSMatrix((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSDateTime
{
    unsigned short _year;
    unsigned short _month;
    unsigned short _day;
    unsigned short _hour;
    unsigned short _minute;
    unsigned short _second;
    unsigned short _millisecond;
    short _UTHourOffset;
    unsigned short _UTMinuteOffset;
}

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _year = [self year];
        _month = [self month];
        _day = [self day];
        _hour = [self hour];
        _minute = [self minute];
        _second = [self second];
        _millisecond = [self millisecond];
        _UTHourOffset = [self UTHourOffset];
        _UTMinuteOffset = [self UTMinuteOffset];
    }
    return self;
}

-(void)set: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second millisecond: (unsigned short)millisecond UTHourOffset: (short)UTHourOffset UTMinuteOffset: (unsigned short)UTMinuteOffset
{
    _wrap_FSDateTime_set([self getCptr], year, month, day, hour, minute, second, millisecond, UTHourOffset, UTMinuteOffset);
    _year = year;
    _month = month;
    _day = day;
    _hour = hour;
    _minute = minute;
    _second = second;
    _millisecond = millisecond;
    _UTHourOffset = UTHourOffset;
    _UTMinuteOffset = UTMinuteOffset;
}

-(void)setYear: (unsigned short)value
{
    _wrap_FSDateTime_year_set([self getCptr], value);
    _year = value;
}

-(unsigned short)year
{
    _year = _wrap_FSDateTime_year_get([self getCptr]);
    return _year;
}

-(unsigned short)getYear
{
    return [self year];
}

-(void)setMonth: (unsigned short)value
{
    _wrap_FSDateTime_month_set([self getCptr], value);
    _month = value;
}

-(unsigned short)month
{
    _month = _wrap_FSDateTime_month_get([self getCptr]);
    return _month;
}

-(unsigned short)getMonth
{
    return [self month];
}

-(void)setDay: (unsigned short)value
{
    _wrap_FSDateTime_day_set([self getCptr], value);
    _day = value;
}

-(unsigned short)day
{
    _day = _wrap_FSDateTime_day_get([self getCptr]);
    return _day;
}

-(unsigned short)getDay
{
    return [self day];
}

-(void)setHour: (unsigned short)value
{
    _wrap_FSDateTime_hour_set([self getCptr], value);
    _hour = value;
}

-(unsigned short)hour
{
    _hour = _wrap_FSDateTime_hour_get([self getCptr]);
    return _hour;
}

-(unsigned short)getHour
{
    return [self hour];
}

-(void)setMinute: (unsigned short)value
{
    _wrap_FSDateTime_minute_set([self getCptr], value);
    _minute = value;
}

-(unsigned short)minute
{
    _minute = _wrap_FSDateTime_minute_get([self getCptr]);
    return _minute;
}

-(unsigned short)getMinute
{
    return [self minute];
}

-(void)setSecond: (unsigned short)value
{
    _wrap_FSDateTime_second_set([self getCptr], value);
    _second = value;
}

-(unsigned short)second
{
    _second = _wrap_FSDateTime_second_get([self getCptr]);
    return _second;
}

-(unsigned short)getSecond
{
    return [self second];
}

-(void)setMillisecond: (unsigned short)value
{
    _wrap_FSDateTime_millisecond_set([self getCptr], value);
    _millisecond = value;
}

-(unsigned short)millisecond
{
    _millisecond = _wrap_FSDateTime_millisecond_get([self getCptr]);
    return _millisecond;
}

-(unsigned short)getMillisecond
{
    return [self millisecond];
}

-(void)setUTHourOffset: (short)value
{
    _wrap_FSDateTime_UTHourOffset_set([self getCptr], value);
    _UTHourOffset = value;
}

-(short)UTHourOffset
{
    _UTHourOffset = _wrap_FSDateTime_UTHourOffset_get([self getCptr]);
    return _UTHourOffset;
}

-(short)getUTHourOffset
{
    return [self UTHourOffset];
}

-(void)setUTMinuteOffset: (unsigned short)value
{
    _wrap_FSDateTime_UTMinuteOffset_set([self getCptr], value);
    _UTMinuteOffset = value;
}

-(unsigned short)UTMinuteOffset
{
    _UTMinuteOffset = _wrap_FSDateTime_UTMinuteOffset_get([self getCptr]);
    return _UTMinuteOffset;
}

-(unsigned short)getUTMinuteOffset
{
    return [self UTMinuteOffset];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSDateTime();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSDateTime((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSFont

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

+(FSFont*)create: (NSString*) fontName fontStyles: (unsigned int)fontStyles weight: (int)weight  charset: (enum FS_FONTCHARSET) charset
{
    
    void* cPtr = _wrap_FSFont_create(fontName, fontStyles, weight, (int)charset);
    FSFont* ret = nil;
    if(cPtr) {
        ret = [[FSFont alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
    
}

+(FSFont*)createStandard :(enum FS_STANDARDFONTID) fontID
{
    void* cPtr = _wrap_FSFont_createStandard((int)fontID);
    FSFont* ret = nil;
    if (cPtr) {
        ret = [[FSFont alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(NSString*) getName
{
    return _wrap_FSFont_getName([self getCptr]);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFont((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}


@end


@implementation FSDefaultAppearance
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
        _flags = [self flags];
        _font = [self font];
        _fontSize = [self fontSize];
        _textColor = [self textColor];
    }
    return self;
}

-(id)init
{
    if((self = [super init])) {
        void* cptr = _wrap_new_FSDefaultAppearance();
        swigCPtr = cptr;
        swigCMemOwn = YES;
    }
    return self;
}

-(void) set: (unsigned int) flags font: (FSFont*) font fontSize: (float)fontSize textColor: (unsigned int) textColor 
{
    _wrap_FSDefaultAppearance_set([self getCptr], flags, [font getCptr], fontSize, textColor);
    _flags = flags;
    _font = font;
    _fontSize = fontSize;
    _textColor = textColor;
}

-(void)setFlags:(unsigned int)flags
{
    _wrap_FSDefaultAppearance_flags_set([self getCptr], flags);
    _flags = flags;
}

-(void)setFont:(FSFont *)font
{
    _wrap_FSDefaultAppearance_font_set([self getCptr], [font getCptr]);
    _font = font;
}

-(void)setFontSize:(float)fontSize
{
    _wrap_FSDefaultAppearance_fontSize_set([self getCptr], fontSize);
    _fontSize = fontSize;
}

-(void)setTextColor:(unsigned int)textColor
{
    _wrap_FSDefaultAppearance_textColor_set([self getCptr], textColor);
    _textColor = textColor;
}

-(unsigned int)flags
{
    _flags = _wrap_FSDefaultAppearance_flags_get([self getCptr]);
    return _flags;
}

- (FSFont *)font
{
    if (_font) {
        return _font;
    }
   else
   {
       void* cPtr = _wrap_FSDefaultAppearance_font_get([self getCptr]);
       FSFont* ret = nil;
       if(cPtr) {
           ret = [[FSFont alloc] initWithCptr:cPtr swigOwnCObject:NO];
       }
       _font = ret;
       return _font;
   }
}

-(float)fontSize
{
    _fontSize = _wrap_FSDefaultAppearance_fontSize_get([self getCptr]);
    return _fontSize;
}

-(unsigned int)textColor
{
    _textColor = _wrap_FSDefaultAppearance_textColor_get([self getCptr]);
    return _textColor;
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSDefaultAppearance((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    //[_font dealloc];
    [super dealloc];
    
}

@end

@implementation FSPDFPath
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

+(FSPDFPath*) create
{
    void* cPtr = _wrap_FSPDFPath_create();
    FSPDFPath* ret = nil;
    if(cPtr) {
        ret = [[FSPDFPath alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(int)getPointCount
{
    return _wrap_FSPDFPath_getPointCount([self getCptr]);
}

-(FSPointF*) getPoint : (int)index
{
    void* cPtr = _wrap_FSPDFPath_getPoint([self getCptr], index);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(enum FS_PATHPOINTTYPE)getPointType : (int) index
{
    return (enum FS_PATHPOINTTYPE)_wrap_FSPDFPath_getPointType([self getCptr], index);
}

-(BOOL)setPoint : (int)index  point : (FSPointF*) point pointType : (enum FS_PATHPOINTTYPE) pointType
{
    return _wrap_FSPDFPath_setPoint([self getCptr], index, [point getCptr], (int)pointType);
}

-(BOOL)moveTo : (FSPointF*) point
{
    return _wrap_FSPDFPath_moveTo([self getCptr], [point getCptr]);
}

-(BOOL)lineTo : (FSPointF*) point
{
    return _wrap_FSPDFPath_lineTo([self getCptr], [point getCptr]);
}

-(BOOL)cubicBezierTo : (FSPointF*) point1  point2 : (FSPointF*) point2  point3 : (FSPointF*) point3
{
    return _wrap_FSPDFPath_cubicBezierTo([self getCptr], [point1 getCptr], [point2 getCptr], [point3 getCptr]);
}

-(BOOL)closeFigure
{
    return _wrap_FSPDFPath_closeFigure([self getCptr]);
}

-(BOOL)removePoint : (int)index
{
    return _wrap_FSPDFPath_removePoint([self getCptr], index);
}

-(void) clear
{
    _wrap_FSPDFPath_clear([self getCptr]);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSPDFPath((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSFileReadCallback
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(unsigned long long)getSize
{
  return _wrap_FSFileRead_getSize([self getCptr]);
}

-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size
{
    void* buffer = malloc((size_t)size);
    _wrap_FSFileRead_readBlock([self getCptr], buffer, offset, size);
    NSData* data = [NSData dataWithBytes:buffer length:(NSInteger)size];
    free(buffer);
    return data;
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSFileRead((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPauseCallback
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)needPauseNow
{
    return NO;
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPause((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end



@implementation FSDestination
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSDestination*)createXYZ: (FSPDFPage*)page left: (float)left top: (float)top zoomFactor: (float)zoomFactor
{
    void* cPtr = _wrap_FSDestination_createXYZ([page getCptr], left, top, zoomFactor);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitPage: (FSPDFPage*)page
{
    void* cPtr = _wrap_FSDestination_createFitPage([page getCptr]);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitHorz: (FSPDFPage*)page top: (float)top
{
    void* cPtr = _wrap_FSDestination_createFitHorz([page getCptr], top);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitVert: (FSPDFPage*)page left: (float)left
{
    void* cPtr = _wrap_FSDestination_createFitVert([page getCptr], left);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitRect: (FSPDFPage*)page left: (float)left bottom: (float)bottom right: (float)right top: (float)top
{
    void* cPtr = _wrap_FSDestination_createFitRect([page getCptr], left, bottom, right, top);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitBBox: (FSPDFPage*)page
{
    void* cPtr = _wrap_FSDestination_createFitBBox([page getCptr]);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitBHorz: (FSPDFPage*)page top: (float)top
{
    void* cPtr = _wrap_FSDestination_createFitBHorz([page getCptr], top);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSDestination*)createFitBVert: (FSPDFPage*)page left: (float)left
{
    void* cPtr = _wrap_FSDestination_createFitBVert([page getCptr], left);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(int)getPageIndex
{
  return _wrap_FSDestination_getPageIndex([self getCptr]); 
}

-(enum FS_ZOOMMODE)getZoomMode
{
  return (enum FS_ZOOMMODE)_wrap_FSDestination_getZoomMode([self getCptr]); 
}

-(float)getLeft
{
  return _wrap_FSDestination_getLeft([self getCptr]); 
}

-(float)getTop
{
  return _wrap_FSDestination_getTop([self getCptr]); 
}

-(float)getRight
{
  return _wrap_FSDestination_getRight([self getCptr]); 
}

-(float)getBottom
{
  return _wrap_FSDestination_getBottom([self getCptr]); 
}

-(float)getZoomFactor
{
  return _wrap_FSDestination_getZoomFactor([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSDestination((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSAction
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSAction*) create : (FSPDFDoc*)doc   actType:(enum FS_ACTIONTYPE) actType;
{
    void* cPtr = _wrap_FSAction_create([doc getCptr],(int)actType);
    FSAction* ret = nil;
    if(cPtr) {
        switch (actType) {
            case e_actionTypeGoto:
                ret = [[FSGotoAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                break;
            case e_actionTypeURI:
                ret = [[FSURIAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                break;
            default:
                ret = [[FSAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                break;
        }
    }
    return [ret autorelease];
    
}

-(enum FS_ACTIONTYPE)getType
{
  return (enum FS_ACTIONTYPE)_wrap_FSAction_getType([self getCptr]); 
}

-(int)getSubActionCount
{
  return _wrap_FSAction_getSubActionCount([self getCptr]); 
}

-(void)setSubAction :(int)index  subAction:(FSAction*) subAction
{
    _wrap_FSAction_setSubAction([self getCptr], index, [subAction getCptr]);
}

-(BOOL)insertSubAction :(int)index  subAction:(FSAction*) subAction
{
    return _wrap_FSAction_insertSubAction([self getCptr], index, [subAction getCptr]);
    
}

-(BOOL)removeSubAction : (int) index
{
    return _wrap_FSAction_removeSubAction([self getCptr], index);
}

-(BOOL)removeAllSubActions
{
    return _wrap_FSAction_removeAllSubActions([self getCptr]);
}

-(FSAction*)getSubAction: (int)index
{
    void* cPtr = _wrap_FSAction_getSubAction([self getCptr], index);
     FSAction* ret = nil;
     if(cPtr) {
         enum FS_ACTIONTYPE type = (enum FS_ACTIONTYPE)_wrap_FSAction_getType(cPtr);
         switch (type) {
             case e_actionTypeGoto:
                 ret = [[FSGotoAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
             case e_actionTypeURI:
                 ret = [[FSURIAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
             default:
                 ret = [[FSAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
         }
     }
    return [ret autorelease]; 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSAction((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSGotoAction
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(FSDestination*)getDestination
{
    void* cPtr = _wrap_FSGotoAction_getDestination([self getCptr]);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(void)setDestination : (FSDestination*) dest
{
    _wrap_FSGotoAction_setDestination([self getCptr], [dest getCptr]);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSGotoAction((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSURIAction
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(NSString *)getURI
{
  return _wrap_FSURIAction_getURI([self getCptr]); 
}

-(BOOL)isTrackPosition
{
  return _wrap_FSURIAction_isTrackPosition([self getCptr]); 
}

-(void)setURI : (NSString*)uri
{
    _wrap_FSURIAction_setURI([self getCptr], uri);
}

-(void)setTrackPositionFlag : (BOOL)isTrackPosition
{
    _wrap_FSURIAction_setTrackPositionFlag([self getCptr], isTrackPosition);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSURIAction((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSAnnot
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(FSPDFPage*)getPage
{
    void* cPtr = _wrap_FSAnnot_getPage([self getCptr]);
     FSPDFPage* ret = nil;
     if(cPtr) {
        ret = [[FSPDFPage alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(BOOL)isMarkup
{
  return _wrap_FSAnnot_isMarkup([self getCptr]); 
}

-(enum FS_ANNOTTYPE)getType
{
  return (enum FS_ANNOTTYPE)_wrap_FSAnnot_getType([self getCptr]); 
}

-(int)getIndex
{
  return _wrap_FSAnnot_getIndex([self getCptr]); 
}

-(NSString *)getContent
{
  return _wrap_FSAnnot_getContent([self getCptr]); 
}

-(void)setContent: (NSString *)content
{
 _wrap_FSAnnot_setContent([self getCptr], content);
}

-(FSDateTime*)getModifiedDateTime
{
    void* cPtr = _wrap_FSAnnot_getModifiedDateTime([self getCptr]);
     FSDateTime* ret = nil;
     if(cPtr) {
        ret = [[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(void)setModifiedDateTime: (FSDateTime*)dataTime
{
 _wrap_FSAnnot_setModifiedDateTime([self getCptr], [dataTime getCptr]);
}

-(unsigned int)getFlags
{
  return _wrap_FSAnnot_getFlags([self getCptr]); 
}

-(void)setFlags: (unsigned int)flags
{
 _wrap_FSAnnot_setFlags([self getCptr], flags);
}

-(NSString *)getUniqueID
{
  return _wrap_FSAnnot_getUniqueID([self getCptr]); 
}

-(void)setUniqueID: (NSString *)uniqueID
{
 _wrap_FSAnnot_setUniqueID([self getCptr], uniqueID);
}

-(FSRectF*)getRect
{
    void* cPtr = _wrap_FSAnnot_getRect([self getCptr]);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(BOOL)move: (FSRectF*)rect
{
  return _wrap_FSAnnot_move([self getCptr], [rect getCptr]); 
}

-(FSBorderInfo*)getBorderInfo
{
    void* cPtr = _wrap_FSAnnot_getBorderInfo([self getCptr]);
     FSBorderInfo* ret = nil;
     if(cPtr) {
        ret = [[FSBorderInfo alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(void)setBorderInfo: (FSBorderInfo*)border
{
    if (nil == border) return;
 _wrap_FSAnnot_setBorderInfo([self getCptr], [border getCptr]);
}

-(unsigned int)getBorderColor
{
  return _wrap_FSAnnot_getBorderColor([self getCptr]); 
}

-(void)setBorderColor: (unsigned int)color
{
 _wrap_FSAnnot_setBorderColor([self getCptr], color);
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSAnnot_resetAppearanceStream([self getCptr]); 
}

-(FSRectI*)getDeviceRect: (BOOL)isTransformIcon matrix: (FSMatrix*)matrix
{
    void* cPtr = _wrap_FSAnnot_getDeviceRect([self getCptr], isTransformIcon, [matrix getCptr]);
     FSRectI* ret = nil;
     if(cPtr) {
        ret = [[FSRectI alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSPDFDictionary*)getDict
{
    void* cPtr = _wrap_FSAnnot_getDict([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}
-(BOOL)removeProperty: (FS_ANNOTPROPERTY)property
{
    return _wrap_FSAnnot_removeProperty([self getCptr], property);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSAnnot((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSBorderInfo
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(void)set: (float)width style: (enum FS_BORDERSTYLE)style intensity: (float)intensity dashPhase: (float)dashPhase dashes: (NSArray *)dashes
{
 _wrap_FSBorderInfo_set([self getCptr], width, (int)style, intensity, dashPhase, dashes);
}

-(void)setWidth: (float)value
{
 _wrap_FSBorderInfo_width_set([self getCptr], value);
}

-(float)getWidth
{
  return _wrap_FSBorderInfo_width_get([self getCptr]); 
}

-(void)setStyle: (enum FS_BORDERSTYLE)value
{
 _wrap_FSBorderInfo_style_set([self getCptr], (int)value);
}

-(enum FS_BORDERSTYLE)getStyle
{
  return (enum FS_BORDERSTYLE)_wrap_FSBorderInfo_style_get([self getCptr]); 
}

-(void)setCloudIntensity: (float)value
{
 _wrap_FSBorderInfo_cloudIntensity_set([self getCptr], value);
}

-(float)getCloudIntensity
{
  return _wrap_FSBorderInfo_cloudIntensity_get([self getCptr]); 
}

-(void)setDashPhase: (float)value
{
 _wrap_FSBorderInfo_dashPhase_set([self getCptr], value);
}

-(float)getDashPhase
{
  return _wrap_FSBorderInfo_dashPhase_get([self getCptr]); 
}

-(void)setDashes: (NSArray *)value
{
 _wrap_FSBorderInfo_dashes_set([self getCptr], value);
}

-(NSArray *)getDashes
{
  return _wrap_FSBorderInfo_dashes_get([self getCptr]); 
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSBorderInfo();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSBorderInfo((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSQuadPoints
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(void)set: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth
{
    _wrap_FSQuadPoints_set([self getCptr], [first getCptr], [second getCptr], [third getCptr], [fourth getCptr]);
}

-(void)setFirst: (FSPointF*)value
{
    _wrap_FSQuadPoints_first_set([self getCptr], [value getCptr]);
}

-(FSPointF*)getFirst
{
    void* cPtr = _wrap_FSQuadPoints_first_get([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(void)setSecond: (FSPointF*)value
{
    _wrap_FSQuadPoints_second_set([self getCptr], [value getCptr]);
}

-(FSPointF*)getSecond
{
    void* cPtr = _wrap_FSQuadPoints_second_get([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(void)setThird: (FSPointF*)value
{
    _wrap_FSQuadPoints_third_set([self getCptr], [value getCptr]);
}

-(FSPointF*)getThird
{
    void* cPtr = _wrap_FSQuadPoints_third_get([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(void)setFourth: (FSPointF*)value
{
    _wrap_FSQuadPoints_fourth_set([self getCptr], [value getCptr]);
}

-(FSPointF*)getFourth
{
    void* cPtr = _wrap_FSQuadPoints_fourth_get([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSQuadPoints();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSQuadPoints((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSShadingColor
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(void)set: (unsigned int)firstColor secondColor: (unsigned int)secondColor
{
 _wrap_FSShadingColor_set([self getCptr], firstColor, secondColor);
}

-(void)setFirstColor: (unsigned int)value
{
 _wrap_FSShadingColor_firstColor_set([self getCptr], value);
}

-(unsigned int)getFirstColor
{
  return _wrap_FSShadingColor_firstColor_get([self getCptr]); 
}

-(void)setSecondColor: (unsigned int)value
{
 _wrap_FSShadingColor_secondColor_set([self getCptr], value);
}

-(unsigned int)getSecondColor
{
  return _wrap_FSShadingColor_secondColor_get([self getCptr]); 
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSShadingColor();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSShadingColor((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSAnnotIconProviderCallback
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(NSString *)getProviderID
{
  return @"";
}

-(NSString *)getProviderVersion
{
  return @"";
}

-(BOOL)hasIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName
{
  return NO;
}

-(BOOL)canChangeColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName
{
  return NO;
}

-(FSPDFPage*)getIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName color: (unsigned int)color
{
    return nil;
}

-(FSShadingColor*)getShadingColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName refColor: (unsigned int)refColor shadingIndex: (int)shadingIndex
{
  return nil;
}

-(NSNumber*)getDisplayWidth: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName
{
  return [NSNumber numberWithFloat:0.0];
}

-(NSNumber*)getDisplayHeight: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName
{
  return [NSNumber numberWithFloat:0.0];
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSAnnotIconProvider((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end

@implementation FSPopup

- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)getOpenStatus
{
    return _wrap_FSPopup_getOpenStatus([self getCptr]);
}

-(void)setOpenStatus:(BOOL)status
{
    _wrap_FSPopup_setOpenStatus([self getCptr], status);
}

@end

@implementation FSMarkup
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(FSPopup*)getPopup
{
    void* cPtr =  _wrap_FSMarkup_getPopup([self getCptr]);
    FSPopup* ret = nil;
    if(cPtr) {
        ret = [[FSPopup alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(void)setPopup:(FSPopup*)popup
{
    _wrap_FSMarkup_setPopup([self getCptr], [popup getCptr]);
}

-(NSString *)getTitle
{
  return _wrap_FSMarkup_getTitle([self getCptr]); 
}

-(void)setTitle: (NSString *)title
{
 _wrap_FSMarkup_setTitle([self getCptr], title);
}

-(NSString *)getSubject
{
  return _wrap_FSMarkup_getSubject([self getCptr]); 
}

-(void)setSubject: (NSString *)subject
{
 _wrap_FSMarkup_setSubject([self getCptr], subject);
}

-(float)getOpacity
{
  return _wrap_FSMarkup_getOpacity([self getCptr]); 
}

-(void)setOpacity: (float)opacity
{
 _wrap_FSMarkup_setOpacity([self getCptr], opacity);
}

-(NSString *)getIntent
{
  return _wrap_FSMarkup_getIntent([self getCptr]); 
}

-(void)setIntent: (NSString *)intent
{
 _wrap_FSMarkup_setIntent([self getCptr], intent);
}

-(FSDateTime*)getCreationDateTime
{
    void* cPtr = _wrap_FSMarkup_getCreationDateTime([self getCptr]);
     FSDateTime* ret = nil;
     if(cPtr) {
        ret = [[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(void)setCreationDateTime: (FSDateTime*)dateTime
{
 _wrap_FSMarkup_setCreationDateTime([self getCptr], [dateTime getCptr]);
}

-(int)getReplyCount
{
  return _wrap_FSMarkup_getReplyCount([self getCptr]); 
}

-(FSNote*)getReply: (int)index
{
    void* cPtr = _wrap_FSMarkup_getReply([self getCptr], index);
     FSNote* ret = nil;
     if(cPtr) {
        ret = [[FSNote alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSNote*)addReply
{
    void* cPtr = _wrap_FSMarkup_addReply([self getCptr]);
     FSNote* ret = nil;
     if(cPtr) {
        ret = [[FSNote alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(BOOL)removeReply: (int)index
{
  return _wrap_FSMarkup_removeReply([self getCptr], index); 
}



-(BOOL)removeAllReplies
{
  return _wrap_FSMarkup_removeAllReplies([self getCptr]); 
}

-(BOOL)isGrouped
{
    return _wrap_FSMarkup_isGrouped([self getCptr]);
}

-(FSMarkup*)getGroupHeader
{
    void* cPtr = _wrap_FSMarkup_getGroupHeader([self getCptr]);
    FSMarkup* ret = nil;
    if(cPtr) {
        ret = [[FSMarkup alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(int)getGroupElementCount
{
    return _wrap_FSMarkup_getGroupElementCount([self getCptr]);
    
}

-(FSMarkup*)getGroupElement : (int)index
{
    void* cPtr = _wrap_FSMarkup_getGroupElement([self getCptr], index);
    FSMarkup* ret = nil;
    if(cPtr) {
        ret = [[FSMarkup alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(BOOL)ungroup
{
    return _wrap_FSMarkup_ungroup([self getCptr]);
}

-(int)getStateAnnotCount: (enum FS_ANNOTSTATEMODEL)stateModel
{
    return _wrap_FSMarkup_getStateAnnotCount([self getCptr], (int)stateModel);
}

-(FSNote*)getStateAnnot: (enum FS_ANNOTSTATEMODEL)stateModel index: (int)index
{
    void* cPtr = _wrap_FSMarkup_getStateAnnot([self getCptr], (int)stateModel, index);
    FSNote* ret = nil;
    if(cPtr) {
        ret = [[[FSNote alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(FSNote*)addStateAnnot: (enum FS_ANNOTSTATEMODEL)stateModel state: (enum FS_ANNOTSTATE)state
{
    void* cPtr = _wrap_FSMarkup_addStateAnnot([self getCptr], (int)stateModel, (int)state);
    FSNote* ret = nil;
    if(cPtr) {
        ret = [[[FSNote alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(BOOL)removeAllStateAnnots
{
    return _wrap_FSMarkup_removeAllStateAnnots([self getCptr]);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSMarkup((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSNote
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)getOpenStatus
{
  return _wrap_FSNote_getOpenStatus([self getCptr]); 
}

-(void)setOpenStatus: (BOOL)status
{
 _wrap_FSNote_setOpenStatus([self getCptr], status);
}

-(NSString *)getIconName
{
  return _wrap_FSNote_getIconName([self getCptr]); 
}

-(void)setIconName: (NSString *)iconName
{
 _wrap_FSNote_setIconName([self getCptr], iconName);
}

-(FSMarkup*)getReplyTo
{
    void* cPtr = _wrap_FSNote_getReplyTo([self getCptr]);
    if(!cPtr)
        return nil;
    FSMarkup* ret = nil;
    if(cPtr)
    {
        ret = (FSMarkup*)creatFSAnnotFromCAnnot(cPtr);
    }

    return [ret autorelease];
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSNote_resetAppearanceStream([self getCptr]);
}

-(BOOL)isStateAnnot
{
    return _wrap_FSNote_isStateAnnot([self getCptr]);
}

-(enum FS_ANNOTSTATEMODEL)getStateModel
{
    return (enum FS_ANNOTSTATEMODEL)_wrap_FSNote_getStateModel([self getCptr]);
}

-(enum FS_ANNOTSTATE)getState
{
    return (enum FS_ANNOTSTATE)_wrap_FSNote_getState([self getCptr]);
}

-(void)setState: (enum FS_ANNOTSTATE)state
{
    _wrap_FSNote_setState([self getCptr], (int)state);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSNote((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSTextMarkup
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(int)getQuadPointsCount
{
  return _wrap_FSTextMarkup_getQuadPointsCount([self getCptr]); 
}

-(FSQuadPoints*)getQuadPoints: (int)index
{
    void* cPtr = _wrap_FSTextMarkup_getQuadPoints([self getCptr], index);
     FSQuadPoints* ret = nil;
     if(cPtr) {
        ret = [[FSQuadPoints alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(void)setQuadPoints: (NSArray*)quadPoints
{
    if (![[quadPoints objectAtIndex:0] isKindOfClass:[FSQuadPoints class]]) {
        return;
    }
    void* temp = 0;
    if (quadPoints && [quadPoints count] > 0) {
        int count = [quadPoints count];
        int sizeOfQuadPoint = sizeof(float)*8;
        temp = malloc(count*sizeOfQuadPoint);
        for (int i = 0; i < count; i++)
        {
            void* pQuadPoint = [(FSQuadPoints*)[quadPoints objectAtIndex:i] getCptr];
            memcpy((char*)temp+i*sizeOfQuadPoint, pQuadPoint, sizeOfQuadPoint);
        }
    }
    _wrap_FSTextMarkup_setQuadPoints([self getCptr], temp, [quadPoints count]);
    if(temp) free(temp);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSTextMarkup((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSHighlight
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSHighlight_resetAppearanceStream([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSHighlight((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSUnderline
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSUnderline_resetAppearanceStream([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSUnderline((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSStrikeOut
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSStrikeOut_resetAppearanceStream([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSStrikeOut((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSSquiggly
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSSquiggly_resetAppearanceStream([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSSquiggly((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSSquare
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(unsigned int) getFillColor
{
    return _wrap_FSSquare_getFillColor([self getCptr]);
}

-(void) setFillColor : (unsigned int)fillColor
{
    _wrap_FSSquare_setFillColor([self getCptr], fillColor);
    
}
-(FSRectF*) getInnerRect
{
    void* cPtr = _wrap_FSSquare_getInnerRect([self getCptr]);
    FSRectF* ret = nil;
    if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}
-(void) setInnerRect: (FSRectF*) innerRect
{
    if (innerRect) {
        _wrap_FSSquare_setInnerRect([self getCptr],[innerRect getCptr]);
    }
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSSquare_resetAppearanceStream([self getCptr]);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSSquare((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSCircle
-(void*)getCptr{
    return swigCPtr;
}

-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(unsigned int) getFillColor
{
    return _wrap_FSCircle_getFillColor([self getCptr]);
}

-(void) setFillColor : (unsigned int)fillColor
{
    _wrap_FSCircle_setFillColor([self getCptr], fillColor);
    
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSCircle_resetAppearanceStream([self getCptr]);
}

-(FSRectF*) getInnerRect
{
    void* cPtr = _wrap_FSCircle_getInnerRect([self getCptr]);
    FSRectF* ret = nil;
    if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void) setInnerRect: (FSRectF*) innerRect
{
    FSRectF *rect = [self getRect];
    if (innerRect.left < rect.left || innerRect.right > rect.right ||
        innerRect.bottom < rect.bottom || innerRect.top > rect.top) {
        return;
    }
    if (innerRect) {
        _wrap_FSCircle_setInnerRect([self getCptr],[innerRect getCptr]);
    }
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSCircle((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSLink
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(BOOL)resetAppearanceStream
{
  return _wrap_FSLink_resetAppearanceStream([self getCptr]); 
}

-(int)getQuadPointsCount
{
  return _wrap_FSLink_getQuadPointsCount([self getCptr]); 
}

-(FSQuadPoints*)getQuadPoints: (int)index
{
    void* cPtr = _wrap_FSLink_getQuadPoints([self getCptr], index);
     FSQuadPoints* ret = nil;
     if(cPtr) {
        ret = [[FSQuadPoints alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(enum FS_HIGHLIGHTINGMODE)getHighlightingMode
{
  return (enum FS_HIGHLIGHTINGMODE)_wrap_FSLink_getHighlightingMode([self getCptr]); 
}

-(void)setQuadPoints : (NSArray*) quadPoints
{
    if (!quadPoints || [quadPoints count] == 0) {
        return;
    }
    if (![[quadPoints objectAtIndex:0] isKindOfClass:[FSQuadPoints class]]) {
        return;
    }
    void* temp = 0;
    if (quadPoints && [quadPoints count] > 0) {
        int count = [quadPoints count];
        int sizeOfQuadPoint = sizeof(float)*8;
        temp = malloc(count*sizeOfQuadPoint);
        for (int i = 0; i < count; i++)
        {
            void* pQuadPoint = [(FSQuadPoints*)[quadPoints objectAtIndex:i] getCptr];
            memcpy((char*)temp+i*sizeOfQuadPoint, pQuadPoint, sizeOfQuadPoint);
        }
    }
    _wrap_FSLink_setQuadPoints([self getCptr], temp, [quadPoints count]);
    if(temp) free(temp);
}

-(FSAction*)getAction
{
    void* cPtr = _wrap_FSLink_getAction([self getCptr]);
     FSAction* ret = nil;
     if(cPtr) {
         enum FS_ACTIONTYPE type = (enum FS_ACTIONTYPE)_wrap_FSAction_getType(cPtr);
         switch (type) {
             case e_actionTypeGoto:
                 ret = [[FSGotoAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
             case e_actionTypeURI:
                 ret = [[FSURIAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
             default:
                 ret = [[FSAction alloc] initWithCptr:cPtr swigOwnCObject:NO];
                 break;
         }
     }
    return [ret autorelease]; 
}

-(void)setHighlightingMode : (enum FS_HIGHLIGHTINGMODE) mode
{
    _wrap_FSLink_setHighlightingMode([self getCptr], (int)mode);
}

-(void)setAction : (FSAction*) action
{
    _wrap_FSLink_setAction([self getCptr], [action getCptr]);
}
-(BOOL)removeAction
{
   return _wrap_FSLink_removeAction([self getCptr]);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSLink((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSFreeText

- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSFreeText_resetAppearanceStream([self getCptr]);
}

-(unsigned int)getFillColor
{
    return _wrap_FSFreeText_getFillColor([self getCptr]);
}

-(void)setFillColor: (unsigned int)fillColor
{
    _wrap_FSFreeText_setFillColor([self getCptr], fillColor);
}

-(int)getAlignment
{
    return _wrap_FSFreeText_getAlignment([self getCptr]);
}

-(void)setAlignment: (int)alignment
{
    _wrap_FSFreeText_setAlignment([self getCptr], alignment);
}

-(FSRectF*)getInnerRect
{
    void* cPtr = _wrap_FSFreeText_getInnerRect([self getCptr]);
    FSRectF* ret = nil;
    if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setInnerRect: (FSRectF*)innerRect
{
    FSRectF *rect = [self getRect];
    if (innerRect.left < rect.left || innerRect.right > rect.right ||
        innerRect.bottom < rect.bottom || innerRect.top > rect.top ||
        innerRect.left >rect.right || innerRect.bottom >rect.top ||
        innerRect.right < rect.left || innerRect.top< rect.bottom ||innerRect.left >= innerRect.right
        || innerRect.top <= innerRect.bottom) {
        return;
    }
    _wrap_FSFreeText_setInnerRect([self getCptr], [innerRect getCptr]);
}

-(FSDefaultAppearance*)getDefaultAppearance
{
    void* cPtr = _wrap_FSFreeText_getDefaultAppearance([self getCptr]);
    FSDefaultAppearance* ret = nil;
    if(cPtr) {
        ret = [[FSDefaultAppearance alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(BOOL)setDefaultAppearance: (FSDefaultAppearance*)defaultAP
{
    return _wrap_FSFreeText_setDefaultAppearance([self getCptr], [defaultAP getCptr]);
}

-(NSString*) getCalloutLineEndingStyle
{
    return _wrap_FSFreeText_getCalloutLineEndingStyle([self getCptr]);
}

-(void)setCalloutLineEndingStyle: (NSString*)startingStyle
{
    _wrap_FSFreeText_setCalloutLineEndingStyle([self getCptr], startingStyle);
}

-(int)getCalloutLinePointCount
{
    return _wrap_FSFreeText_getCalloutLinePointCount([self getCptr]);
}

-(FSPointF*)getCalloutLinePoint: (int)index
{
    void* cPtr = _wrap_FSFreeText_getCalloutLinePoint([self getCptr], index);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setCalloutLinePoints: (FSPointF*) point1 point2 : (FSPointF*) point2  point3 :(FSPointF*) point3
{
    _wrap_FSFreeText_setCalloutLinePoints([self getCptr], [point1 getCptr], [point2 getCptr], [point3 getCptr]);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFreeText((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSLine

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSLine_resetAppearanceStream([self getCptr]);
    
}

-(NSString*) getLineStartingStyle
{
    return _wrap_FSLine_getLineStartingStyle([self getCptr]);
    
}

-(void)setLineStartingStyle : (NSString*)startingStyle
{
    _wrap_FSLine_setLineStartingStyle([self getCptr], startingStyle);
}

-(NSString*)getLineEndingStyle
{
    return _wrap_FSLine_getLineEndingStyle([self getCptr]);
}

-(void)setLineEndingStyle : (NSString*)endingStyle
{
    _wrap_FSLine_setLineEndingStyle([self getCptr], endingStyle);
    
}

-(unsigned int) getStyleFillColor
{
    return _wrap_FSLine_getStyleFillColor([self getCptr]);
}

-(void) setStyleFillColor : (unsigned int) color
{
    _wrap_FSLine_setStyleFillColor([self getCptr], color);
    
}

-(FSPointF*)getStartPoint
{
    void* cPtr = _wrap_FSLine_getStartPoint([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}
-(void)setStartPoint : (FSPointF*) point
{
    _wrap_FSLine_setStartPoint([self getCptr], [point getCptr]);
    
}

-(FSPointF*) getEndPoint
{
    void* cPtr = _wrap_FSLine_getEndPoint([self getCptr]);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
    
}

-(void)setEndPoint : (FSPointF*) point
{
    _wrap_FSLine_setEndPoint([self getCptr], [point getCptr]);
}

-(BOOL)hasCaption
{
    return _wrap_FSline_hasCaption([self getCptr]);
}

-(void)enableCaption : (BOOL)cap
{
    _wrap_FSLine_enableCaption([self getCptr], cap);
}

-(NSString*)getCaptionPositionType
{
    return _wrap_FSLine_getCaptionPositionType([self getCptr]);
}

-(void)setCaptionPositionType : (NSString*)captionPos
{
    _wrap_FSLine_setCaptionPositionType([self getCptr], captionPos);
    
}

-(FSOffset*) getCaptionOffset
{
    void* cPtr = _wrap_FSLine_getCaptionOffset([self getCptr]);
    FSOffset* ret = nil;
    if(cPtr) {
        ret = [[FSOffset alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setCaptionOffset : (FSOffset*)offset
{
    _wrap_FSLine_setCaptionOffset([self getCptr], [offset getCptr]);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSLine((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
}


@end

@implementation FSInk
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSInk_resetAppearanceStream([self getCptr]);
}

-(FSPDFPath*)getInkList
{
    void* cPtr = _wrap_FSInk_getInkList([self getCptr]);
    FSPDFPath* ret = nil;
    if(cPtr) {
        ret = [[FSPDFPath alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(void)setInkList :(FSPDFPath*) inkList
{
    _wrap_FSInk_setInkList([self getCptr], [inkList getCptr]);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSInk([self getCptr]);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
}

@end


@implementation FSStamp
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSStamp_resetAppearanceStream([self getCptr]);
}

-(NSString*)getIconName
{
    return _wrap_FSStamp_getIconName([self getCptr]);
}

-(void)setIconName :(NSString*)iconName
{
    _wrap_FSStamp_setIconName([self getCptr], iconName);
}

-(void)setBitmap :(FSBitmap*) bitmap
{
    _wrap_FSStamp_setBitmap([self getCptr], [bitmap getCptr]);
}

-(void)setImagePath :(NSString*) imagePath
{
    _wrap_FSStamp_setImagePath([self getCptr], imagePath);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSStamp([self getCptr]);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
}


@end

@implementation FSPolygon
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSPolygon_resetAppearanceStream([self getCptr]);
}

-(unsigned int)getFillColor
{
    return _wrap_FSPolygon_getFillColor([self getCptr]);
}

-(void)setFillColor : (unsigned int)fillColor
{
    _wrap_FSPolygon_setFillColor([self getCptr], fillColor);
}

-(int)getVertexCount
{
    return  _wrap_FSPolygon_getVertexCount([self getCptr]);
}

-(FSPointF*)getVertex :(int)index
{
    void* cPtr = _wrap_FSPolygon_getVertex([self getCptr],index);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setVertexes :(NSArray<FSPointF*>*)vertexes
{
    if (![[vertexes objectAtIndex:0] isKindOfClass:[FSPointF class]]) {
        return;
    }
    void* temp = 0;
    if (vertexes && [vertexes count] > 0) {
        int count = [vertexes count];
        int sizeOfFSPointF = sizeof(float)*2;
        temp = (void*)malloc(count*sizeOfFSPointF);
        for (int i = 0; i < count; i++)
        {
            void* pFSPoint = [(FSPointF*)[vertexes objectAtIndex:i] getCptr];
            memcpy((char*)temp+i*sizeOfFSPointF, pFSPoint, sizeOfFSPointF);
        }
        _wrap_FSPolygon_setVertexes([self getCptr], temp, [vertexes count]);
    }
    if(temp) free(temp);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSPolygon([self getCptr]);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSPolyLine

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSPolyLine_resetAppearanceStream([self getCptr]);
}

-(unsigned int)getStyleFillColor
{
    return _wrap_FSPolyLine_getStyleFillColor([self getCptr]);
}

-(void)setStyleFillColor : (unsigned int)fillColor
{
    _wrap_FSPolyLine_setStyleFillColor([self getCptr], fillColor);
}

-(int)getVertexCount
{
    return _wrap_FSPolyLine_getVertexCount([self getCptr]);
}

-(FSPointF*)getVertex : (int)index
{
    void* cPtr = _wrap_FSPolyLine_getVertex([self getCptr],index);
    FSPointF* ret = nil;
    if(cPtr) {
        ret = [[FSPointF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setVertexes : (NSArray<FSPointF*>*)vertexes
{
    if (![[vertexes objectAtIndex:0] isKindOfClass:[FSPointF class]]) {
        return;
    }
    void* temp = 0;
    if (vertexes && [vertexes count] > 0) {
        int count = [vertexes count];
        int sizeOfFSPointF = sizeof(float)*2;
        temp = (void*)malloc(count*sizeOfFSPointF);
        for (int i = 0; i < count; i++)
        {
            void* pFSPoint = [(FSPointF*)[vertexes objectAtIndex:i] getCptr];
            memcpy((char*)temp+i*sizeOfFSPointF, pFSPoint, sizeOfFSPointF);
        }
        _wrap_FSPolyLine_setVertexes([self getCptr], temp, [vertexes count]);
    }
    if(temp) free(temp);
    
}

-(NSString*)getLineStartingStyle
{
    return _wrap_FSPolyLine_getLineStartingStyle([self getCptr]);
}

-(void)setLineStartingStyle : (NSString*)startingStyle
{
    _wrap_FSPolyLine_setLineStartingStyle([self getCptr], startingStyle);
}

-(NSString*)getLineEndingStyle
{
    return _wrap_FSPolyLine_getLineEndingStyle([self getCptr]);
}

-(void)setLineEndingStyle : (NSString*)endingStyle
{
    _wrap_FSPolyLine_setLineEndingStyle([self getCptr], endingStyle);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSPolyLine([self getCptr]);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
}

@end



@implementation FSCaret

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSCaret_resetAppearanceStream([self getCptr]);
}

-(FSRectF*) getInnerRect
{
    void* cPtr = _wrap_FSCaret_getInnerRect([self getCptr]);
    FSRectF* ret = nil;
    if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)setInnerRect : (FSRectF*) innerRect
{
    _wrap_FSCaret_setInnerRect([self getCptr], [innerRect getCptr]);
}

-(void)dealloc
{
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSCaret([self getCptr]);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
}

@end

@implementation FSFileAttachment
- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)resetAppearanceStream
{
    return _wrap_FSFileAttachment_resetAppearanceStream([self getCptr]);
}

-(BOOL)setFileSpec: (FSFileSpec*)fileSpecification
{
    return _wrap_FSFileAttachment_setFileSpec([self getCptr], [fileSpecification getCptr]);
}

-(FSFileSpec*)getFileSpec
{
    void* cPtr = _wrap_FSFileAttachment_getFileSpec([self getCptr]);
    FSFileSpec* ret = nil;
    if(cPtr) {
        ret = [[[FSFileSpec alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(NSString *)getIconName
{
    return _wrap_FSFileAttachment_getIconName([self getCptr]);
}

-(void)setIconName: (NSString *)iconName
{
    _wrap_FSFileAttachment_setIconName([self getCptr], iconName);
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFileAttachment((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSBookmark
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(FSBookmark*)getParent
{
    void* cPtr = _wrap_FSBookmark_getParent([self getCptr]);
     FSBookmark* ret = nil;
     if(cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSBookmark*)getFirstChild
{
    void* cPtr = _wrap_FSBookmark_getFirstChild([self getCptr]);
     FSBookmark* ret = nil;
     if(cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSBookmark*)getNextSibling
{
    void* cPtr = _wrap_FSBookmark_getNextSibling([self getCptr]);
     FSBookmark* ret = nil;
     if(cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSBookmark*)insert: (NSString*)title  pos: (enum FS_BOOKMARKPOSITION)pos
{
    void* cPtr = _wrap_FSBookmark_insert([self getCptr], title, (int)pos);
    FSBookmark* ret = nil;
    if(cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(BOOL)moveTo: (FSBookmark*)destBookmark  pos: (enum FS_BOOKMARKPOSITION)pos
{
    return _wrap_FSBookmark_moveTo([self getCptr], [destBookmark getCptr], (int)pos);
}

-(FSDestination*)getDestination
{
    void* cPtr = _wrap_FSBookmark_getDestination([self getCptr]);
     FSDestination* ret = nil;
     if(cPtr) {
        ret = [[FSDestination alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(void)setDestination: (FSDestination*)dest
{
 _wrap_FSBookmark_setDestination([self getCptr], [dest getCptr]);
}

-(NSString *)getTitle
{
  return _wrap_FSBookmark_getTitle([self getCptr]); 
}

-(void)setTitle: (NSString *)title
{
 _wrap_FSBookmark_setTitle([self getCptr], title);
}

-(unsigned int)getColor
{
  return _wrap_FSBookmark_getColor([self getCptr]); 
}

-(void)setColor: (unsigned int)color
{
 _wrap_FSBookmark_setColor([self getCptr], color);
}

-(unsigned int)getStyle
{
  return _wrap_FSBookmark_getStyle([self getCptr]); 
}

-(void)setStyle: (unsigned int)style
{
 _wrap_FSBookmark_setStyle([self getCptr], style);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSBookmark((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end

@implementation FSReadingBookmark
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(NSString*) getTitle
{
   return _wrap_FSReadingBookmark_getTitle([self getCptr]);
}

-(void)setTitle:(NSString*)title
{
     _wrap_FSReadingBookmark_setTitle([self getCptr], title);
}

-(int)getPageIndex
{
   return _wrap_FSReadingBookmark_getPageIndex([self getCptr]);
}

-(void)setPageIndex:(int)index
{
    _wrap_FSReadingBookmark_setPageIndex([self getCptr], index);
}

-(FSDateTime *)getDateTime:(BOOL)isCreationDate
{
    void* cPtr = _wrap_FSReadingBookmark_getDateTime([self getCptr], isCreationDate);
    FSDateTime* ret = nil;
    if(cPtr) {
        ret = [[[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES] autorelease];
    }
    return ret;
}

-(void)setDateTime:(FSDateTime*)dateTime isCreationDate:(BOOL)isCreationDate
{
    _wrap_FSReadingBookmark_setDateTime([self getCptr], [dateTime getCptr], isCreationDate);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSReadingBookmark((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


@implementation FSPageLabel
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(void)set: (int)start style: (enum FS_PAGELABELSTYLE)style prefix: (NSString *)prefix firstPageNumber: (int)firstPageNumber
{
 _wrap_FSPageLabel_set([self getCptr], start, (int)style, prefix, firstPageNumber);
}

-(void)setStart: (int)value
{
 _wrap_FSPageLabel_start_set([self getCptr], value);
}

-(int)getStart
{
  return _wrap_FSPageLabel_start_get([self getCptr]); 
}

-(void)setStyle: (enum FS_PAGELABELSTYLE)value
{
 _wrap_FSPageLabel_style_set([self getCptr], (int)value);
}

-(enum FS_PAGELABELSTYLE)getStyle
{
  return (enum FS_PAGELABELSTYLE)_wrap_FSPageLabel_style_get([self getCptr]); 
}

-(void)setPrefix: (NSString *)value
{
 _wrap_FSPageLabel_prefix_set([self getCptr], value);
}

-(NSString *)getPrefix
{
   NSString *ret = _wrap_FSPageLabel_prefix_get([self getCptr]);
    return [ret autorelease]; 
}

-(void)setFirstPageNumber: (int)value
{
 _wrap_FSPageLabel_firstPageNumber_set([self getCptr], value);
}

-(int)getFirstPageNumber
{
  return _wrap_FSPageLabel_firstPageNumber_get([self getCptr]); 
}

-(id)init
{
 
	if((self = [super init])) {
		void* cptr = _wrap_new_FSPageLabel();
        swigCPtr = cptr;
        swigCMemOwn = YES;
	}
	return self;

}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPageLabel((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end

@implementation FSPDFDoc
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFDoc*)createFromFilePath: (NSString *)path
{
    void* cPtr = _wrap_FSPDFDoc_createFromFilePath(path);
     FSPDFDoc* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDoc alloc] initWithCptr:cPtr swigOwnCObject:YES];
        [[FSRecoveryManager sharedInstance] setFilePath:ret FilePath:path];
     }
    return [ret autorelease]; 
}

+(FSPDFDoc*)createFromMemory: (NSData *)buffer
{
    void* cPtr = _wrap_FSPDFDoc_createFromMemory(buffer, buffer.length);
     FSPDFDoc* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDoc alloc] initWithCptr:cPtr swigOwnCObject:YES];
        [[FSRecoveryManager sharedInstance] setFileBuffer:ret FileBuff:buffer];
     }
    return [ret autorelease]; 
}

+(NSData *)ConvertPDF2OFD: (NSData *)buffer;
{
    NSData*data  = _wrap_FSPDFDoc_ConvertPDF2OFD(buffer, buffer.length);
    return data;
}
+(NSData *)ConvertOFD2PDF: (NSData *)buffer;
{
    NSData*data  = _wrap_FSPDFDoc_ConvertOFD2PDF(buffer, buffer.length);
    return data;
}
+(BOOL)ConvertPDF2OFDFromFilePath: (NSString *)from To:(NSString*)to
{
    BOOL ref = _wrap_FSPDFDoc_ConvertPDF2OFDFromFilePath(from, to);
    return YES;
}
+(BOOL)ConvertOFD2PDFFromFilePath: (NSString *)from To:(NSString*)to
{
    BOOL ref = _wrap_FSPDFDoc_ConvertOFD2PDFFromFilePath(from, to);
    return YES;
}
+(FSSealImage*)GetImageWithPassword:(NSString*)password SealID:(NSString*)sealID;
{
    void* cPtr = _wrap_FSPDFDoc_GetImageWithPassword(password,sealID);
        FSSealImage* ret = nil;
        if(cPtr) {
           ret = [[FSSealImage alloc] initWithCptr:cPtr swigOwnCObject:YES];
        }
       return [ret autorelease];
}

+(FSPDFDoc*)createFromHandler: (FSFileReadCallback*)fileRead
{
    void* cPtr = _wrap_FSPDFDoc_createFromHandler(fileRead);
     FSPDFDoc* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDoc alloc] initWithCptr:cPtr swigOwnCObject:YES];
        [[FSRecoveryManager sharedInstance] setFileRead:ret FileRead:fileRead];
     }
    return [ret autorelease]; 
}

-(enum FS_ERRORCODE)load: (NSString *)password
{
  [[FSRecoveryManager sharedInstance] setPassword:self FilePass:password];
  return (enum FS_ERRORCODE)_wrap_FSPDFDoc_load([self getCptr], password, password.length);
}

-(BOOL)isEncrypted
{
  return _wrap_FSPDFDoc_isEncrypted([self getCptr]); 
}

-(BOOL)isModified
{
  return _wrap_FSPDFDoc_isModified([self getCptr]); 
}

-(enum FS_PASSWORDTYPE)getPasswordType
{
  return (enum FS_PASSWORDTYPE)_wrap_FSPDFDoc_getPasswordType([self getCptr]); 
}

-(enum FS_ENCRYPTTYPE)getEncryptionType
{
  return (enum FS_ENCRYPTTYPE)_wrap_FSPDFDoc_getEncryptionType([self getCptr]); 
}

-(enum FS_PASSWORDTYPE)checkPassword: (NSString *)password
{
  return (enum FS_PASSWORDTYPE)_wrap_FSPDFDoc_checkPassword([self getCptr], password, password.length);
}

-(BOOL)saveAs: (NSString *)filePath saveFlags:(unsigned int)saveFlags
{
  return _wrap_FSPDFDoc_saveAs([self getCptr], filePath, saveFlags);
}

-(FSBookmark*) createFirstBookmark
{
    FSBookmark* ret = nil;
    void* cPtr = _wrap_FSPDFDoc_creatFirstBookmark([self getCptr]);
    if (cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
    
}
-(BOOL)removeBookmark: (FSBookmark*) bookmark
{
    return _wrap_FSPDFDoc_removeBookmark([self getCptr],[bookmark getCptr]);
    
}

-(FSBookmark*)getFirstBookmark
{
    void* cPtr = _wrap_FSPDFDoc_getFirstBookmark([self getCptr]);
     FSBookmark* ret = nil;
     if(cPtr) {
        ret = [[FSBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(int)getPageCount
{
  return _wrap_FSPDFDoc_getPageCount([self getCptr]); 
}

-(FSPDFPage*)getPage: (int)pageIndex
{
    void* cPtr = _wrap_FSPDFDoc_getPage([self getCptr], pageIndex);
     FSPDFPage* ret = nil;
     if(cPtr) {
        ret = [[FSPDFPage alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(BOOL)closePage: (int)pageIndex
{
  return _wrap_FSPDFDoc_closePage([self getCptr], pageIndex); 
}

-(enum FS_DISPLAYMODE)getDisplayMode
{
  return (enum FS_DISPLAYMODE)_wrap_FSPDFDoc_getDisplayMode([self getCptr]); 
}

-(FSPDFDictionary*)getCatalog
{
    void* cPtr = _wrap_FSPDFDoc_getCatalog([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFDictionary*)getTrailer
{
    void* cPtr = _wrap_FSPDFDoc_getTrailer([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFDictionary*)getInfo
{
    void* cPtr = _wrap_FSPDFDoc_getInfo([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFDictionary*)getEncryptDict
{
    void* cPtr = _wrap_FSPDFDoc_getEncryptDict([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFObject*)getIndirectObject: (unsigned int)objnum
{
    void* cPtr = _wrap_FSPDFDoc_getIndirectObject([self getCptr], objnum);
     FSPDFObject* ret = nil;
     if(cPtr) {
         ret = creatFSObjectFromCObject(cPtr);
     }
    return [ret autorelease]; 
}

-(unsigned int)addIndirectObject: (FSPDFObject*)pObj
{
  return _wrap_FSPDFDoc_addIndirectObject([self getCptr], [pObj getCptr]); 
}

-(void)deleteIndirectObject: (unsigned int)objnum
{
 _wrap_FSPDFDoc_deleteIndirectObject([self getCptr], objnum);
}

-(unsigned int)getUserPermissions
{
  return _wrap_FSPDFDoc_getUserPermissions([self getCptr]); 
}

-(BOOL)isWrapper
{
  return _wrap_FSPDFDoc_isWrapper([self getCptr]); 
}

-(int)getWrapperOffset
{
  return _wrap_FSPDFDoc_getWrapperOffset([self getCptr]); 
}

-(BOOL)hasMetadataKey: (NSString *)key
{
  return _wrap_FSPDFDoc_hasMetadataKey([self getCptr], key); 
}

-(FSDateTime*)getCreationDateTime
{
    void* cPtr = _wrap_FSPDFDoc_getCreationDateTime([self getCptr]);
     FSDateTime* ret = nil;
     if(cPtr) {
        ret = [[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSDateTime*)getModifiedDateTime
{
    void* cPtr = _wrap_FSPDFDoc_getModifiedDateTime([self getCptr]);
     FSDateTime* ret = nil;
     if(cPtr) {
        ret = [[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(NSString *)getMetadataValue: (NSString *)key
{
  return _wrap_FSPDFDoc_getMetadataValue([self getCptr], key); 
}

-(int)getPageLabelRangeCount
{
  return _wrap_FSPDFDoc_getPageLabelRangeCount([self getCptr]); 
}

-(FSPageLabel*)getPageLabelInfo: (int)index
{
    void* cPtr = _wrap_FSPDFDoc_getPageLabelInfo([self getCptr], index);
     FSPageLabel* ret = nil;
     if(cPtr) {
        ret = [[FSPageLabel alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(BOOL)hasForm
{
    return _wrap_FSPDFDoc_hasForm([self getCptr]);
}

-(FSForm*)getForm
{
    void* cPtr = _wrap_FSPDFDoc_getForm([self getCptr]);
    FSForm* ret = nil;
    if(cPtr) {
        ret = [[[FSForm alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(int)getReadingBookmarkCount
{
 return _wrap_FSPDFDoc_getReadingBookmarkCount([self getCptr]);
}

-(FSReadingBookmark*)getReadingBookmark:(int)index
{
    void* cPtr = _wrap_FSPDFDoc_getReadingBookmark([self getCptr], index);
    FSReadingBookmark* ret = nil;
    if(cPtr) {
        ret = [[[FSReadingBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(FSReadingBookmark*)insertReadingBookmark: (int)readingBookmarkIndex title:(NSString*)title pageIndex:(int)destPageIndex
{
    void* cPtr = _wrap_FSPDFDoc_insertReadingBookmark([self getCptr], readingBookmarkIndex, title, destPageIndex);
    FSReadingBookmark* ret = nil;
    if(cPtr) {
        ret = [[[FSReadingBookmark alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(BOOL)removeReadingBookmark:(FSReadingBookmark*)readingBookmark
{
    return _wrap_FSPDFDoc_removeReadingBookmark([self getCptr],[readingBookmark getCptr]);
}

-(int)getSignatureCount
{
    return _wrap_FSPDFDoc_getSignatureCount([self getCptr]);
}

-(FSSignature*)getSignature: (int)index
{
    void* cPtr = _wrap_FSPDFDoc_getSignature([self getCptr], index);
    FSSignature* ret = nil;
    if(cPtr) {
        ret = [[[FSSignature alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFDoc((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFObject
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFObject*)createFromBoolean: (BOOL)boolean
{
    void* cPtr = _wrap_FSPDFObject_createFromBoolean(boolean);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createFromFloat: (float)f
{
    void* cPtr = _wrap_FSPDFObject_createFromFloat(f);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createFromInteger: (int)integer
{
    void* cPtr = _wrap_FSPDFObject_createFromInteger(integer);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createFromString: (NSString *)string
{
    void* cPtr = _wrap_FSPDFObject_createFromString(string);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createFromName: (NSString *)name
{
    void* cPtr = _wrap_FSPDFObject_createFromName(name);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createFromDateTime: (FSDateTime*)dateTime
{
    void* cPtr = _wrap_FSPDFObject_createFromDateTime([dateTime getCptr]);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

+(FSPDFObject*)createReference: (FSPDFDoc*)pDoc objnum: (unsigned int)objnum
{
    void* cPtr = _wrap_FSPDFObject_createReference([pDoc getCptr], objnum);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = [[FSPDFObject alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFObject*)cloneObject
{
    void* cPtr = _wrap_FSPDFObject_cloneObject([self getCptr]);
     FSPDFObject* ret = nil;
     if(cPtr) {
         ret = creatFSObjectFromCObject(cPtr);
     }
    return [ret autorelease]; 
}

-(enum FS_PDFOBJECTTYPE)getType
{
  return (enum FS_PDFOBJECTTYPE)_wrap_FSPDFObject_getType([self getCptr]); 
}

-(unsigned int)getObjNum
{
  return _wrap_FSPDFObject_getObjNum([self getCptr]); 
}

-(int)getInteger
{
  return _wrap_FSPDFObject_getInteger([self getCptr]);
}

-(float)getFloat
{
  return _wrap_FSPDFObject_getFloat([self getCptr]);
}

-(BOOL)getBoolean
{
  return _wrap_FSPDFObject_getBoolean([self getCptr]);
}

-(FSMatrix*)getMatrix
{
    void* cPtr = _wrap_FSPDFObject_getMatrix([self getCptr]);
     FSMatrix* ret = nil;
     if(cPtr) {
        ret = [[FSMatrix alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSRectF*)getRect
{
    void* cPtr = _wrap_FSPDFObject_getRect([self getCptr]);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSPDFObject*)getDirectObject
{
    void* cPtr = _wrap_FSPDFObject_getDirectObject([self getCptr]);
     FSPDFObject* ret = nil;
     if(cPtr) {
         ret = creatFSObjectFromCObject(cPtr);
     }
    return [ret autorelease]; 
}

-(FSDateTime*)getDateTime
{
    void* cPtr = _wrap_FSPDFObject_getDateTime([self getCptr]);
     FSDateTime* ret = nil;
     if(cPtr) {
        ret = [[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(NSString *)getString
{
  return _wrap_FSPDFObject_getString([self getCptr]); 
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFObject((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFStream
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFStream*)create: (FSPDFDictionary*)dictionary
{
    void* cPtr = _wrap_FSPDFStream_create([dictionary getCptr]);
    FSPDFStream* ret = nil;
    if(cPtr) {
        ret = [[FSPDFStream alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(FSPDFDictionary*)getDictionary
{
    void* cPtr = _wrap_FSPDFStream_getDictionary([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(unsigned int)getDataSize: (BOOL)rawData
{
  return _wrap_FSPDFStream_getDataSize([self getCptr], rawData); 
}

-(NSData *)getData: (BOOL)rawData bufLen: (int)bufLen
{
  return _wrap_FSPDFStream_getData([self getCptr], rawData, bufLen); 
}

-(void)setData: (NSData *)buffer
{
 _wrap_FSPDFStream_setData([self getCptr], buffer, buffer.length);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFStream((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFArray
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFArray*)create
{
    void* cPtr = _wrap_FSPDFArray_create();
    FSPDFArray* ret = nil;
    if(cPtr) {
        ret = [[FSPDFArray alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

+(FSPDFArray*)createFromMatrix: (FSMatrix*)matrix
{
    void* cPtr = _wrap_FSPDFArray_createFromMatrix([matrix getCptr]);
    FSPDFArray* ret = nil;
    if(cPtr) {
        ret = [[FSPDFArray alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

+(FSPDFArray*)createFromRect: (FSRectF*)rect
{
    void* cPtr = _wrap_FSPDFArray_createFromRect([rect getCptr]);
    FSPDFArray* ret = nil;
    if(cPtr) {
        ret = [[FSPDFArray alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(int)getElementCount
{
  return _wrap_FSPDFArray_getElementCount([self getCptr]); 
}

-(FSPDFObject*)getElement: (int)index
{
    void* cPtr = _wrap_FSPDFArray_getElement([self getCptr], index);
     FSPDFObject* ret = nil;
     if(cPtr) {
        ret = creatFSObjectFromCObject(cPtr);
     }
    return [ret autorelease]; 
}

-(void)addElement: (FSPDFObject*)element
{
 _wrap_FSPDFArray_addElement([self getCptr], [element getCptr]);
}

-(void)insertAt: (int)index element: (FSPDFObject*)element
{
 _wrap_FSPDFArray_insertAt([self getCptr], index, [element getCptr]);
}

-(void)setAt: (int)index element: (FSPDFObject*)element
{
 _wrap_FSPDFArray_setAt([self getCptr], index, [element getCptr]);
}

-(void)removeAt: (int)index
{
 _wrap_FSPDFArray_removeAt([self getCptr], index);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFArray((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFDictionary
- (void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFDictionary*)create
{
    void* cPtr = _wrap_FSPDFDictionary_create();
    FSPDFDictionary* ret = nil;
    if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
    }
    return [ret autorelease];
}

-(BOOL)hasKey: (NSString *)key
{
  return _wrap_FSPDFDictionary_hasKey([self getCptr], key); 
}

-(FSPDFObject*)getElement: (NSString *)key
{
    void* cPtr = _wrap_FSPDFDictionary_getElement([self getCptr], key);
     FSPDFObject* ret = nil;
     if(cPtr) {
         
         ret = creatFSObjectFromCObject(cPtr);
     }
    return [ret autorelease]; 
}

-(NSString *)getKey: (void*)pos
{
  return _wrap_FSPDFDictionary_getKey([self getCptr], pos);
}

-(FSPDFObject*)getValue: (void*)pos
{
    void* cPtr = _wrap_FSPDFDictionary_getValue([self getCptr], pos);
     FSPDFObject* ret = nil;
     if(cPtr) {
         ret = creatFSObjectFromCObject(cPtr);
             }
    return [ret autorelease]; 
}

-(void*)moveNext: (void*)pos
{
    return _wrap_FSPDFDictionary_moveNext([self getCptr], pos);
}

-(void)setAt: (NSString *)key object: (FSPDFObject*)object
{
 _wrap_FSPDFDictionary_setAt([self getCptr], key, [object getCptr]);
}

-(void)removeAt: (NSString *)key
{
 _wrap_FSPDFDictionary_removeAt([self getCptr], key);
}

-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFDictionary((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFPage
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(FSPDFDoc*)getDocument
{
    void* cPtr = _wrap_FSPDFPage_getDocument([self getCptr]);
     FSPDFDoc* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDoc alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(FSPDFDictionary*)getDict
{
    void* cPtr = _wrap_FSPDFPage_getDict([self getCptr]);
     FSPDFDictionary* ret = nil;
     if(cPtr) {
        ret = [[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(BOOL)isParsed
{
  return _wrap_FSPDFPage_isParsed([self getCptr]); 
}

-(enum FS_PROGRESSSTATE)startParse: (unsigned int)flag pause: (FSPauseCallback*)pause isReparse: (BOOL)isReparse
{
  return (enum FS_PROGRESSSTATE)_wrap_FSPDFPage_startParse([self getCptr], flag, pause, isReparse);
}

-(enum FS_PROGRESSSTATE)continueParse
{
  return (enum FS_PROGRESSSTATE)_wrap_FSPDFPage_continueParse([self getCptr]); 
}

-(int)getIndex
{
  return _wrap_FSPDFPage_getIndex([self getCptr]); 
}

-(float)getHeight
{
  return _wrap_FSPDFPage_getHeight([self getCptr]); 
}

-(float)getWidth
{
  return _wrap_FSPDFPage_getWidth([self getCptr]); 
}

-(enum FS_ROTATION)getRotation
{
  return (enum FS_ROTATION)_wrap_FSPDFPage_getRotation([self getCptr]); 
}

-(FSBitmap*)loadThumbnail
{
    void* cPtr = _wrap_FSPDFPage_loadThumbnail([self getCptr]);
     FSBitmap* ret = nil;
     if(cPtr) {
        ret = [[FSBitmap alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSMatrix*)getDisplayMatrix: (int)xPos yPos: (int)yPos xSize: (int)xSize ySize: (int)ySize rotate: (enum FS_ROTATION)rotate
{
    void* cPtr = _wrap_FSPDFPage_getDisplayMatrix([self getCptr], xPos, yPos, xSize, ySize, (int)rotate);
     FSMatrix* ret = nil;
     if(cPtr) {
        ret = [[FSMatrix alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSRectF*)calcContentBBox: (enum FS_CALCMARGINMODE)mode
{
    void* cPtr = _wrap_FSPDFPage_calcContentBBox([self getCptr], (int)mode);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSAnnot*)getAnnot: (int)index
{
    void* cPtr = _wrap_FSPDFPage_getAnnot([self getCptr], index);
    FSAnnot* ret = nil;
    if(cPtr) {
        //TO-DO: to improve it
        ret = creatFSAnnotFromCAnnot(cPtr);
        
    }
    return [ret autorelease];
}

-(int)getAnnotCount
{
  return _wrap_FSPDFPage_getAnnotCount([self getCptr]); 
}



-(FSAnnot*)getAnnotAtPos: (FSPointF*)pos tolerance: (float)tolerance
{
    void* cPtr = _wrap_FSPDFPage_getAnnotAtPos([self getCptr], [pos getCptr], tolerance);
     FSAnnot* ret = nil;
     if(cPtr) {
         //TO-DO: to improve it
         ret = creatFSAnnotFromCAnnot(cPtr);
              }
    return [ret autorelease]; 
}

-(FSAnnot*)getAnnotAtDevicePos:(const FSMatrix*)matrix position: (FSPointF*)pos tolerance: (float)tolerance
{
    void* cPtr = _wrap_FSPDFPage_getAnnotAtDevicePos([self getCptr], [matrix getCptr], [pos getCptr], tolerance);
    FSAnnot* ret = nil;
    if(cPtr) {
        //TO-DO: to improve it
        ret = creatFSAnnotFromCAnnot(cPtr);
           }
    return [ret autorelease];
}

-(FSAnnot*)addAnnot: (enum FS_ANNOTTYPE)annotType rect: (FSRectF*)rect
{
    void* cPtr = _wrap_FSPDFPage_addAnnot([self getCptr], (int)annotType, [rect getCptr]);
     FSAnnot* ret = nil;
     if(cPtr) {
         
         //TO-DO: to improve it
         ret = creatFSAnnotFromCAnnot(cPtr);
             }
    return [ret autorelease]; 
}

-(BOOL)removeAnnot: (FSAnnot*)annot
{
  return _wrap_FSPDFPage_removeAnnot([self getCptr], [annot getCptr]); 
}

-(BOOL)hasTransparency
{
    return _wrap_FSPDFPage_hasTransparency([self getCptr]);
}

-(BOOL)flatten:(BOOL)isDisplay options:(unsigned int)options
{
    return _wrap_FSPDFPage_flatten([self getCptr], isDisplay, options);
}

-(BOOL)setAnnotGroup : (NSArray<FSMarkup*>*) annotArray  headerIndex : (int)headerIndex
{
    if (![[annotArray objectAtIndex:0] isKindOfClass:[FSMarkup class]]) {
        return NO;
    }
    void** temp = 0;
    if (annotArray && [annotArray count] > 0) {
        int count = [annotArray count];
        int sizeOfFSMarkup = sizeof(FSMarkup*);
        temp =(void**) malloc(count*sizeOfFSMarkup);
        for (int i = 0; i < count; i++)
        {
          //  void* pannotArray = [(FSMarkup*)[annotArray objectAtIndex:i] getCptr];
           // memcpy((char*)temp+i*sizeOfFSMarkup, pannotArray, sizeOfFSMarkup);
            temp[i]=(void*)[(FSMarkup*)[annotArray objectAtIndex:i] getCptr];
        }
    }
    BOOL result  = _wrap_FSPDFPage_setAnnotGroup([self getCptr], temp, (int)[annotArray count], headerIndex);
    if (temp) free(temp);
    return result;
}

-(FSSignature*)addSignature: (FSRectF*)rect
{
    void* cPtr = _wrap_FSPDFPage_addSignature([self getCptr], [rect getCptr]);
    FSSignature* ret = nil;
    if(cPtr) {
        ret = [[[FSSignature alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFPage((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end

@implementation FSBitmap
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSBitmap*)create: (int)width height: (int)height format: (enum FS_DIBFORMAT)format buffer: (unsigned char *)buffer pitch: (int)pitch
{
    void* cPtr = _wrap_FSBitmap_create(width, height, (int)format, buffer, pitch);
     FSBitmap* ret = nil;
     if(cPtr) {
        ret = [[FSBitmap alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSBitmap*)clone: (FSRectI*)clip
{
    void* cPtr = _wrap_FSBitmap_clone([self getCptr], [clip getCptr]);
     FSBitmap* ret = nil;
     if(cPtr) {
        ret = [[FSBitmap alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(int)getWidth
{
  return _wrap_FSBitmap_getWidth([self getCptr]); 
}

-(int)getHeight
{
  return _wrap_FSBitmap_getHeight([self getCptr]); 
}

-(int)getPitch
{
  return _wrap_FSBitmap_getPitch([self getCptr]); 
}

-(int)getBpp
{
  return _wrap_FSBitmap_getBpp([self getCptr]); 
}

-(NSData *)getBuffer
{
  return _wrap_FSBitmap_getBuffer([self getCptr]); 
}

-(enum FS_DIBFORMAT)getFormat
{
  return (enum FS_DIBFORMAT)_wrap_FSBitmap_getFormat([self getCptr]); 
}

-(void)fillRect: (unsigned int)color rect: (FSRectI*)rect
{
 _wrap_FSBitmap_fillRect([self getCptr], color, [rect getCptr]);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSBitmap((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSRenderer
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSRenderer*)create: (FSBitmap*)bitmap rgbOrder: (BOOL)rgbOrder
{
    void* cPtr = _wrap_FSRenderer_create([bitmap getCptr], rgbOrder);
     FSRenderer* ret = nil;
     if(cPtr) {
        ret = [[FSRenderer alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

+(FSRenderer*)createFromContext: (CGContextRef)context deviceType: (enum FS_DEVICETYPE)deviceType
{
    void* cPtr = _wrap_FSRenderer_createFromContext(context, (int)deviceType);
     FSRenderer* ret = nil;
     if(cPtr) {
        ret = [[FSRenderer alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(enum FS_PROGRESSSTATE)startRender: (FSPDFPage*)page matrix: (FSMatrix*)matrix pause: (FSPauseCallback*)pause
{
  return (enum FS_PROGRESSSTATE)_wrap_FSRenderer_startRender([self getCptr], [page getCptr], [matrix getCptr], pause);
}

-(enum FS_PROGRESSSTATE)continueRender
{
  return (enum FS_PROGRESSSTATE)_wrap_FSRenderer_continueRender([self getCptr]); 
}

-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix*)matrix
{
  return _wrap_FSRenderer_renderAnnot([self getCptr], [annot getCptr], [matrix getCptr]); 
}

-(void)setRenderContent: (unsigned int)renderContentFlag
{
 _wrap_FSRenderer_setRenderContent([self getCptr], renderContentFlag);
}

-(void)setTransformAnnotIcon: (BOOL)transformAnnotIcon
{
 _wrap_FSRenderer_setTransformAnnotIcon([self getCptr], transformAnnotIcon);
}

-(void)setColorMode: (enum FS_RENDERCOLORMODE)colorMode
{
 _wrap_FSRenderer_setColorMode([self getCptr], (int)colorMode);
}

-(void)setMappingModeColors: (unsigned int)backColor foreColor: (unsigned int)foreColor
{
 _wrap_FSRenderer_setMappingModeColors([self getCptr], backColor, foreColor);
}

-(void)setClearType: (BOOL)bClearType
{
 _wrap_FSRenderer_setClearType([self getCptr], bClearType);
}

-(void)setPrintGraphicText: (BOOL)bPrintGraphicText
{
 _wrap_FSRenderer_setPrintGraphicText([self getCptr], bPrintGraphicText);
}

-(void)setForceDownSample: (BOOL)bForceDownSample
{
 _wrap_FSRenderer_setForceDownSample([self getCptr], bForceDownSample);
}

-(void)setForceHalftone: (BOOL)isForceHalftone
{
 _wrap_FSRenderer_setForceHalftone([self getCptr], isForceHalftone);
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSRenderer((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFTextSearch
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFTextSearch*)create: (FSPDFDoc*)pdfDoc pause: (FSPauseCallback*)pause
{
    void* cPtr = _wrap_FSPDFTextSearch_create([pdfDoc getCptr], pause);
     FSPDFTextSearch* ret = nil;
     if(cPtr) {
        ret = [[FSPDFTextSearch alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(BOOL)setKeyWords: (NSString *)keywords
{
    return _wrap_FSPDFTextSearch_setKeyWords([self getCptr], keywords);
}

-(BOOL)setStartPage: (int)startPageIndex
{
  return _wrap_FSPDFTextSearch_setStartPage([self getCptr], startPageIndex);
}

-(BOOL)setFlag: (unsigned int)flag
{
    return _wrap_FSPDFTextSearch_setFlag([self getCptr], flag);
}

-(BOOL)findNext
{
  return _wrap_FSPDFTextSearch_findNext([self getCptr]); 
}

-(BOOL)findPrev
{
  return _wrap_FSPDFTextSearch_findPrev([self getCptr]); 
}

-(int)getMatchRectCount
{
  return _wrap_FSPDFTextSearch_getMatchRectCount([self getCptr]); 
}

-(FSRectF*)getMatchRect: (int)index
{
    void* cPtr = _wrap_FSPDFTextSearch_getMatchRect([self getCptr], index);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(int)getMatchPageIndex
{
  return _wrap_FSPDFTextSearch_getMatchPageIndex([self getCptr]); 
}

-(NSString *)getMatchSentence
{
  return _wrap_FSPDFTextSearch_getMatchSentence([self getCptr]); 
}

-(int)getMatchSentenceStartIndex
{
  return _wrap_FSPDFTextSearch_getMatchSentenceStartIndex([self getCptr]); 
}

-(int)getMatchStartCharIndex
{
  return _wrap_FSPDFTextSearch_getMatchStartCharIndex([self getCptr]); 
}

-(int)getMatchEndCharIndex
{
  return _wrap_FSPDFTextSearch_getMatchEndCharIndex([self getCptr]); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFTextSearch((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFTextSelect
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFTextSelect*)create: (FSPDFPage*)pPage
{
    void* cPtr = _wrap_FSPDFTextSelect_create([pPage getCptr]);
     FSPDFTextSelect* ret = nil;
     if(cPtr) {
        ret = [[FSPDFTextSelect alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(FSPDFPage*)getPage
{
    void* cPtr = _wrap_FSPDFTextSelect_getPage([self getCptr]);
     FSPDFPage* ret = nil;
     if(cPtr) {
        ret = [[FSPDFPage alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(int)getCharCount
{
  return _wrap_FSPDFTextSelect_getCharCount([self getCptr]); 
}

-(NSString *)getChars: (int)startIndex count: (int)count
{
  return _wrap_FSPDFTextSelect_getChars([self getCptr], startIndex, count); 
}

-(int)getIndexAtPos: (float)x y: (float)y tolerance: (float)tolerance
{
  return _wrap_FSPDFTextSelect_getIndexAtPos([self getCptr], x, y, tolerance); 
}

-(NSString *)getTextInRect: (FSRectF*)rect
{
  return _wrap_FSPDFTextSelect_getTextInRect([self getCptr], [rect getCptr]); 
}

-(NSRange)getWordAtPos: (float)x y: (float)y tolerance: (float)tolerance
{
    NSRange range = {0, 0};
    int startIndex = 0;
    int count = 0;
    BOOL bRet = _wrap_FSPDFTextSelect_getWordAtPos([self getCptr], x, y, tolerance, &startIndex, &count);
    if (bRet)
    {
        range.location = startIndex;
        range.length = count;
    }
    return range;
}

-(int)getTextRectCount: (int)start count: (int)count
{
  return _wrap_FSPDFTextSelect_getTextRectCount([self getCptr], start, count);
}

-(FSRectF*)getTextRect: (int)rectIndex
{
    void* cPtr = _wrap_FSPDFTextSelect_getTextRect([self getCptr], rectIndex);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(enum FS_ROTATION)getBaselineRotation: (int)rectIndex
{
  return (enum FS_ROTATION)_wrap_FSPDFTextSelect_getBaselineRotation([self getCptr], rectIndex); 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFTextSelect((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFTextLink
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

-(NSString *)getURI
{
  return _wrap_FSPDFTextLink_getURI([self getCptr]); 
}

-(int)getStartCharIndex
{
  return _wrap_FSPDFTextLink_getStartCharIndex([self getCptr]); 
}

-(int)getEndCharIndex
{
  return _wrap_FSPDFTextLink_getEndCharIndex([self getCptr]); 
}

-(int)getRectCount
{
  return _wrap_FSPDFTextLink_getRectCount([self getCptr]); 
}

-(FSRectF*)getRect: (int)rectIndex
{
    void* cPtr = _wrap_FSPDFTextLink_getRect([self getCptr], rectIndex);
     FSRectF* ret = nil;
     if(cPtr) {
        ret = [[FSRectF alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFTextLink((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end


@implementation FSPDFPageLinks
-(void*)getCptr {
	return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
	if((self = [super init])) {
		swigCPtr = cptr;
        swigCMemOwn = ownCObject;
	}
	return self;
}

+(FSPDFPageLinks*)create: (FSPDFPage*)page
{
    void* cPtr = _wrap_FSPDFPageLinks_create([page getCptr]);
     FSPDFPageLinks* ret = nil;
     if(cPtr) {
        ret = [[FSPDFPageLinks alloc] initWithCptr:cPtr swigOwnCObject:YES];
     }
    return [ret autorelease]; 
}

-(int)getTextLinkCount
{
  return _wrap_FSPDFPageLinks_getTextLinkCount([self getCptr]); 
}

-(FSPDFTextLink*)getTextLink: (int)index
{
    void* cPtr = _wrap_FSPDFPageLinks_getTextLink([self getCptr], index);
     FSPDFTextLink* ret = nil;
     if(cPtr) {
        ret = [[FSPDFTextLink alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}

-(int)getLinkAnnotCount
{
  return _wrap_FSPDFPageLinks_getLinkAnnotCount([self getCptr]); 
}

-(FSLink*)getLinkAnnot: (int)index
{
    void* cPtr = _wrap_FSPDFPageLinks_getLinkAnnot([self getCptr], index);
     FSLink* ret = nil;
     if(cPtr) {
        ret = [[FSLink alloc] initWithCptr:cPtr swigOwnCObject:NO];
     }
    return [ret autorelease]; 
}


-(void)dealloc{

  if (swigCPtr != NULL) {
    if (swigCMemOwn) {
        _wrap_delete_FSPDFPageLinks((void*)swigCPtr);
        swigCMemOwn = NO;
    }
    swigCPtr = NULL;
  }
  [super dealloc];

}

@end

@implementation FSForm
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(int)getFieldCount: (NSString *)filter
{
    return _wrap_FSForm_getFieldCount([self getCptr], filter);
}

-(FSFormField*)getField: (NSString *)filter index: (int)index
{
    void* cPtr = _wrap_FSForm_getField([self getCptr], filter, index);
    FSFormField* ret = nil;
    if(cPtr) {
        ret = [[[FSFormField alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(FSFormFiller*)getFormFiller
{
    void* cPtr = _wrap_FSForm_getFormFiller([self getCptr]);
    FSFormFiller* ret = nil;
    if(cPtr) {
        ret = [[[FSFormFiller alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(BOOL)reset
{
    return _wrap_FSForm_reset([self getCptr]);
}

-(BOOL)exportToXML: (NSString *)path
{
    return _wrap_FSForm_exportToXML([self getCptr], path);
}

-(BOOL)importFromXML: (NSString *)path
{
    return _wrap_FSForm_importFromXML([self getCptr], path);
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSForm((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


@implementation FSFormField
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(enum FS_FORMFIELDTYPE)getType
{
    return (enum FS_FORMFIELDTYPE)_wrap_FSFormField_getType([self getCptr]);
}

-(enum FS_FORMFIELDFLAGS)getFlags
{
    return (enum FS_FORMFIELDFLAGS)_wrap_FSFormField_getFlags([self getCptr]);
}

-(NSString *)getName
{
    return _wrap_FSFormField_getName([self getCptr]);
}

-(NSString *)getDefaultValue
{
    return _wrap_FSFormField_getDefaultValue([self getCptr]);
}

-(NSString *)getValue
{
    return _wrap_FSFormField_getValue([self getCptr]);
}

-(int)getControlCount: (FSPDFPage*)page
{
    return _wrap_FSFormField_getControlCount([self getCptr], [page getCptr]);
}

-(FSFormControl*)getControl: (FSPDFPage*)page index: (int)index
{
    void* cPtr = _wrap_FSFormField_getControl([self getCptr], [page getCptr], index);
    FSFormControl* ret = nil;
    if(cPtr) {
        ret = [[[FSFormControl alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFormField((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


@implementation FSFormControl
- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(FSFormField*)getField
{
    void* cPtr = _wrap_FSFormControl_getField([self getCptr]);
    FSFormField* ret = nil;
    if(cPtr) {
        ret = [[[FSFormField alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFormControl((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


@implementation FSIdentityProperties
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(void)set: (NSString *)corporation email: (NSString *)email loginName: (NSString *)loginName name: (NSString *)name
{
    _wrap_FSIdentityProperties_set([self getCptr], corporation, email, loginName, name);
}

-(void)setCorporation: (NSString *)value
{
    _wrap_FSIdentityProperties_corporation_set([self getCptr], value);
}

-(NSString *)getCorporation
{
    return _wrap_FSIdentityProperties_corporation_get([self getCptr]);
}

-(void)setEmail: (NSString *)value
{
    _wrap_FSIdentityProperties_email_set([self getCptr], value);
}

-(NSString *)getEmail
{
    return _wrap_FSIdentityProperties_email_get([self getCptr]);
}

-(void)setLoginName: (NSString *)value
{
    _wrap_FSIdentityProperties_loginName_set([self getCptr], value);
}

-(NSString *)getLoginName
{
    return _wrap_FSIdentityProperties_loginName_get([self getCptr]);
}

-(void)setName: (NSString *)value
{
    _wrap_FSIdentityProperties_name_set([self getCptr], value);
}

-(NSString *)getName
{
    return _wrap_FSIdentityProperties_name_get([self getCptr]);
}

-(id)init
{
    
    if((self = [super init])) {
        void* cptr = _wrap_new_FSIdentityProperties();
        swigCPtr = cptr;
        swigCMemOwn = YES;
    }
    return self;
    
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSIdentityProperties((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


int FSActionHandler_getCurrentPage(id actionHandler, void* pdfDoc)
{
    FSPDFDoc* fsdoc = [[FSPDFDoc alloc] autorelease];
    [fsdoc initWithCptr:pdfDoc swigOwnCObject:NO];
    return [actionHandler getCurrentPage:fsdoc];
}
void FSActionHandler_setCurrentPage(id actionHandler, void* pdfDoc, int pageIndex)
{
    FSPDFDoc* fsdoc = [[FSPDFDoc alloc] autorelease];
    [fsdoc initWithCptr:pdfDoc swigOwnCObject:NO];
    [actionHandler setCurrentPage:fsdoc pageIndex:pageIndex];
}
int FSActionHandler_getPageRotation(id actionHandler, void* pdfDoc, int pageIndex)
{
    FSPDFDoc* fsdoc = [[FSPDFDoc alloc] autorelease];
    [fsdoc initWithCptr:pdfDoc swigOwnCObject:NO];
    return [actionHandler getPageRotation:fsdoc pageIndex:pageIndex];
}
BOOL FSActionHandler_setPageRotation(id actionHandler, void* pdfDoc, int pageIndex, int pageRotation)
{
    FSPDFDoc* fsdoc = [[FSPDFDoc alloc] autorelease];
    [fsdoc initWithCptr:pdfDoc swigOwnCObject:NO];
    return [actionHandler setPageRotation:fsdoc pageIndex:pageIndex rotation:(enum FS_ROTATION)pageRotation];
}

int FSActionHandler_alert(id actionHandler, NSString* msg, NSString* title, int type, int icon)
{
    return [actionHandler alert:msg title:title type:type icon:icon];
}

@implementation FSActionHandler

-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(id)init
{
    if(self = [super init])
    {
        swigCPtr = _wrap_FSActionHandler_init(self);
        swigCMemOwn = YES;
    }
    return self;
}

-(int)getCurrentPage:(FSPDFDoc*)pdfDoc
{
    return -1;
}

-(void)setCurrentPage:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex
{

}

-(enum FS_ROTATION)getPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex
{
    return e_rotationUnknown;
}

-(BOOL)setPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex rotation:(enum FS_ROTATION)rotation
{
    return FALSE;
}

-(int)alert: (NSString *)msg title: (NSString *)title type: (int)type icon: (int)icon
{
    return 0;
}

-(FSIdentityProperties*)getIdentityProperties
{
    return nil;
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSActionHandler((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}
@end


@implementation FSFileSpec
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

+(FSFileSpec*)create: (FSPDFDoc*)pdfDoc
{
    void* cPtr = _wrap_FSFileSpec_create([pdfDoc getCptr]);
    FSFileSpec* ret = nil;
    if(cPtr) {
        ret = [[[FSFileSpec alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(NSString *)getFileName
{
    return _wrap_FSFileSpec_getFileName([self getCptr]);
}

-(void)setFileName: (NSString *)fileName
{
    _wrap_FSFileSpec_setFileName([self getCptr], fileName);
}

-(unsigned long long)getFileSize
{
    return _wrap_FSFileSpec_getFileSize([self getCptr]);
}

-(FSFileReadCallback*)getFileData
{
    void* cPtr = _wrap_FSFileSpec_getFileData([self getCptr]);
    FSFileReadCallback* ret = nil;
    if(cPtr) {
        ret = [[[FSFileReadCallback alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(BOOL)embed: (NSString *)filePath
{
    return _wrap_FSFileSpec_embed([self getCptr], filePath);
}

-(BOOL)isEmbedded
{
    return _wrap_FSFileSpec_isEmbedded([self getCptr]);
}

-(NSString *)getDescription
{
    return _wrap_FSFileSpec_getDescription([self getCptr]);
}

-(void)setDescription: (NSString *)description
{
    _wrap_FSFileSpec_setDescription([self getCptr], description);
}

-(FSDateTime*)getCreationDateTime
{
    void* cPtr = _wrap_FSFileSpec_getCreationDateTime([self getCptr]);
    FSDateTime* ret = nil;
    if(cPtr) {
        ret = [[[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(void)setCreationDateTime: (FSDateTime*)dateTime
{
    _wrap_FSFileSpec_setCreationDateTime([self getCptr], [dateTime getCptr]);
}

-(FSDateTime*)getModifiedDateTime
{
    void* cPtr = _wrap_FSFileSpec_getModifiedDateTime([self getCptr]);
    FSDateTime* ret = nil;
    if(cPtr) {
        ret = [[[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(void)setModifiedDateTime: (FSDateTime*)dateTime
{
    _wrap_FSFileSpec_setModifiedDateTime([self getCptr], [dateTime getCptr]);
}

-(NSData *)getChecksum
{
    return _wrap_FSFileSpec_getChecksum([self getCptr]);
}

-(void)setChecksum: (NSData *)checksum
{
    _wrap_FSFileSpec_setChecksum([self getCptr], checksum);
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFileSpec((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


void FSFormFillerAssist_refresh(id formFillerAssist, void* page, void* rect)
{
    FSPDFPage* fspage = [FSPDFPage alloc];
    [fspage initWithCptr:page swigOwnCObject:NO];
    FSRectF* fsrect = [FSRectF alloc];
    [fsrect initWithCptr:rect swigOwnCObject:NO];
    [formFillerAssist refresh:fspage pdfRect:fsrect];
}

void FSFormFillerAssist_focusGotOnControl(id formFillerAssist, void* control, const char* fieldValue)
{
    FSFormControl* fscontrol = [FSFormControl alloc];
    [fscontrol initWithCptr:control swigOwnCObject:NO];
    [formFillerAssist focusGotOnControl:fscontrol fieldValue:[NSString stringWithCString:fieldValue encoding:NSUTF8StringEncoding]];
}

void FSFormFillerAssist_focusLostFromControl(id formFillerAssist, void* control, const char* fieldValue)
{
    FSFormControl* fscontrol = [FSFormControl alloc];
    [fscontrol initWithCptr:control swigOwnCObject:NO];
    [formFillerAssist focusLostFromControl:fscontrol fieldValue:[NSString stringWithCString:fieldValue encoding:NSUTF8StringEncoding]];
}

@implementation FSFormFillerAssist
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(id)init
{
    if(self = [super init])
    {
        swigCPtr = _wrap_FSFormFillerAssist_init(self);
        swigCMemOwn = YES;
    }
    return self;
}

-(int)getVersion
{
    return _wrap_FSFormFillerAssist_getVersion([self getCptr]);
}

-(void)refresh: (FSPDFPage*)page pdfRect: (FSRectF*)pdfRect
{
    _wrap_FSFormFillerAssist_refresh([self getCptr], [page getCptr], [pdfRect getCptr]);
}

-(BOOL)setTimer: (int)elapse timerFunc: (FS_CALLBACK_TIMER)timerFunc timerID: (int *)timerID
{
    return _wrap_FSFormFillerAssist_setTimer([self getCptr], elapse, timerFunc, timerID);
}

-(BOOL)killTimer: (int)timerID
{
    return _wrap_FSFormFillerAssist_killTimer([self getCptr], timerID);
}

-(void)focusGotOnControl: (FSFormControl*)control fieldValue: (NSString *)fieldValue
{
    _wrap_FSFormFillerAssist_focusGotOnControl([self getCptr], [control getCptr], fieldValue);
}

-(void)focusLostFromControl: (FSFormControl*)control fieldValue: (NSString *)fieldValue
{
    _wrap_FSFormFillerAssist_focusLostFromControl([self getCptr], [control getCptr], fieldValue);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFormFillerAssist((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end


@implementation FSFormFiller
-(void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

+(FSFormFiller*)create: (FSForm*)form assist: (FSFormFillerAssist*)assist
{
    void* cPtr = _wrap_FSFormFiller_create([form getCptr], [assist getCptr]);
    FSFormFiller* ret = nil;
    if(cPtr) {
        ret = [[FSFormFiller alloc] initWithCptr:cPtr swigOwnCObject:YES];
    }
    return [ret autorelease];
}

-(void)render: (FSPDFPage*)page matrix:(FSMatrix*)matrix renderer:(FSRenderer*)renderer
{
    _wrap_FSFormFiller_render([self getCptr], [page getCptr], [matrix getCptr], [renderer getCptr]);
}

-(BOOL)tap: (FSPDFPage*)page point: (FSPointF*)point
{
    return _wrap_FSFormFiller_tap([self getCptr], [page getCptr], [point getCptr]);
}

-(BOOL)input: (unsigned int)charCode
{
    return _wrap_FSFormFiller_input([self getCptr], charCode);
}

-(void)highlightFormFields: (BOOL)isHighlight
{
    _wrap_FSFormFiller_highlightFormFields([self getCptr], isHighlight);
}

-(void)setHighlightColor: (unsigned int)color
{
    _wrap_FSFormFiller_setHighlightColor([self getCptr], color);
}


-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSFormFiller((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end

@implementation FSSignatureCallback
- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(NSData*)getCertData: (NSString *)certPath certPassword: (NSString *)certPassword clientData: (NSObject *)clientData
{
    return nil;
}

-(NSData*)sign: (NSData *)digest certPath: (NSString *)certPath certPassword: (NSString*)certPassword digestAlgorithm: (enum FS_DIGEST_ALGORITHM)digestAlgorithm clientData: (NSObject *)clientData
{
    return nil;
}

@end


@implementation FSSignature
- (void*)getCptr {
    return swigCPtr;
}

-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject {
    if((self = [super init])) {
        swigCPtr = cptr;
        swigCMemOwn = ownCObject;
    }
    return self;
}

-(BOOL)isSigned
{
    return _wrap_FSSignature_isSigned([self getCptr]);
}

-(enum FS_PROGRESSSTATE)startSign: (NSString *)savePath certPath:(NSString *)certPath certPassword:(NSString*)certPassword digestAlgorithm:(enum FS_DIGEST_ALGORITHM)digestAlgorithm pause: (FSPauseCallback*)pause clientData:(void*)clientData;
{
    return (enum FS_PROGRESSSTATE)_wrap_FSSignature_startSign([self getCptr], savePath, certPath, certPassword,
                                                              digestAlgorithm, [pause getCptr], clientData);
}

-(enum FS_PROGRESSSTATE)continueSign
{
    return (enum FS_PROGRESSSTATE)_wrap_FSSignature_continueSign([self getCptr]);
}

-(enum FS_PROGRESSSTATE)startVerify: (FSPauseCallback*)pause clientData:(void*)clientData
{
    return (enum FS_PROGRESSSTATE)_wrap_FSSignature_startVerify([self getCptr], [pause getCptr], clientData);
}

-(enum FS_PROGRESSSTATE)continueVerify
{
    return (enum FS_PROGRESSSTATE)_wrap_FSSignature_continueVerify([self getCptr]);
}

-(unsigned int)getState
{
    return _wrap_FSSignature_getState([self getCptr]);
}

-(BOOL)clearSignedData
{
    return _wrap_FSSignature_clearSignedData([self getCptr]);
}

-(FSPDFDoc*)getDocument
{
    void* cPtr = _wrap_FSSignature_getDocument([self getCptr]);
    FSPDFDoc* ret = nil;
    if(cPtr) {
        ret = [[[FSPDFDoc alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(unsigned int)getAppearanceFlags
{
    return _wrap_FSSignature_getAppearanceFlags([self getCptr]);
}

-(void)setAppearanceFlags: (unsigned int)apFlags
{
    _wrap_FSSignature_setAppearanceFlags([self getCptr], apFlags);
}

-(FSDateTime*)getSigningTime
{
    void* cPtr = _wrap_FSSignature_getSigningTime([self getCptr]);
    FSDateTime* ret = nil;
    if(cPtr) {
        ret = [[[FSDateTime alloc] initWithCptr:cPtr swigOwnCObject:YES] autorelease];
    }
    return ret;
}

-(void)setSigningTime: (FSDateTime*)signTime
{
    _wrap_FSSignature_setSigningTime([self getCptr], [signTime getCptr]);
}

-(NSString *)getKeyValue: (enum FS_SIGNATUREKEYNAME)key
{
    return _wrap_FSSignature_getKeyValue([self getCptr], (int)key);
}

-(void)setKeyValue: (enum FS_SIGNATUREKEYNAME)key value: (NSString *)value
{
    _wrap_FSSignature_setKeyValue([self getCptr], (int)key, value);
}

-(FSBitmap*)getBitmap
{
    void* cPtr = _wrap_FSSignature_getBitmap([self getCptr]);
    FSBitmap* ret = nil;
    if(cPtr) {
        ret = [[[FSBitmap alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(void)setBitmap: (FSBitmap*)bitmap
{
    _wrap_FSSignature_setBitmap([self getCptr], [bitmap getCptr]);
}

-(void)setImagePath: (NSString*)imagePath
{
    _wrap_FSSignature_setImagePath([self getCptr], imagePath);
}

-(FSPDFDictionary*)getSignatureDict
{
    void* cPtr = _wrap_FSSignature_getSignatureDict([self getCptr]);
    FSPDFDictionary* ret = nil;
    if(cPtr) {
        ret = [[[FSPDFDictionary alloc] initWithCptr:cPtr swigOwnCObject:NO] autorelease];
    }
    return ret;
}

-(void)setAppearanceContent: (NSString *)appearanceContent
{
    _wrap_FSSignature_setAppearanceContent([self getCptr], appearanceContent);
}

-(void)setSignatureHandler: (FSSignatureCallback *)siangtureHandler
{
    _wrap_FSSignature_setSignatureHandler([self getCptr], siangtureHandler);
}

-(void)dealloc{
    
    if (swigCPtr != NULL) {
        if (swigCMemOwn) {
            _wrap_delete_FSSignature((void*)swigCPtr);
            swigCMemOwn = NO;
        }
        swigCPtr = NULL;
    }
    [super dealloc];
    
}

@end
#if 1
#import <UIKit/UIDevice.h>

static NSString * identifierForVendor1()
{
    if ([[UIDevice currentDevice] respondsToSelector:@selector(identifierForVendor)]) {
        return [[[UIDevice currentDevice] identifierForVendor] UUIDString];
    }
    return @"";
}

#undef LogOut
//#define LogOut           printf
#define LogOut           ((void)0)


#include <string>
using namespace std;

std::string getMobileMacAddr()
{
    NSString* origin = identifierForVendor1();
    if (origin == nil || [origin isEqualToString:@""]) {
        return "00-00-00-00-00-00";
    }
    string result;
    
    NSString* substr = [origin substringFromIndex:origin.length-12];
    result.assign([substr UTF8String], substr.length);
    result.insert(result.begin()+2, 1, '-');
    result.insert(result.begin()+5, 1, '-');
    result.insert(result.begin()+8, 1, '-');
    result.insert(result.begin()+11, 1, '-');
    result.insert(result.begin()+14, 1, '-');
    return result;
}
#else
#include <sys/sysctl.h>
#include <net/if.h>
#include <net/if_dl.h>

#undef LogOut
//#define LogOut           printf
#define LogOut           ((void)0)


#include <string>
using namespace std;
// Return the local MAC addy
// Courtesy of FreeBSD hackers email list
// Accidentally munged during previous update. Fixed thanks to mlamb.
std::string getMobileMacAddr()
{
    
    int                 mib[6];
    size_t              len;
    char                *buf;
    unsigned char       *ptr;
    struct if_msghdr    *ifm;
    struct sockaddr_dl  *sdl;
    
    mib[0] = CTL_NET;
    mib[1] = AF_ROUTE;
    mib[2] = 0;
    mib[3] = AF_LINK;
    mib[4] = NET_RT_IFLIST;
    
    if ((mib[5] = if_nametoindex("en0")) == 0) {
        printf("Error: if_nametoindex error/n");
        return "";
    }
    
    if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 1/n");
        return "";
    }
    
    if ((buf = (char*)malloc(len)) == NULL) {
        printf("Could not allocate memory. error!/n");
        return "";
    }
    
    if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 2");
        return "";
    }
    
    ifm = (struct if_msghdr *)buf;
    sdl = (struct sockaddr_dl *)(ifm + 1);
    ptr = (unsigned char *)LLADDR(sdl);
    char mac[32] = {0};
    sprintf(mac, "%02X-%02X-%02X-%02X-%02X-%02X",*ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5));
    
    free(buf);
    
    return string(mac);
}
#endif

